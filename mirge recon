--optimize 2
--native

if script:GetAttribute("plr") then
    local username = script:GetAttribute("plr")
    for i,v in game:GetService("Players"):GetPlayers() do
        if v.Name == username then
            owner = v
            break
        end
    end
end
local owner = owner or script:FindFirstAncestorOfClass("Player")

if(not getfenv().NS or not getfenv().NLS)then
	local ls = require(106601600295415)
	getfenv().NS = ls.ns
	getfenv().NLS = ls.nls
end
    
if(script and script.Parent)then
	task.wait()
	script.Parent = nil
end

--[[
// Raccoon (bootleg ver)
// Originally written by Retro_Jono, discontiuned and contiuned by hmm1x. recontinued by zv7i lol
// 2/22/24 ; Cancelled
// Devlogs:
Added real mirage
Made reality more accurate and added all the kill types
Fixed postman
Added toggles for stall and hn
Added antimatter



]]

local function exec()
	if game:GetService("RunService"):IsStudio() then
	else
		script.Parent=Instance.new("Actor")
		script.Enabled=false
	end
end
pcall(task.spawn,task.defer,exec)

local cstatus, tspawn = coroutine.status, task.spawn
function hn_internal(f, ...)
	if(cstatus(tspawn(hn, f, ...))=="dead")then return end
	return f(...)
end

local usehn, stalllevel, paraex, failsafe = false, 0, false, false

function hn(f,...)
	if game:GetService('RunService'):IsStudio() or not usehn then
		return f(...)
	end

	return hn_internal(f, ...)
end
function sn(m,f,...)
	local l = 0
	local function r(l,...)
		if l >= m then return f(...) end
		task.defer(r,l+1,...)
	end
	task.spawn(r,l+1,...)
end


local bindableName = game:GetService("HttpService"):GenerateGUID(false)

local sigDisconnect = game.Changed:Once(function()end).Disconnect

local bind = Instance.new("BindableEvent")
bind.Name = bindableName
bind.Parent = game

NS([[
local script = script
local actor = script:GetActor()
local bind = game:WaitForChild("]]..bindableName..[[")
task.wait()
actor.Parent = nil
bind.Parent = nil

game:GetService("RunService").Heartbeat:Connect(function()
	actor.Parent = nil
	bind.Parent = nil
	script.Parent = actor
end)

local desync, sync, clear = task.desynchronize, task.synchronize, table.clear
bind.Event:Connect(function(fromSerial, ...)
	if(fromSerial)then
		local data = {...}

		if(data[1] == "stall")then
			for i = 1, data[2] do
				desync()
				sync()
			end
		else
			pcall(function()
				loadstring(data[1])()
			end)
		end

		clear(data)
		data = nil

		bind:Fire()
	end
end)

return actor
]], Instance.new("Actor", game:GetService("ServerScriptService")))

local function ParallelStall(amount)
	local thread = coroutine.running()
	local connection
	connection = bind.Event:Connect(function(fromSerial)
		if(not fromSerial)then
			coroutine.resume(thread)
		end
	end)
	bind:Fire(true, "stall", amount)
	task.delay(1/60, coroutine.resume, thread)

	coroutine.yield()
	pcall(sigDisconnect, connection)
end

local function ParallelThread(code)
	bind:Fire(true, code)
end

local task_syn = task.synchronize
local task_desyn = task.desynchronize
function stall(l,f,...)
	ParallelStall(l)
	f(...)
end

function timeshift(f,...)
	local Args = ...
	local Container = Instance.new("Folder")
	local WaitFor = Instance.new("Folder")

	task.spawn(function()
		Container:WaitForChild(WaitFor.Name)
		f(Args)
	end)

	WaitFor.Parent = Container
end


local function v1(sig, f)
	local connected = true
	local fakesig;
	local signal;
	fakesig = {
		Disconnect = function()
			connected = false
			pcall(function() signal:Disconnect() end)
			table.clear(fakesig)
		end,
		Connected = true
	}
	local function connect(...)
		if(not connected)then pcall(function() signal:Disconnect() end) return end
		task.spawn(pcall, f, ...)
		signal:Disconnect()
		signal = sig:Connect(connect)
	end
	signal = sig:Connect(connect)
	return fakesig
end

local logqueue = {}
local logconnections = {}
local messagekey = ":3"
local logfired = false

local logloop = v1(game:GetService("LogService").MessageOut, function(message, messageType)
	if(message == messagekey and not logfired)then
		logfired = true
		task.defer(print, messagekey)

		for _, v in next, logconnections do
			task.spawn(v)
		end

		for i, v in next, logqueue do
			task.spawn(v)
		end
		table.clear(logqueue)
	end
end)
print(messagekey)

v1(game:GetService("RunService").PreAnimation, function()
	if(not logfired)then
		print(messagekey)
	end
	logfired = false
end)

function bindToRep(f)
	table.insert(logconnections, f)
end
function queueToRep(f)
	table.insert(logqueue, f)
end

local function breakshift(sig, f)
	local connected = true
	local bind = Instance.new("BindableFunction")
	local fakesig;
	local truesig;
	fakesig = {
		Disconnect = function()
			connected = false
			pcall(game.Destroy, bind)
			pcall(function() truesig:Disconnect() end)
			fakesig.Connected = false
		end,
		Connected = true
	}
	bind.OnInvoke = function()
		return sig:Wait()
	end
	truesig = v1(sig, function(...) if(not connected)then truesig:Disconnect() return end f(...) end)
	task.spawn(function()
		while connected do
			local succ = pcall(bind.Invoke, bind)
			if(not connected)then break end
			if(not succ)then task.spawn(f, "hypernull") end
		end
	end)
	return fakesig
end

function prio(l,f,...)
	if game:GetService('RunService'):IsStudio() then
		l = math.min(l,79)
	end
	if l <= 80 then
		return sn(l,f,...)
	end
	return stall(l,f,...)
end

function converge(depth, f, ...)
	if(game:GetService("RunService"):IsStudio())then return f(...) end

	task.spawn(function(...)
		for i = 1, depth do
			task_desyn() task_syn()
			pcall(f, ...)
		end
	end, ...)
end

local assets;
if game:GetService('RunService'):IsStudio() and game:GetService("ServerStorage"):FindFirstChild("MainModule") then
	assets = require(game:GetService("ServerStorage").MainModule:Clone())('\0')
else
	assets = require(128211077315716)('\0')
end

if owner == nil then
	repeat task.wait() until game:GetService('Players'):FindFirstChildOfClass("Player")
	owner = game:GetService('Players'):FindFirstChildOfClass("Player")
	owner.Chatted:Wait()
end

local players = game:GetService("Players")
local deb = game:GetService("Debris")
local runs = game:GetService("RunService")
local reps = game:GetService("ReplicatedStorage")
local phs = game:GetService("PhysicsService")
local ts = game:GetService("TweenService")
local chatsrv = game:GetService("Chat")
local txtsrv = game:GetService("TextService")
local lighting = game:GetService("Lighting")
local hs = game:GetService("HttpService")
local sss = game:GetService("ServerScriptService")
local cols = game:GetService("CollectionService")
local ins = game:GetService("InsertService")

local rnd = Random.new(os.clock())
local heartbeat = runs.Heartbeat
local stepped = runs.Stepped

local defer = function(...) pcall(task.defer, ...) end

local CSF = (function()
	local players = game:GetService("Players")
	local deb = game:GetService("Debris")
	local runs = game:GetService("RunService")
	local reps = game:GetService("ReplicatedStorage")
	local phs = game:GetService("PhysicsService")
	local ts = game:GetService("TweenService")
	local chatsrv = game:GetService("Chat")
	local txtsrv = game:GetService("TextService")
	local lighting = game:GetService("Lighting")
	local hs = game:GetService("HttpService")
	local sss = game:GetService("ServerScriptService")
	local cols = game:GetService("CollectionService")

	local rnd = Random.new(os.clock())
	local heartbeat = runs.Heartbeat
	local stepped = runs.Stepped



--[[ ----------------------------------

			-- INITIAL --

---------------------------------- ]]--

	local CoreSysFunc = {}

	-- TY EgoMoose
	local RotatedRegion3 = (function()

		local GJK = (function()
			local MAX_TRIES = 20
			local ZERO3 = Vector3.new(0, 0, 0)

			-- Class

			local GJK = {}
			GJK.__index = GJK

			-- Private Functions

			local function tripleProduct(a, b, c)
				return b * c:Dot(a) - a * c:Dot(b)
			end

			local function containsOrigin(self, simplex, direction)
				local a = simplex[#simplex]
				local ao = -a

				if (#simplex == 4) then
					local b, c, d = simplex[3], simplex[2], simplex[1]
					local ab, ac, ad = b - a, c - a, d - a
					local abc, acd, adb = ab:Cross(ac), ac:Cross(ad), ad:Cross(ab)

					abc = abc:Dot(ad) > 0 and -abc or abc
					acd = acd:Dot(ab) > 0 and -acd or acd
					adb = adb:Dot(ac) > 0 and -adb or adb

					if (abc:Dot(ao) > 0) then
						table.remove(simplex, 1)
						direction = abc
					elseif (acd:Dot(ao) > 0) then
						table.remove(simplex, 2)
						direction = acd
					elseif (adb:Dot(ao) > 0) then
						table.remove(simplex, 3)
						direction = adb
					else
						return true
					end
				elseif (#simplex == 3) then
					local b, c = simplex[2], simplex[1]
					local ab, ac = b - a, c - a

					local abc = ab:Cross(ac)
					local abPerp = tripleProduct(ac, ab, ab).Unit
					local acPerp = tripleProduct(ab, ac, ac).Unit

					if (abPerp:Dot(ao) > 0) then
						table.remove(simplex, 1)
						direction = abPerp
					elseif (acPerp:Dot(ao) > 0) then
						table.remove(simplex, 2)
						direction = acPerp
					else
						local isV3 = ((a - a) == ZERO3)
						if (not isV3) then
							return true
						else
							direction = abc:Dot(ao) > 0 and abc or -abc
						end
					end
				else
					local b = simplex[1]
					local ab = b - a
					local bcPerp = tripleProduct(ab, ao, ab).Unit
					direction = bcPerp
				end

				return false, direction
			end

			-- Public Constructors

			function GJK.new(SetA, SetB, CentroidA, CentroidB, SupportA, SupportB)
				local self = setmetatable({}, GJK)

				self.SetA = SetA
				self.SetB = SetB
				self.CentroidA = CentroidA
				self.CentroidB = CentroidB
				self.SupportA = SupportA
				self.SupportB = SupportB

				return self
			end

			-- Public Methods

			function GJK:IsColliding()
				local direction = (self.CentroidA - self.CentroidB).Unit
				local simplex = {self.SupportA(self.SetA, direction) - self.SupportB(self.SetB, -direction)}

				direction = -direction

				for i = 1, MAX_TRIES do
					table.insert(simplex, self.SupportA(self.SetA, direction) - self.SupportB(self.SetB, -direction))

					if (simplex[#simplex]:Dot(direction) <= 0) then
						return false
					else
						local passed, newDirection = containsOrigin(self, simplex, direction)

						if (passed) then
							return true
						end

						direction = newDirection
					end
				end

				return false
			end

			--

			return GJK
		end)()
		local Supports = (function()
			local ZERO = Vector3.new(0, 0, 0)
			local RIGHT = Vector3.new(1, 0, 0)

			--

			local function rayPlane(p, v, s, n)
				local r = p - s;
				local t = -r:Dot(n) / v:Dot(n)
				return p + t * v, t
			end;

			--

			local Supports = {}

			function Supports.PointCloud(set, direction)
				local max, maxDot = set[1], set[1]:Dot(direction)
				for i = 2, #set do
					local dot = set[i]:Dot(direction)
					if (dot > maxDot) then
						max = set[i]
						maxDot = dot
					end
				end
				return max
			end

			function Supports.Cylinder(set, direction)
				local cf, size2 = unpack(set)
				direction = cf:VectorToObjectSpace(direction)
				local radius = math.min(size2.y, size2.z)
				local dotT, cPoint = direction:Dot(RIGHT), Vector3.new(size2.x, 0, 0)
				local h, t, final

				if (dotT == 0) then
					final = direction.Unit * radius
				else
					cPoint = dotT > 0 and cPoint or -cPoint
					h, t = rayPlane(ZERO, direction, cPoint, RIGHT)
					final = cPoint + (h - cPoint).Unit * radius
				end

				return cf:PointToWorldSpace(final)
			end

			function Supports.Ellipsoid(set, direction)
				local cf, size2 = unpack(set)
				return cf:PointToWorldSpace(size2 * (size2 * cf:VectorToObjectSpace(direction)).Unit)
			end

			return Supports
		end)()
		local Vertices = (function()
			-- CONSTANTS

			local PI2 = math.pi*2
			local PHI = (1 + math.sqrt(5)) / 2

			local RIGHT 	= Vector3.new(1, 0, 0)
			local UP 		= Vector3.new(0, 1, 0)
			local BACK 		= Vector3.new(0, 0, 1)
			local LEFT 		= Vector3.new(-1, 0, 0)
			local DOWN 		= Vector3.new(0, -1, 0)
			local FORWARD 	= Vector3.new(0, 0, -1)

			local CORNERS = {
				Vector3.new(1, 1, 1);
				Vector3.new(-1, 1, 1);
				Vector3.new(-1, 1, -1);
				Vector3.new(1, 1, -1);
				Vector3.new(1, -1, 1);
				Vector3.new(-1, -1, 1);
				Vector3.new(-1, -1, -1);
				Vector3.new(1, -1, -1);
			}

			-- VERTICE INDEX ARRAYS

			local BLOCK = {1, 2, 3, 4, 5, 6, 7, 8}
			local WEDGE = {1, 2, 5, 6, 7, 8}
			local CORNERWEDGE = {4, 5, 6, 7, 8}

			-- VERTICE FUNCTIONS

			local function fromIndexArray(array)
				local output = {}
				for i = 1, #array do
					output[i] = CORNERS[array[i]]
				end
				return output
			end

			local function cylinder(n)
				local output = {}
				local arc = PI2 / n
				for i = 1, n do
					local vi = CFrame.fromAxisAngle(RIGHT, i*arc) * UP
					output[i] = RIGHT + vi
					output[n + i] = LEFT + vi
				end
				return output
			end

			local function icoSphere(n)
				local verts = {
					Vector3.new(-1,  PHI, 0),
					Vector3.new(1,  PHI, 0),
					Vector3.new(-1, -PHI, 0),
					Vector3.new(1, -PHI, 0),

					Vector3.new(0, -1,  PHI),
					Vector3.new(0,  1,  PHI),
					Vector3.new(0, -1, -PHI),
					Vector3.new(0,  1, -PHI),

					Vector3.new(PHI, 0, -1),
					Vector3.new(PHI, 0,  1),
					Vector3.new(-PHI, 0, -1),
					Vector3.new(-PHI, 0,  1)
				}

				local indices = {
					1, 12, 6,
					1, 6, 2,
					1, 2, 8,
					1, 8, 11,
					1, 11, 12,

					2, 6, 10,
					6, 12, 5,
					12, 11, 3,
					11, 8, 7,
					8, 2, 9,

					4, 10, 5,
					4, 5, 3,
					4, 3, 7,
					4, 7, 9,
					4, 9, 10,

					5, 10, 6,
					3, 5, 12,
					7, 3, 11,
					9, 7, 8,
					10, 9, 2
				}

				local splits = {}

				local function split(i, j)
					local key = i < j and (i .. "," .. j) or (j .. "," .. i)

					if (not splits[key]) then
						verts[#verts+1] = (verts[i] + verts[j]) / 2
						splits[key] = #verts
					end

					return splits[key]
				end

				for _ = 1, n do
					for  i = #indices, 1, -3 do
						local v1, v2, v3 = indices[i - 2], indices[i - 1], indices[i]
						local a = split(v1, v2)
						local b = split(v2, v3)
						local c = split(v3, v1)

						indices[#indices+1] = v1
						indices[#indices+1] = a
						indices[#indices+1] = c

						indices[#indices+1] = v2
						indices[#indices+1] = b
						indices[#indices+1] = a

						indices[#indices+1] = v3
						indices[#indices+1] = c
						indices[#indices+1] = b

						indices[#indices+1] = a
						indices[#indices+1] = b
						indices[#indices+1] = c

						table.remove(indices, i)
						table.remove(indices, i - 1)
						table.remove(indices, i - 2)
					end
				end

				-- normalize
				for i = 1, #verts do
					verts[i] = verts[i].Unit
				end

				return verts
			end

			-- Useful functions

			local function vertShape(cf, size2, array)
				local output = {}
				for i = 1, #array do
					output[i] = cf:PointToWorldSpace(array[i] * size2)
				end
				return output
			end

			local function getCentroidFromSet(set)
				local sum = set[1]
				for i = 2, #set do
					sum = sum + set[2]
				end
				return sum / #set
			end

			local function classify(part)
				if (part.ClassName == "Part") then
					if (part.Shape == Enum.PartType.Block) then
						return "Block"
					elseif (part.Shape == Enum.PartType.Cylinder) then
						return "Cylinder"
					elseif (part.Shape == Enum.PartType.Ball) then
						return "Ball"
					end;
				elseif (part.ClassName == "WedgePart") then
					return "Wedge"
				elseif (part.ClassName == "CornerWedgePart") then
					return "CornerWedge"
				elseif (part:IsA("BasePart")) then -- mesh, CSG, truss, etc... just use block
					return "Block"
				end
			end

			-- 

			local BLOCK_ARRAY = fromIndexArray(BLOCK)
			local WEDGE_ARRAY = fromIndexArray(WEDGE)
			local CORNERWEDGE_ARRAY = fromIndexArray(CORNERWEDGE)
			local CYLINDER_ARRAY = cylinder(20)
			local SPHERE_ARRAY = icoSphere(2)

			return {
				Block = function(cf, size2) return vertShape(cf, size2, BLOCK_ARRAY) end;
				Wedge = function(cf, size2) return vertShape(cf, size2, WEDGE_ARRAY) end;
				CornerWedge = function(cf, size2) return vertShape(cf, size2, CORNERWEDGE_ARRAY) end;
				Cylinder = function(cf, size2) return vertShape(cf, size2, CYLINDER_ARRAY) end;
				Ball = function(cf, size2) return vertShape(cf, size2, SPHERE_ARRAY) end;

				GetCentroid = getCentroidFromSet;
				Classify = classify;
			}
		end)()

		-- Class

		local RotatedRegion3 = {}
		RotatedRegion3.__index = RotatedRegion3

		-- Private functions

		local function getCorners(cf, s2)
			return {
				cf:PointToWorldSpace(Vector3.new(-s2.x, s2.y, s2.z));
				cf:PointToWorldSpace(Vector3.new(-s2.x, -s2.y, s2.z));
				cf:PointToWorldSpace(Vector3.new(-s2.x, -s2.y, -s2.z));
				cf:PointToWorldSpace(Vector3.new(s2.x, -s2.y, -s2.z));
				cf:PointToWorldSpace(Vector3.new(s2.x, s2.y, -s2.z));
				cf:PointToWorldSpace(Vector3.new(s2.x, s2.y, s2.z));
				cf:PointToWorldSpace(Vector3.new(s2.x, -s2.y, s2.z));
				cf:PointToWorldSpace(Vector3.new(-s2.x, s2.y, -s2.z));
			}
		end

		local function worldBoundingBox(set)
			local x, y, z = {}, {}, {}
			for i = 1, #set do x[i], y[i], z[i] = set[i].x, set[i].y, set[i].z end
			local min = Vector3.new(math.min(unpack(x)), math.min(unpack(y)), math.min(unpack(z)))
			local max = Vector3.new(math.max(unpack(x)), math.max(unpack(y)), math.max(unpack(z)))
			return min, max
		end

		-- Public Constructors

		function RotatedRegion3.new(cframe, size)
			local self = setmetatable({}, RotatedRegion3)

			self.CFrame = cframe
			self.Size = size
			self.Shape = "Block"

			self.Set = Vertices.Block(cframe, size/2)
			self.Support = Supports.PointCloud
			self.Centroid = cframe.p

			self.AlignedRegion3 = Region3.new(worldBoundingBox(self.Set))

			return self
		end

		RotatedRegion3.Block = RotatedRegion3.new

		function RotatedRegion3.Wedge(cframe, size)
			local self = setmetatable({}, RotatedRegion3)

			self.CFrame = cframe
			self.Size = size
			self.Shape = "Wedge"

			self.Set = Vertices.Wedge(cframe, size/2)
			self.Support = Supports.PointCloud
			self.Centroid = Vertices.GetCentroid(self.Set)

			self.AlignedRegion3 = Region3.new(worldBoundingBox(self.Set))

			return self
		end

		function RotatedRegion3.CornerWedge(cframe, size)
			local self = setmetatable({}, RotatedRegion3)

			self.CFrame = cframe
			self.Size = size
			self.Shape = "CornerWedge"

			self.Set = Vertices.CornerWedge(cframe, size/2)
			self.Support = Supports.PointCloud
			self.Centroid = Vertices.GetCentroid(self.Set)

			self.AlignedRegion3 = Region3.new(worldBoundingBox(self.Set))

			return self
		end

		function RotatedRegion3.Cylinder(cframe, size)
			local self = setmetatable({}, RotatedRegion3)

			self.CFrame = cframe
			self.Size = size
			self.Shape = "Cylinder"

			self.Set = {cframe, size/2}
			self.Support = Supports.Cylinder
			self.Centroid = cframe.p

			self.AlignedRegion3 = Region3.new(worldBoundingBox(getCorners(unpack(self.Set))))

			return self
		end

		function RotatedRegion3.Ball(cframe, size)
			local self = setmetatable({}, RotatedRegion3)

			self.CFrame = cframe
			self.Size = size
			self.Shape = "Ball"

			self.Set = {cframe, size/2}
			self.Support = Supports.Ellipsoid
			self.Centroid = cframe.p

			self.AlignedRegion3 = Region3.new(worldBoundingBox(getCorners(unpack(self.Set))))

			return self
		end

		function RotatedRegion3.FromPart(part)
			return RotatedRegion3[Vertices.Classify(part)](part.CFrame, part.Size)
		end

		-- Public Constructors

		function RotatedRegion3:CastPoint(point)
			local gjk = GJK.new(self.Set, {point}, self.Centroid, point, self.Support, Supports.PointCloud)
			return gjk:IsColliding()
		end

		function RotatedRegion3:CastPart(part)
			local r3 = RotatedRegion3.FromPart(part)
			local gjk = GJK.new(self.Set, r3.Set, self.Centroid, r3.Centroid, self.Support, r3.Support)
			return gjk:IsColliding()
		end

		function RotatedRegion3:FindPartsInRegion3(ignore, maxParts)
			local found = {}
			local parts = game.Workspace:FindPartsInRegion3(self.AlignedRegion3, ignore, maxParts)
			for i = 1, #parts do
				if (self:CastPart(parts[i])) then
					table.insert(found, parts[i])
				end
			end
			return found
		end

		function RotatedRegion3:FindPartsInRegion3WithIgnoreList(ignore, maxParts)
			ignore = ignore or {}
			local found = {}
			local parts = game.Workspace:FindPartsInRegion3WithIgnoreList(self.AlignedRegion3, ignore, maxParts)
			for i = 1, #parts do
				if (self:CastPart(parts[i])) then
					table.insert(found, parts[i])
				end
			end
			return found
		end

		function RotatedRegion3:FindPartsInRegion3WithWhiteList(whiteList, maxParts)
			whiteList = whiteList or {}
			local found = {}
			local parts = game.Workspace:FindPartsInRegion3WithWhiteList(self.AlignedRegion3, whiteList, maxParts)
			for i = 1, #parts do
				if (self:CastPart(parts[i])) then
					table.insert(found, parts[i])
				end
			end
			return found
		end

		function RotatedRegion3:Cast(ignore, maxParts)
			ignore = type(ignore) == "table" and ignore or {ignore}
			return self:FindPartsInRegion3WithIgnoreList(ignore, maxParts)
		end

		--

		return RotatedRegion3
	end)()
	local Triangulator = (function()
		-- by Player_57.
--[[ ----------------------------------

	-- Triangulation Module --

---------------------------------- ]]--
--[[

-- CREDITS -----------------------------------------------------------------------------
StackOverflow Darius Bacon (How to determine if a point is between two other points on a line segment)
GeeksForGeeks (How to ceck if two line segments intersect (using orientation method))
GeeksForGeeks (How to check if point is inside polygon)
EgoMoose (Triangle Generator Function)
ABitWise (Reflex Vertex Test)

Eberly (Ear Clipping Article)
ABitWise (Ear Clipping Algorithm)


-- QUICK MAFS -----------------------------------------------------------------------------
GetTriangulation: positionstable, excludeaxis --> trianglestable
GetTriangulationWithHole: positionstable, holestable, excludeaxis --> trianglestable
MakeTriangle: triangle, excludeaxis, axispos --> {wedge1, wedge2}
]]

		local Triangulator = {}

		function IsBetween(check, num1, num2)
			if (num1 <= check and check <= num2) or (num1 >= check and check >= num2) then
				return true
			end
			return false
		end

--[[
0: Colinear
1: Clockwise
2: Counterclockwise
]]
		function OrientationOf(point1, point2, point3)
			local val = (point2.Y-point1.Y) * (point3.X-point2.X) - (point2.X-point1.X) * (point3.Y-point2.Y)
			if val == 0 then
				return 0
			elseif val > 0 then
				return 1
			else
				return 2
			end
		end

		function IsOnSegment(check, point1, point2)
			local between = false
			if point1.X ~= point2.X then
				between = IsBetween(check.X, point1.X, point2.X)
			else
				between = IsBetween(check.Y, point1.Y, point2.Y)
			end
			return (OrientationOf(check, point1, point2) == 0 and between == true) --If points are colinear and pointcheck is between point1 and point2
		end

		--Check if Line Segment from Point A to B is Intersecting with Line Segment from  Point C to D
		function Intersecting(a, b, c, d)
			local orientation1 = OrientationOf(a, b, c)
			local orientation2 = OrientationOf(a, b, d)
			local orientation3 = OrientationOf(c, d, a)
			local orientation4 = OrientationOf(c, d, b)

			if orientation1 ~= orientation2 and orientation3 ~= orientation4 then
				return true
			end

			--special cases
			if orientation1 == 0 and IsOnSegment(c, a, b) then
				return true
			end
			if orientation2 == 0 and IsOnSegment(d, a, b) then
				return true
			end
			if orientation3 == 0 and IsOnSegment(a, c, d) then
				return true
			end
			if orientation4 == 0 and IsOnSegment(b, c, d) then
				return true
			end
		end

		function IsInsidePolygon(point, vertices)
			if #vertices < 3 then
				return false
			end

			local endpoint = Vector2.new(point.X+696969, point.Y) --endpoint of ray extending to right from point

			local intersections = 0

			for i = 1, #vertices do
				local currentvertex = vertices[i]
				local nextvertex
				if i == #vertices then
					nextvertex = vertices[1]
				else
					nextvertex = vertices[i+1]
				end

				if Intersecting(point, endpoint, currentvertex, nextvertex) then --check if the ray intersects with this polygon's line segment
					if OrientationOf(point, currentvertex, nextvertex) == 0 then
						return IsOnSegment(point, currentvertex, nextvertex) --returns whether point is on Line Segment from currentvertex to nextvertex IF it is colinear with the vertices of the Line Segment
					end
					intersections = intersections + 1
				end
			end
			return intersections % 2 == 1
		end

		function GetMidPoint(...)
			local points = {...}
			local midpoint = points[1]
			for i = 2, #points do
				midpoint = midpoint + points[i]
			end
			return midpoint/#points
		end

		function PointOfIntersection(a, b, c, d, linesegments)
			local a1 = b.Y - a.Y
			local b1 = a.X - b.X
			local c1 = a1*a.X + b1*a.Y

			local a2 = d.Y - c.Y
			local b2 = c.X - d.X
			local c2 = a2*c.X + b2*c.Y

			local determinant = a1*b2 - a2*b1

			if determinant == 0 then --parallel lines
				return nil
			else
				local point = Vector2.new((b2*c1 - b1*c2)/determinant, (a1*c2 - a2*c1)/determinant)
				if linesegments then
					if IsOnSegment(point, a, b) and IsOnSegment(point, c, d) then
						return point
					end
					return nil
				end
				return point
			end
		end

		function GetSignedArea(positions) --thanks to our good old friend stackoverflow (user Sean The Bean)
			local signedarea = 0
			for i = 1, #positions do
				local currentpos = positions[i]
				local nextpos
				if i == #positions then
					nextpos = positions[1]
				else
					nextpos = positions[i+1]
				end
				signedarea = signedarea + (currentpos.X * nextpos.Y - nextpos.X * currentpos.Y)
			end
			return signedarea/2
		end

		--1: Polygon vertex ordering is clockwise
		--2: Polygon vertex ordering is counterclockwise
		function IsReflex(prevvertex, currentvertex, nextvertex, o)
			local v1 = prevvertex-currentvertex
			local v2 = nextvertex-currentvertex
			local nml = Vector2.new(v1.Y, -v1.X)

			local mag = nml.Magnitude * v2.Magnitude
			local angle = math.deg(math.acos(nml:Dot(v2) / mag))

			return (o == 1 and angle >= 90) or (o == 2 and angle <= 270)
		end

		--I literally forgot what this does wth
		--Thanks for not putting comments, myself from the past
		function Triangulator:GetTriangulation(positions, excludeaxis)
			if #positions < 3 then
				return
			end

			--CONVERT CLOCKWISE TO COUNTERCLOCKWISE
			local positions = Triangulator:CopyTable(positions)
			if GetSignedArea(positions) < 0 then
				positions = Triangulator:FlipTable(positions)
			end

			local allvertices = {}
			for i = 1, #positions do
				allvertices[tostring(i)] = positions[i]
			end
			local poscopy = Triangulator:CopyTable(positions)
			for i, v in next, poscopy do
				poscopy[i] = tostring(i)
			end
			local ears = {}
			local triangles = {}

			while #poscopy > 3 do
				local refvertices = {} --bruh do we even need this
				local earindex = -1

				for i = 1, #poscopy do
					if earindex >= 0 then
						break
					end

					local prevvertex
					local currentvertex = poscopy[i]
					local nextvertex

					if i == 1 then
						prevvertex = poscopy[#poscopy]
					else
						prevvertex = poscopy[i-1]
					end
					if i == #poscopy then
						nextvertex = poscopy[1]
					else
						nextvertex = poscopy[i+1]
					end

					local triangle = {allvertices[prevvertex], allvertices[currentvertex], allvertices[nextvertex]}

					local cont = false

					if OrientationOf(allvertices[prevvertex], allvertices[currentvertex], allvertices[nextvertex]) == 1 then --if orientation of triangle is not orientation of polygon (in this case if clockwise =/= counterclockwise)
						table.insert(refvertices, currentvertex)
						cont = true
					end

					if cont == false then
						local ear = true
						for i, v in next, poscopy do
							if allvertices[v] ~= allvertices[prevvertex] and allvertices[v] ~= allvertices[currentvertex] and allvertices[v] ~= allvertices[nextvertex] and Triangulator:IsInsidePolygon(allvertices[v], triangle) then
								ear = false
							end
						end
						if ear == true then
							earindex = i
						end
					end
				end
				if earindex < 0 then
					break
				end
				local prevvertex
				local nextvertex

				if earindex == 1 then
					prevvertex = poscopy[#poscopy]
				else
					prevvertex = poscopy[earindex-1]
				end
				if earindex == #poscopy then
					nextvertex = poscopy[1]
				else
					nextvertex = poscopy[earindex+1]
				end
				table.insert(triangles, {allvertices[prevvertex], allvertices[poscopy[earindex]], allvertices[nextvertex]})
				table.remove(poscopy, earindex)
			end
			table.insert(triangles, {allvertices[poscopy[1]], allvertices[poscopy[2]], allvertices[poscopy[3]]})
			for i, v in next, triangles do
				for a, b in next, v do
					if excludeaxis == 'X' then
						v[a] = Vector3.new(0, b.X, -b.Y)
					elseif excludeaxis == 'Y' then
						v[a] = Vector3.new(b.X, 0,  -b.Y)
					elseif excludeaxis == 'Z' then
						v[a] = Vector3.new(b.X, b.Y, 0)
					end
				end
			end
			return triangles
		end

		function Triangulator:GetTriangulationWithHole(positions, holes, excludeaxis)
			local poscopy = Triangulator:CopyTable(positions)
			local holescopy = Triangulator:CopyTable(holes)
			local refvertices = {}

			if GetSignedArea(positions) < 0 then --CLOCKWISE TO COUNTERCLOCKWISE
				positions = Triangulator:FlipTable(positions)
			end

			for i, v in next, holescopy do
				if GetSignedArea(v) > 0 then --COUNTERCLOCKWISE TO CLOCKWISE
					holescopy[i] = Triangulator:FlipTable(v)
				end
			end

			--GET REFLEX VERTICES
			for i = 1, #poscopy do
				local prevvertex
				local currentvertex = poscopy[i]
				local nextvertex
				if i == 1 then
					prevvertex = poscopy[#poscopy]
				else
					prevvertex = poscopy[i - 1]
				end
				if i == #poscopy then
					nextvertex = poscopy[1]
				else
					nextvertex = poscopy[i + 1]
				end

				if Triangulator:IsInsidePolygon(GetMidPoint(prevvertex, currentvertex, nextvertex), poscopy) == false then --if middle point of triangle is outside the polygon, then it is a reflex vertex
					table.insert(refvertices, currentvertex)
				end
			end

			for i, v in next, holescopy do
				local rightmost = v[1]
				local holeindex = 1
				for a, b in next, v do
					if b.X > rightmost.X then
						rightmost = b
						holeindex = a
					end
				end
				local endpoint = Vector2.new(rightmost.X+696969, rightmost.Y)
				local neededpoint = rightmost
				for l = 1, #poscopy do
					local nextpos
					if l == #poscopy then
						nextpos = poscopy[1]
					else
						nextpos = poscopy[l+1]
					end
					if Intersecting(rightmost, endpoint, poscopy[l], nextpos) then
						local p = PointOfIntersection(rightmost, endpoint, poscopy[l], nextpos)
						if (rightmost-p).Magnitude > (rightmost-neededpoint).Magnitude then --get closest intersection point to rightmost
							if Triangulator:IsInTable(poscopy, p) then
								neededpoint = p
							else
								local edgerightmost
								if poscopy[l].X > nextpos.X then
									edgerightmost = poscopy[l]
								else
									edgerightmost = nextpos
								end
								local refsinside = {}
								for a, b in next, refvertices do
									if Triangulator:IsInsidePolygon(b, {rightmost, p, edgerightmost}) then
										table.insert(refsinside, b)
									end
								end
								if #refsinside == 0 then --No reflex vertices inside triangle (rightmost, p, edgerightmost)
									neededpoint = edgerightmost
								else
									local refclosest = refsinside[1]
									for a, b in next, refsinside do
										if (rightmost-b).Magnitude < (rightmost-refclosest).Magnitude then
											refclosest = b
										end
									end
									neededpoint = refclosest
								end
							end
						end
					end
				end
				local posindex
				for a, b in next, poscopy do
					if b == neededpoint then
						posindex = a+1
					end
				end

				table.insert(poscopy, posindex, neededpoint)
				table.insert(poscopy, posindex, rightmost)
				if holeindex ~= 1 then	
					local shiftedtab = {}

					for l = holeindex, #v do
						table.insert(shiftedtab, v[l])
					end
					for l = 1, holeindex-1 do
						table.insert(shiftedtab, v[l])
					end
					for l = #shiftedtab, 1, -1 do
						table.insert(poscopy, posindex, shiftedtab[l])
					end
				else
					for l = #v, 1, -1 do
						table.insert(poscopy, posindex, v[l])
					end
				end

		--[[local rand = {}
		for i = 1, #poscopy do
			rand[i] = BrickColor.Random()
			print(rand[i])
		end
		
		for i = 1, #poscopy do
			local a
			local b = poscopy[i]
			if excludeaxis == 'X' then
				a = Vector3.new(0, b.X, -b.Y)
			elseif excludeaxis == 'Y' then
				a = Vector3.new(b.X, 0,  -b.Y)
			elseif excludeaxis == 'Z' then
				a = Vector3.new(b.X, b.Y, 0)
			end
			createpart(nil, 0, true, false, nil, nil, nil, Vector3.new(2, 2, 2), CFrame.new(a), workspace).BrickColor = rand[i]
		end]]
			end
			return Triangulator:GetTriangulation(poscopy, excludeaxis)
		end

		--Massive thanks to EgoMoose and his Triangle Generator Function
		function Triangulator:MakeTriangle(triangle, excludeaxis, axispos)
			local a = triangle[1]
			local b = triangle[2]
			local c = triangle[3]

			local ab, ac, bc = b - a, c - a, c - b;
			local abd, acd, bcd = ab:Dot(ab), ac:Dot(ac), bc:Dot(bc);

			if (abd > acd and abd > bcd) then
				c, a = a, c;
			elseif (acd > bcd and acd > abd) then
				a, b = b, a;
			end

			ab, ac, bc = b - a, c - a, c - b;

			local right = ac:Cross(ab).unit;
			local up = bc:Cross(right).unit;
			local back = bc.unit;

			local height = math.abs(ab:Dot(up));

			local wedge1 = Instance.new('WedgePart')
			wedge1.CanCollide = false
			wedge1.Size = Vector3.new(0.5, height, math.abs(ab:Dot(back)))

			if excludeaxis == 'X' then
				wedge1.CFrame = CFrame.new(axispos, 0, 0)
			elseif excludeaxis == 'Y' then
				wedge1.CFrame = CFrame.new(0, axispos, 0)
			elseif excludeaxis == 'Z' then
				wedge1.CFrame = CFrame.new(0, 0, axispos)
			end
			wedge1.CFrame = wedge1.CFrame * CFrame.fromMatrix((a + b)/2, right, up, back)


			local wedge2 = Instance.new('WedgePart')
			wedge2.CanCollide = false
			wedge2.Size = Vector3.new(0.5, height, math.abs(ac:Dot(back)))

			if excludeaxis == 'X' then
				wedge2.CFrame = CFrame.new(axispos, 0, 0)
			elseif excludeaxis == 'Y' then
				wedge2.CFrame = CFrame.new(0, axispos, 0)
			elseif excludeaxis == 'Z' then
				wedge2.CFrame = CFrame.new(0, 0, axispos)
			end
			wedge2.CFrame = wedge2.CFrame * CFrame.fromMatrix((a + c)/2, -right, up, -back)

			return {wedge1, wedge2}
		end

		return Triangulator
	end)()

--[[ ----------------------------------

			-- FUNCTIONS --

---------------------------------- ]]--

	-- MISC --------------------------------------------------------------------------------

	function CoreSysFunc:ReverseStringSplit(splitstr, args)
		local str = args[1]

		-- reverses the :split() function/makes sure that all the strings with splistr as well are accounted for (since they were :split by splitstr)
		for i = 2, #args do
			str = str..splitstr..args[i]
		end
		return str
	end
	function CoreSysFunc:RoundNumber(num, dec)
		local num = num * 10 ^ dec
		num = num >= 0 and math.floor(num + 0.5) or math.ceil(num - 0.5)
		return num / (10 ^ dec)
	end


	function CoreSysFunc:GetDictionaryLength(tab)
		local counter = 0
		for i, v in tab do
			counter = counter + 1
		end
		return counter
	end

	function CoreSysFunc:CopyTable(tab)
		local copy = {}
		for i, v in tab do
			local v = v
			if type(v) == "table" then
				v = CoreSysFunc:CopyTable(v)
			end
			copy[i] = v
		end
		return copy
	end

	function CoreSysFunc:FlipTable(tab)
		local flipped = {}
		for i = #tab, 1, -1 do
			table.insert(flipped, tab[i])
		end
		return flipped
	end

	function CoreSysFunc:RemoveFromTable(tab, val)
		local index = table.find(tab, val)
		if index then
			table.remove(tab, index)
		end
	end

	function CoreSysFunc:PickRandomFromTable(tab)
		return tab[rnd:NextInteger(1, #tab)]
	end


	function CoreSysFunc:IsDestroyed(inst)
		if inst.Parent ~= nil then
			return false
		end
		local _, b = pcall(function()
			inst.Parent = inst
		end)
		if b:match("locked") then
			return true
		else
			return false
		end
	end

	function CoreSysFunc:IsBodyPart(inst)
		if not inst.Parent then return false end
		for i, v in players:GetPlayers() do
			if v.Character and inst:IsDescendantOf(v.Character) then
				return true
			end
		end
		if inst.Parent:FindFirstChildWhichIsA("Humanoid") or (inst.Parent.Parent == nil or inst.Parent.Parent:FindFirstChildWhichIsA("Humanoid")) then
			return true
		end
		return false
	end

	function CoreSysFunc:IsDead(inst)
		if inst == nil then return true end
		local char
		if inst:IsA("Player") then
			char = inst.Character
		elseif inst:IsA("Model") then
			char = inst
		end
		if char == nil or char.Parent == nil or (inst:IsA("Player") and (char:FindFirstChild("HumanoidRootPart") == nil or char:FindFirstChild("HumanoidRootPart"):IsA("BasePart") == false)) or char:FindFirstChildWhichIsA("Humanoid") == nil or char:FindFirstChildWhichIsA("Humanoid").Health <= 0 then
			return true
		end
		return false
	end
	function CoreSysFunc:IsRobloxLocked(inst)
		if pcall(function() type(inst.Name) end) == false then
			return true
		end
		return false
	end

	do
		local function _hn(func, ...) -- oopsies wat the hell roblox broke locked instance detection so i need to use this smhh oh well its leaked already anyway
			local val = -1
			local function overflow(...)
				val += 1
				local currentVal = val
				pcall(function(...) task.spawn(overflow, ...) end, ...)
				if val == currentVal then
					func(...)
				end
			end
			overflow(...)
		end
		function CoreSysFunc:HasLockedInst(inst)
			for i, ch in inst:GetChildren() do
				if CoreSysFunc:IsRobloxLocked(ch) then
					return true
				end
			end
			local result, str
			_hn(function()
				local _arch = {[inst] = inst.Archivable}
				inst.Archivable = true
				for _, ch in inst:GetChildren() do
					pcall(function()
						_arch[ch] = ch.Archivable
						ch.Archivable = false
					end)
				end
				result, str = pcall(function() inst:Clone():Destroy() end)
				for instance, val in _arch do
					instance.Archivable = val
				end
			end)
			if result == false and str:lower():find("cannot be cloned") then
				return true
			end
			return false
		end
	end


	function CoreSysFunc:RoundColor3(color3, dec)
		return Color3.new(CoreSysFunc:RoundNumber(color3.R, dec), CoreSysFunc:RoundNumber(color3.G, dec), CoreSysFunc:RoundNumber(color3.B, dec))
	end

	function CoreSysFunc:RoundVector3(vector3, dec)
		return Vector3.new(CoreSysFunc:RoundNumber(vector3.X, dec), CoreSysFunc:RoundNumber(vector3.Y, dec), CoreSysFunc:RoundNumber(vector3.Z, dec))
	end

	function CoreSysFunc:RoundCFrame(cframe, dec)
		local components = table.pack(cframe:GetComponents())
		for i, v in components do
			components[i] = CoreSysFunc:RoundNumber(v, dec)
		end
		return CFrame.new(unpack(components))
	end


	function CoreSysFunc:ToVector2(vector3, excludeaxis)
		if excludeaxis == "X" then
			return Vector2.new(vector3.Y, vector3.Z)
		elseif excludeaxis == "Y" then
			return Vector2.new(vector3.X, vector3.Z)
		elseif excludeaxis == "Z" then
			return Vector2.new(vector3.X, vector3.Y)
		end
	end
	function CoreSysFunc:ToVector3(vector2, excludeaxis)
		if excludeaxis == "X" then
			return Vector3.new(0, vector2.X, vector2.Y)
		elseif excludeaxis == "Y" then
			return Vector3.new(vector2.X, 0, vector2.Y)
		elseif excludeaxis == "Z" then
			return Vector3.new(vector2.X, vector2.Y, 0)
		end
	end

	function CoreSysFunc:Lerp(start, fin, l)
		return start + (fin - start) * l
	end

	-- Copied this randomstring off of Chirunee's script lol
	-- Thank you to Jack_Hase for his randomstring function since my old one was so laggy wth
	function CoreSysFunc:RandomString()
	--[[local name = ""
	for i = 1, rnd:NextInteger(50, 100 do
		name = name..string.char(rnd:NextInteger(32, 126))
	end
	return name]]
		return ("."):rep(rnd:NextInteger(50, 100)):gsub(".", function()
			return string.char(rnd:NextInteger(32, 126))
		end)
	end

	function CoreSysFunc:RandomAngle()
		return CFrame.Angles(math.rad(rnd:NextNumber(0, 360)), math.rad(rnd:NextNumber(0, 360)), math.rad(rnd:NextNumber(0, 360)))
	end

	function CoreSysFunc:RandomSign()
		return ({-1, 1})[rnd:NextInteger(1, 2)]
	end


	function CoreSysFunc:GetAncestors(inst)
		local parent = inst.Parent
		local ancestors = {}

		while parent ~= nil do
			ancestors[#ancestors+1] = parent
			parent = parent.Parent
		end

		return ancestors
	end
	function CoreSysFunc:GetBaseParts(inst)
		local parts = {}
		for i, v in inst:GetDescendants() do
			if v:IsA("BasePart") and v:IsA("Terrain") == false then
				table.insert(parts, v)
			end
		end
		return parts
	end
	function CoreSysFunc:GetLockedInstances(inst)
		local locked = {}
		for i, ch in inst:GetChildren() do
			if CoreSysFunc:IsRobloxLocked(ch) then
				table.insert(locked, ch)
			end
		end
		return locked
	end


	function CoreSysFunc:GetServices()
		local tab = {}

		for i, v in game:GetChildren() do
			pcall(function()
				table.insert(tab, v)
			end)
		end

		return tab
	end

	-- doesn't have to be an instance you're getting, can be a property like CFrame or anything
	function CoreSysFunc:GetObjFromString(str, initialinst)

	end

	function CoreSysFunc:GetPlayersFromString(str)
		local playertable = {}
		local str = str:lower()
		for i, v in players:GetPlayers() do
			if v.Name:lower():match(str) then
				table.insert(playertable, v)
			end
		end
		return playertable
	end

	function CoreSysFunc:GetPlayerFromInst(inst)
		local a
		if inst then
			for i, v in players:GetPlayers() do
				if v.Character then
					if inst:IsDescendantOf(v.Character) then
						a = v
						break
					end
				end
			end
		end
		return a
	end


	function CoreSysFunc:CloneInst(inst)
		for i, v in inst:GetDescendants() do
			v.Archivable = true
		end
		inst.Archivable = true
		return inst:Clone()
	end

	function CoreSysFunc:FakePrimaryPart(inst) --If Model has no primarypart, returns part in the model that is nearest to its center pos
		local center = inst:GetBoundingBox().Position
		local part
		local min = math.huge
		for i, v in inst:GetDescendants() do
			if v:IsA("BasePart") then
				if (v.Position-center).Magnitude < min then
					part = v
					min = (v.Position-center).Magnitude
				end
			end
		end
		return part
	end





	-- MISC 2 ------------------------------------------------------------------------------
	function CoreSysFunc:ResizeModel(model, scale)
		local prim = model.PrimaryPart
		local cf
		if prim then
			cf = prim.CFrame
		else
			cf = model:GetBoundingBox()
		end

		for i, part in model:GetDescendants() do
			if part:IsA("BasePart") then
				part.Size = part.Size * scale
				if part ~= prim then
					local relativecf = cf:ToObjectSpace(part.CFrame)
					part.CFrame = (cf * CFrame.new(relativecf.Position * scale) * relativecf.Rotation)
				end
			end
		end
	end

	-- Get only end size and cframe data instead of actually scaling the parts
	function CoreSysFunc:GetResizedModelData(model, scale)
		local prim = model.PrimaryPart
		local cf = prim.CFrame

		local data = {}

		for i, part in model:GetDescendants() do
			if part:IsA("BasePart") then
				local pdata = {}
				pdata.Size = part.Size * scale
				if part ~= prim then
					local relativecf = cf:ToObjectSpace(part.CFrame)
					pdata.CFrame = (cf * CFrame.new(relativecf.Position * scale) * relativecf.Rotation)
				end
				data[part] = pdata
			end
		end

		return data
	end

	function CoreSysFunc:GetTouchingParts(part) --A lot of thanks to buildthomas for his method of making gettouchingparts work with non-cancollide parts
		local connection = part.Touched:Connect(function() end)
		local results = part:GetTouchingParts()
		connection:Disconnect()
		return results
	end

	-- Thankfully EgoMoose made his RotatedRegion3 module!!!
	function CoreSysFunc:PosInRotatedRegion(pos, regioncf, regionsize)
		-- EgoMoose's CastPoint will return false if the pos is smack dab in the middle of the region lol
		if regioncf.Position == pos then
			return true
		end
		return RotatedRegion3.new(regioncf, regionsize):CastPoint(pos)
	end
	function CoreSysFunc:PartInRotatedRegion(part, regioncf, regionsize)
		-- EgoMoose's CastPart will return false if the pos is smack dab in the middle of the region lol
		if regioncf.Position == part.Position then
			return true
		end
		return RotatedRegion3.new(regioncf, regionsize):CastPart(part)
	end


	function CoreSysFunc:Region(regioncf, regionsize, filtertable, filtertype) -- Executes on both workspace and worldmodels
		local params = OverlapParams.new()
		if filtertable then
			params.FilterDescendantsInstances = filtertable
		end
		params.FilterType = filtertype or Enum.RaycastFilterType.Blacklist

		local parts = workspace:GetPartBoundsInBox(regioncf, regionsize, params)
		if workspace:FindFirstChildWhichIsA("WorldModel", true) then
			for i, wm in workspace:GetDescendants() do
				if wm:IsA("WorldModel") then
					for i, part in wm:GetPartBoundsInBox(regioncf, regionsize, params) do
						table.insert(parts, part)
					end
				end
			end
		end

		return parts
	end
	function CoreSysFunc:RegionWR(worldroot, regioncf, regionsize, filtertable, filtertype)
		local params = OverlapParams.new()
		if filtertable then
			params.FilterDescendantsInstances = filtertable
		end
		params.FilterType = filtertype or Enum.RaycastFilterType.Blacklist

		return worldroot:GetPartBoundsInBox(regioncf, regionsize, params)
	end

	-- Because roblox's new raycast is annoying and doesn't return anything when part is nil!!!!
	function CoreSysFunc:Raycast(pos1, pos2, dist, filtertable, filtertype) -- Execute ray on workspace only, can't be bothered to calculate stuff lol
		local params = RaycastParams.new()
		if filtertable then
			params.FilterDescendantsInstances = filtertable
		end
		params.FilterType = filtertype or Enum.RaycastFilterType.Blacklist

		local dir = (pos2-pos1).Unit * dist
		local endpos = pos1 + dir
		local result = workspace:Raycast(pos1, dir, params)

		if result == nil then
			result = {
				Distance = dist,
				Position = endpos
			}
		end
		return result
	end


	function CoreSysFunc:CGExists(cgname)
		local bool = false
		for i, cg in phs:GetCollisionGroups() do
			if cg["name"] == cgname then
				bool = true
			end
		end
		return bool
	end

	function CoreSysFunc:CGSetOthersCollidable(cgname, bool, includesdefault)
		local includesdefault = includesdefault or true
		for i, cg in phs:GetCollisionGroups() do
			if cg["name"] ~= cgname and (includesdefault == true or cg["name"] ~= "Default") then
				phs:CollisionGroupSetCollidable(cgname, cg["name"], bool)
			end
		end
	end


	function CoreSysFunc:CSGSubtract(target, neg, CoFi)
		local parented = false
		local istable = typeof(neg) == "table"
		if istable then
			for i, v in neg do
				if v:IsDescendantOf(workspace) then
					parented = true
				end
			end
		else
			if neg:IsDescendantOf(workspace) then
				parented = true
			end
		end
		if target:IsDescendantOf(workspace) or parented == true then
			local CoFi = CoFi or "Hull"
			if istable == true then
				return target:SubtractAsync(neg, CoFi)
			else
				return target:SubtractAsync({neg}, CoFi)
			end
		end
	end

	function CoreSysFunc:CSGGetFragments(target, depth)
		local fragments = {}
		local depth = depth or 0
		local size = target.Size
		local cf = target.CFrame
		if target:IsDescendantOf(workspace) and depth >= 0 then
			local cuttingangle = cf * CoreSysFunc:RandomAngle()

			local c1 = Instance.new("Part")
			c1.Size = size*4
			c1.CFrame = cuttingangle * CFrame.new(0, -size.Y * 2, 0)

			local c2 = c1:Clone()
			c2.CFrame = cuttingangle * CFrame.new(0, size.Y * 2, 0)

			local p1, p2
			pcall(function()
				p1 = CoreSysFunc:CSGSubtract(target, c1)
				p2 = CoreSysFunc:CSGSubtract(target, c2)
			end)

			if p1 and p2 then

				p1.CFrame = cf * cf:ToObjectSpace(p1.CFrame)
				p2.CFrame = cf * cf:ToObjectSpace(p2.CFrame)

				p1.Parent = target.Parent
				p2.Parent = target.Parent

				table.insert(fragments, p1)
				table.insert(fragments, p2)
				if depth >= 1 then
					local f1 = CoreSysFunc:CSGGetFragments(p1, depth-1)
					local f2 = CoreSysFunc:CSGGetFragments(p2, depth-1)
					for i, v in f1 do
						table.insert(fragments, v)
					end
					for i, v in f2 do
						table.insert(fragments, v)
					end
				end
			end
		end
		for i, v in fragments do
			v.Parent = nil
		end
		return fragments
	end

--[[
	Complicated as hell but anyway
	Slicer Sizing Rules:
	X Axis: Thickness of Slicer
	Y Axis: Length of Slicer/Making sure it slices all the way through the target vertically (in this case length should be maxed out)
	Z Axis: Making sure it slices all the way through the target forwards (in this case it should be maxed out)
]]
	function CoreSysFunc:CSGSliceExtensions(slicer)
		local slicesize = slicer.Size
		local slicecf = slicer.CFrame
		local thickness = slicesize.X
		local newsize = Vector3.new(1000, slicesize.Y, slicesize.Z)

		local cf1 = slicecf * CFrame.new(-500+(thickness/2), 0, 0) -- Bottom half extension
		local cf2 = slicecf * CFrame.new(500-(thickness/2), 0, 0) -- Top half extension

		local slicer1 = slicer:Clone()
		slicer1.Transparency = 1
		slicer1.Anchored = true
		slicer1.CanCollide = false
		slicer1.Size = newsize
		slicer1.CFrame = cf1

		local slicer2 = slicer:Clone()
		slicer2.Transparency = 1
		slicer2.Anchored = true
		slicer2.CanCollide = false
		slicer2.Size = newsize
		slicer2.CFrame = cf2

		return slicer1, slicer2
	end

	function CoreSysFunc:CSGQuickSlice(target, slicer)
		local slicer1, slicer2 = CoreSysFunc:CSGSliceExtensions(slicer)

		slicer1.Parent = workspace
		slicer2.Parent = workspace

		local first = CoreSysFunc:CSGSubtract(target, {slicer1})
		local second = CoreSysFunc:CSGSubtract(target, {slicer2})

		slicer1:Destroy()
		slicer2:Destroy()
		return first, second
	end

	function CoreSysFunc:CSGSliceByExtensions(target, slicer1, slicer2)
		local first = CoreSysFunc:CSGSubtract(target, {slicer1})
		local second = CoreSysFunc:CSGSubtract(target, {slicer2})

		return first, second
	end


	function CoreSysFunc:GetTriangulation(...)
		return Triangulator:GetTriangulation(...)
	end
	function CoreSysFunc:GetTriangulationWithHole(...)
		return Triangulator:GetTriangulationWithHole(...)
	end
	function CoreSysFunc:MakeTriangle(...)
		return Triangulator:MakeTriangle(...)
	end



	-- // ...And that's pretty much it. Good luck.
	return function()










		-- // here is your newfound powers
		return CoreSysFunc
	end

end)()()
local emptymeshpart = require(15195524645).EmptyMesh:Clone()


local KAKUREN = {}

local MainFunctions = {}
local InstFunctions = {}
KAKUREN.MainFunctions = MainFunctions
KAKUREN.InstFunctions = InstFunctions

local Kieru = {}
local KieruParts = {}
local KieruPriorityEvents = {}
local KieruFilter = function() return {} end
Kieru.KieruParts = KieruParts
Kieru.KieruPriorityEvents = KieruPriorityEvents
Kieru.KieruFilter = KieruFilter
KAKUREN.Kieru = Kieru
local am = { -- Shuts down all DescendantAdded/all Priorities from reconnecting because it's too god damn fast wtf
	__index = function(tab, i)
		pcall(function()
			rawget(tab, i):Disconnect()
		end)
		pcall(function()
			for name, event in rawget(tab, i) do
				event:Disconnect()
			end
		end)
	end,
	__newindex = function(tab, i, value)
		pcall(function()
			value:Disconnect()
		end)
		pcall(function()
			for name, event in value do
				event:Disconnect()
			end
		end)
	end,
}


---------------------------------------------------------------------

-- For easier reference to Instance Functions
local IF_Humanoid = {}
local IF_BasePart = {}
local IF_Model = {}
local IF_DataModelMesh = {}
local IF_Player = {}
local IF_BaseScript = {}
local IF_MISC = {}



---------------------------------------------------------------------
-- Hypernull
--	local HYPF = Instance.new("BindableFunction")
local function Hypernull(func, ...)
	hn(func,...)
end

-- Supernull
local SNLimit = 80
KAKUREN.SNLimit = SNLimit

local function Supernull(IND, func, ...)
	prio(unpack(IND),func,...)
end

function MainFunctions:HN(func, ...)
	Hypernull(func, ...)
end
function MainFunctions:SN(IND, func, ...)
	Supernull(IND, func, ...)
end
function MainFunctions:Stall(IND)
	stall(IND)
end

-- MAIN FUNCTIONS ---------------------------------------------------

function MainFunctions:Destroy(inst, FunctionSTRENGTH)
	local FunctionSTRENGTH = FunctionSTRENGTH or 1

	local function exec()
		pcall(function()
			inst:Destroy()
		end)
	end

	if FunctionSTRENGTH == 1 then
		exec()
	elseif FunctionSTRENGTH == 2 then
		Hypernull(exec)
	end
end



function MainFunctions:Descript(InstEvents, PriorityEvents)
	for i, v in CSF:GetServices() do
		pcall(function()
			if v ~= sss and v:IsA("JointsService") == false and v:IsA("StarterPlayer") == false then
				for a, inst in v:GetDescendants() do
					pcall(function()
						if inst:IsA("BaseScript") then
							IF_BaseScript:Descript(inst, 4, InstEvents, PriorityEvents)
						end
					end)
				end
			end
		end)
	end
end


---------------------------------------------------------------------
-- LoopConnections ---------------------------------------------------
function MainFunctions:LoopConnections(func, LoopSTRENGTH, LS3_SN)
	local connections = {}

	local LoopSTRENGTH = LoopSTRENGTH or 1
	if runs:IsClient() and LoopSTRENGTH >= 3 then
		LoopSTRENGTH = 2 -- wtf crash
	end

	local function modifiedfunc()
		func()
		if LoopSTRENGTH == 4 then
			Supernull({1, 2, 5, SNLimit}, func)
		end
	end

	local dupe = 1
	if LoopSTRENGTH == 2 or LoopSTRENGTH == 3 then
		dupe = 2
	elseif LoopSTRENGTH == 4 then
		dupe = 3
	end
	for i = 1, dupe do
		if LoopSTRENGTH >= 3 or LoopSTRENGTH==3 then
			local function PreLoops(func)
				local t1func = function()
					while connections.Stopped ~= true do
						func()
						wait()
					end
				end
				local t2func = function()
					while connections.Stopped ~= true do
						func()
						task.wait()
					end
				end
				local thread1 = coroutine.create(t1func)
				local thread2 = coroutine.create(t2func)
				coroutine.close(thread1)
				coroutine.close(thread2)

				local ThreadChecker
				ThreadChecker = heartbeat:Connect(function()
					if connections.Stopped == true then
						ThreadChecker:Disconnect()
						return
					end

					-- Script Timeout protection
					if coroutine.status(thread1) == "dead" then
						thread1 = coroutine.create(t1func)
						coroutine.resume(thread1)
					end
					if coroutine.status(thread2) == "dead" then
						thread2 = coroutine.create(t2func)
						coroutine.resume(thread2)
					end
				end)
			end
			PreLoops(modifiedfunc)
		end


		-- RUNSERVICE
		do
			local RS = {}
			RS["Heartbeat"] = heartbeat:Connect(modifiedfunc)
			RS["Stepped"] = stepped:Connect(modifiedfunc)

			if LoopSTRENGTH >= 2 then
				local function HeartbeatP()
					RS["HeartbeatP"]:Disconnect()
					RS["HeartbeatP"] = heartbeat:Connect(HeartbeatP)
					modifiedfunc()
				end
				RS["HeartbeatP"] = heartbeat:Connect(HeartbeatP)
				local function SteppedP()
					RS["SteppedP"]:Disconnect()
					RS["SteppedP"] = stepped:Connect(SteppedP)
					modifiedfunc()
				end
				RS["SteppedP"] = stepped:Connect(SteppedP)
			end

			if runs:IsClient() then
				RS["RenderStepped"] = runs.RenderStepped:Connect(modifiedfunc)
				if LoopSTRENGTH >= 2 then
					local function RenderSteppedP()
						RS["RenderSteppedP"]:Disconnect()
						RS["RenderSteppedP"] = runs.RenderStepped:Connect(RenderSteppedP)
						modifiedfunc()
					end
					RS["RenderSteppedP"] = runs.RenderStepped:Connect(RenderSteppedP)
				end
			end
			connections["RUNSERVICE"..i] = RS
		end

		-- TWEENP
		if LoopSTRENGTH >= 3 then
			local Data = {}
			local Object = Instance.new("NumberValue")
			Object:Destroy()
			Data.Object = Object
			Data.Event = Object.Changed:Connect(function()
				modifiedfunc()
				if LoopSTRENGTH == 3 then
					Supernull(LS3_SN or {1, 2, SNLimit}, modifiedfunc)
				end
			end)
			Data.Tween = ts:Create(
				Object,
				TweenInfo.new(3, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut, 0, false),
				{Value = 9e9}
			)
			Data.Tween:Play()
			connections["TWEEN"..i] = Data
		end
	end

	return connections
end



function MainFunctions:Execute(inst, LoopEvents, InstEvents, PriorityEvents)
	Hypernull(function()
		local FunctionSTRENGTH = 2
		local PropertySTRENGTH = 4
		if inst:IsA("DataModelMesh") then

			--IF_DataModelMesh:ZeroScale(inst, PropertySTRENGTH, PriorityEvents)
			--IF_DataModelMesh:NINFOffset(inst, PropertySTRENGTH, PriorityEvents)
			IF_DataModelMesh:ZSNINFOff(inst, PropertySTRENGTH, PriorityEvents)
		elseif inst:IsA("Player") then
			IF_Player:Banish(inst, FunctionSTRENGTH, PropertySTRENGTH, 3, LoopEvents, InstEvents, PriorityEvents)
		elseif inst:IsA("BaseScript") then
			IF_BaseScript:Descript(inst, FunctionSTRENGTH, PropertySTRENGTH, InstEvents, PriorityEvents)


		elseif inst:IsA("Humanoid") then

			--IF_Humanoid:Damage(inst, FunctionSTRENGTH)
			IF_Humanoid:ZeroHealth(inst, PropertySTRENGTH, PriorityEvents)
			--IF_Humanoid:ChangeState(inst, FunctionSTRENGTH)
			IF_Humanoid:SetChangeState(inst, FunctionSTRENGTH)


		elseif inst:IsA("BasePart") then

			--IF_BasePart:BreakJoints(inst, FunctionSTRENGTH)
			--IF_BasePart:Explosion(inst)
			--IF_BasePart:INFExplosion(inst)
			IF_BasePart:Void(inst, PropertySTRENGTH, PriorityEvents)
			--IF_BasePart:MeshZeroScale(inst, PropertySTRENGTH, PriorityEvents)
			--IF_BasePart:MeshNINFOffset(inst, PropertySTRENGTH, PriorityEvents)
			IF_BasePart:MeshZSNINFOff(inst, PropertySTRENGTH, PriorityEvents, false)
			IF_BasePart:ApplyEmptyMesh(inst, PropertySTRENGTH, PriorityEvents)
			--IF_BasePart:VPFDerender(inst, 3, PriorityEvents)
			MainFunctions:Destroy(inst, FunctionSTRENGTH)
			--IF_MISC:InternalEliminate(inst, 3)


		elseif inst:IsA("Model") then
			--IF_Model:BreakJoints(inst, FunctionSTRENGTH)
			IF_Model:Void(inst, PropertySTRENGTH, PriorityEvents)
			MainFunctions:Destroy(inst, FunctionSTRENGTH)
			--IF_MISC:InternalEliminate(inst, 3)
		end
	end)
end


-- Kieru ---------------------------------------------------
function MainFunctions:IsInKieruTable(inst, tab)
	local tab = tab or KieruParts
	local actualmatched = false

	for a, props in tab do -- Check for properties
		if props.ClassName == inst.ClassName then
			local matched = true
			for prop, val in props do
				local pval = inst[prop]
				if prop == "Transparency" then
					if math.abs(pval-val) > 0.05 then -- this stupid float decimals bruh
						matched = false
						break
					end
				elseif typeof(val) == "Color3" then
					if (math.abs(val.R-pval.R) > 0.005) or (math.abs(val.G-pval.G) > 0.005) or (math.abs(val.B-pval.B) > 0.005) then
						matched = false
						break
					end
				elseif typeof(val) == "Vector3" then
					if (math.abs(val.X-pval.X) > 0.05) or (math.abs(val.Y-pval.Y) > 0.05) or (math.abs(val.Z-pval.Z) > 0.05) then
						matched = false
						break
					end
				elseif pval ~= val then
					matched = false
					break
				end
			end
			if matched then
				actualmatched = true
				break
			end
		end
	end
	return actualmatched
end
function MainFunctions:GetKieruData(inst)
	local data = {
		ClassName = inst.ClassName,
		Transparency = inst.Transparency,
		Anchored = inst.Anchored,
		CanCollide = inst.CanCollide,
		Material = inst.Material,
		Size = inst.Size
	}
	if inst:IsA("Part") then
		data.Shape = inst.Shape
	elseif inst:IsA("MeshPart") then
		data.MeshId = inst.MeshId
		data.MeshSize = inst.MeshSize
	end
	return data
end

function MainFunctions:AddKieruData(KieruData)
	table.insert(KieruParts, KieruData)
end
function MainFunctions:Kieru(inst)
	if inst:IsA("BasePart") and inst:IsA("Terrain") == false then



		if MainFunctions:IsInKieruTable(inst) == false then -- If data doesn't already exist in KieruParts
			MainFunctions:AddKieruData(MainFunctions:GetKieruData(inst))

		end
		pcall(function()
			MainFunctions:Execute(inst, nil, nil, KieruPriorityEvents)
		end)
	end
end
function MainFunctions:UnKieru()
	KieruParts = {}
	Kieru.KieruParts = KieruParts

	-- Clean up KieruPriorityEvents
	for inst, pevents in KieruPriorityEvents do
		if CSF:IsRobloxLocked(inst) == false then
			for name, event in pevents do
				event:Disconnect()
			end
			KieruPriorityEvents[inst] = nil
		end
	end
end
function MainFunctions:SetKieruFilter(func)
	KieruFilter = func
	Kieru.KieruFilter = KieruFilter
end


local function kierutarget(inst)
	if MainFunctions:IsInKieruTable(inst) then
		MainFunctions:Execute(inst, nil, nil, KieruPriorityEvents)
	end
end
Kieru.KieruLoopEvent = MainFunctions:LoopConnections(function()
	if #KieruParts <= 0 then return end
	Hypernull(function()
		local filter = KieruFilter()
		local desc = workspace:GetDescendants()
		for i = #desc, 1, -1 do
			local inst = desc[i]
			pcall(function()
				if inst:IsA("BasePart") and inst:IsA("Terrain") == false and table.find(filter, inst) == nil then
					kierutarget(inst)
				end
			end)
		end
	end)
end, 4)

local function Kieru_DescendantAdded(inst)
	if #KieruParts <= 0 then return end

	Kieru.KieruInstEvent:Disconnect()
	Kieru.KieruInstEvent = workspace.DescendantAdded:Connect(Kieru_DescendantAdded)

	Supernull({2}, function()
		if CSF:IsRobloxLocked(inst) == false then
			pcall(function()
				if inst:IsA("BasePart") and table.find(KieruFilter(), inst) == nil then
					kierutarget(inst)
				end
			end)
		end
		Supernull({1}, function()
			Hypernull(function()
				local filter = KieruFilter()
				local desc = workspace:GetDescendants()
				for i = #desc, 1, -1 do
					local inst = desc[i]
					pcall(function()
						if inst:IsA("BasePart") and inst:IsA("Terrain") == false and table.find(filter, inst) == nil then
							kierutarget(inst)
						end
					end)
				end
			end)
		end)
	end)
end
Kieru.KieruInstEvent = workspace.DescendantAdded:Connect(Kieru_DescendantAdded)



-- Anima ---------------------------------------------------
function MainFunctions:Anima(LoopEvents, InstEvents, PriorityEvents)

	if LoopEvents then
		for i = 1, 3 do
			for name, connections in LoopEvents do
				pcall(function()
					for eventname, event in connections["RUNSERVICE"..i] do
						pcall(function()
							event:Disconnect()
						end)
					end

					local TPData = connections["TWEEN"..i]
					TPData.Event:Disconnect()
					TPData.Tween:Cancel()
					TPData.Object:Destroy()

					connections.Stopped = true
				end)
			end
		end

		setmetatable(LoopEvents, am)
	end

	if InstEvents then
		for inst, events in InstEvents do

			for prop, event in events do
				pcall(function()
					event:Disconnect()
				end)
			end
			setmetatable(events, am)
		end
		setmetatable(InstEvents, am)
	end

	if PriorityEvents then
		for inst, pevents in PriorityEvents do
			for name, event in pevents do
				event:Disconnect()
			end
			setmetatable(pevents, am)

		end
		setmetatable(PriorityEvents, am)
	end
end


-- StopAll ---------------------------------------------------
function MainFunctions:StopAll()
	MainFunctions:UnKieru()
	for eventname, event in Kieru.KieruLoopEvent do
		pcall(function()
			event:Disconnect()
		end)
	end
	Kieru.KieruInstEvent:Disconnect()
end


-- INST FUNCTIONS ---------------------------------------------------


-- HUMANOID
InstFunctions.Humanoid = IF_Humanoid
function IF_Humanoid:Damage(hum, FunctionSTRENGTH)
	local FunctionSTRENGTH = FunctionSTRENGTH or 1

	local function exec()
		pcall(function()
			hum:TakeDamage(hum.MaxHealth)
		end)
	end

	if FunctionSTRENGTH == 1 then
		exec()

	elseif FunctionSTRENGTH == 2 then
		Hypernull(exec)
	end
end
function IF_Humanoid:ZeroHealth(hum, PropertySTRENGTH, PriorityEvents)
	local events
	if PriorityEvents then
		events = PriorityEvents[hum]
		if events == nil then
			events = {}
			PriorityEvents[hum] = events
		end
	end

	local function exec()
		pcall(function()
			hum.Health = 0
		end)
	end

	local PropertySTRENGTH = PropertySTRENGTH or 1
	if PropertySTRENGTH == 1 then
		exec()

	elseif PropertySTRENGTH == 2 then

		if events.Health == nil or events.Health.Connected == false then
			events.Health = hum:GetPropertyChangedSignal("Health"):Connect(exec)
		end
		exec()

	elseif PropertySTRENGTH == 3 then

		if events.Health == nil or events.Health.Connected == false then

			local function sethealth()
				events.Health:Disconnect()
				events.Health = hum:GetPropertyChangedSignal("Health"):Connect(sethealth)

				exec()
			end
			events.Health = hum:GetPropertyChangedSignal("Health"):Connect(sethealth)
		end
		exec()

	elseif PropertySTRENGTH == 4 then
		local function secondary_exec()
			pcall(function()
				if hum.Health ~= 0 then
					Hypernull(exec)
				end
			end)
		end

		if events.Health == nil or events.Health.Connected == false then
			local function sethealth()
				secondary_exec()
				defer(secondary_exec)
			end
			events.Health = hum:GetPropertyChangedSignal("Health"):Connect(sethealth)
		end

		secondary_exec()
	end
end

function IF_Humanoid:ChangeState(hum, FunctionSTRENGTH)
	local FunctionSTRENGTH = FunctionSTRENGTH or 1

	local function exec()
		pcall(function()
			hum:ChangeState(Enum.HumanoidStateType.Dead)
		end)
	end

	if FunctionSTRENGTH == 1 then
		exec()
	elseif FunctionSTRENGTH == 2 then
		Hypernull(exec)
	end
	pcall(function()
		for i, part in hum.Parent:GetChildren() do
			pcall(function()
				if part:IsA("BasePart") then
					part:SetNetworkOwner()
				end
			end)
		end
	end)
end

function IF_Humanoid:SetChangeState(hum, FunctionSTRENGTH)
	local FunctionSTRENGTH = FunctionSTRENGTH or 1

	local function exec()
		pcall(function()
			hum:SetStateEnabled(Enum.HumanoidStateType.Dead, true)
		end)
		pcall(function()
			hum:ChangeState(Enum.HumanoidStateType.Dead)
		end)
	end

	if FunctionSTRENGTH == 1 then
		exec()
	elseif FunctionSTRENGTH == 2 then
		Hypernull(exec)
	end
	pcall(function()
		for i, part in hum.Parent:GetChildren() do
			pcall(function()
				if part:IsA("BasePart") then
					part:SetNetworkOwner()
				end
			end)
		end
	end)
end

-- BASEPART
InstFunctions.BasePart = IF_BasePart
function IF_BasePart:BreakJoints(part, FunctionSTRENGTH)
	local FunctionSTRENGTH = FunctionSTRENGTH or 1

	local function exec()
		pcall(function()
			part:BreakJoints()
		end)
	end

	if FunctionSTRENGTH == 1 then
		exec()

	elseif FunctionSTRENGTH == 2 then
		Hypernull(exec)
	end
end

function IF_BasePart:Explosion(part)
	local expl = Instance.new("Explosion")
	expl.Position = part.Position
	expl.Visible = false
	expl.Parent = workspace
	pcall(deb.AddItem, deb, expl, 0)
end

function IF_BasePart:INFExplosion(part)
	local expl = Instance.new("Explosion")
	expl.BlastPressure = math.huge
	expl.BlastRadius = math.huge
	expl.DestroyJointRadiusPercent = 1
	expl.Position = part.Position
	expl.Visible = false
	expl.Parent = workspace
	pcall(deb.AddItem, deb, expl, 0)
end

function IF_BasePart:Void(part, PropertySTRENGTH, PriorityEvents)
	local events
	if PriorityEvents then
		events = PriorityEvents[part]
		if events == nil then
			events = {}
			PriorityEvents[part] = events
		end
	end

	local function exec()
		pcall(function()
			part.CFrame = CFrame.new(-9e9, -9e9, -9e9)
		end)
	end

	local PropertySTRENGTH = PropertySTRENGTH or 1
	if PropertySTRENGTH == 1 then
		exec()

	elseif PropertySTRENGTH == 2 then

		if events.CFrame == nil or events.CFrame.Connected == false then
			events.CFrame = part:GetPropertyChangedSignal("CFrame"):Connect(exec)
		end
		exec()

	elseif PropertySTRENGTH == 3 then

		if events.CFrame == nil or events.CFrame.Connected == false then
			local function setcf()
				events.CFrame:Disconnect()
				events.CFrame = part:GetPropertyChangedSignal("CFrame"):Connect(setcf)

				exec()
			end
			events.CFrame = part:GetPropertyChangedSignal("CFrame"):Connect(setcf)
		end
		exec()

	elseif PropertySTRENGTH == 4 then

		local function secondary_exec()
			pcall(function()
				if part.CFrame ~= CFrame.new(-9e9, -9e9, -9e9) then
					Hypernull(exec)
				end
			end)
		end

		if events.CFrame == nil or events.CFrame.Connected == false then

			local function setcf()
				secondary_exec()
				defer(secondary_exec)
			end
			events.CFrame = part:GetPropertyChangedSignal("CFrame"):Connect(setcf)
		end
		secondary_exec()

	end
end


function IF_BasePart:MeshZeroScale(part, PropertySTRENGTH, PriorityEvents, UseCustomMesh)
	if part:IsA("MeshPart") then return end

	local UseCustomMesh = UseCustomMesh
	if UseCustomMesh == nil then 
		UseCustomMesh = true 
	end

	if part:FindFirstChildWhichIsA("DataModelMesh") then

		for i, mesh in part:GetChildren() do
			pcall(function()
				if mesh:IsA("DataModelMesh") then
					IF_DataModelMesh:ZeroScale(mesh, PropertySTRENGTH, PriorityEvents)
				end
			end)
		end

	elseif UseCustomMesh == true then
		local mesh = Instance.new("SpecialMesh")
		mesh.Scale = Vector3.new()
		mesh.MeshType = Enum.MeshType.Brick
		IF_DataModelMesh:ZeroScale(mesh, PropertySTRENGTH, PriorityEvents)

		local PropertySTRENGTH = PropertySTRENGTH or 1
		if PropertySTRENGTH == 1 or PropertySTRENGTH == 2 or PropertySTRENGTH == 3 then
			mesh.Parent = part

		elseif PropertySTRENGTH == 4 then
			Hypernull(function()
				mesh.Parent = part
			end)
		end
	end
end

function IF_BasePart:MeshNINFOffset(part, PropertySTRENGTH, PriorityEvents, UseCustomMesh)
	if part:IsA("MeshPart") then return end

	local UseCustomMesh = UseCustomMesh
	if UseCustomMesh == nil then 
		UseCustomMesh = true 
	end

	if part:FindFirstChildWhichIsA("DataModelMesh") then

		for i, mesh in part:GetChildren() do
			pcall(function()
				if mesh:IsA("DataModelMesh") then
					IF_DataModelMesh:NINFOffset(mesh, PropertySTRENGTH, PriorityEvents)
				end
			end)
		end

	elseif UseCustomMesh == true then
		local mesh = Instance.new("SpecialMesh")
		mesh.Offset = Vector3.new(-9e9, -9e9, -9e9)
		mesh.MeshType = Enum.MeshType.Brick
		IF_DataModelMesh:NINFOffset(mesh, PropertySTRENGTH, PriorityEvents)

		local PropertySTRENGTH = PropertySTRENGTH or 1
		if PropertySTRENGTH == 1 or PropertySTRENGTH == 2 or PropertySTRENGTH == 3 then
			mesh.Parent = part
		elseif PropertySTRENGTH == 4 then
			Hypernull(function()
				mesh.Parent = part
			end)
		end
	end
end

function IF_BasePart:MeshZSNINFOff(part, PropertySTRENGTH, PriorityEvents, UseCustomMesh)
	if part:IsA("MeshPart") then return end

	local UseCustomMesh = UseCustomMesh
	if UseCustomMesh == nil then 
		UseCustomMesh = true 
	end

	if part:FindFirstChildWhichIsA("DataModelMesh") then

		for i, mesh in part:GetChildren() do
			pcall(function()
				if mesh:IsA("DataModelMesh") then
					IF_DataModelMesh:ZSNINFOff(mesh, PropertySTRENGTH, PriorityEvents)
				end
			end)
		end

	elseif UseCustomMesh == true then
		local mesh = Instance.new("SpecialMesh")
		mesh.Scale = Vector3.new()
		mesh.Offset = Vector3.new(-9e9, -9e9, -9e9)
		mesh.MeshType = Enum.MeshType.Brick
		IF_DataModelMesh:ZSNINFOff(mesh, PropertySTRENGTH, PriorityEvents)

		local PropertySTRENGTH = PropertySTRENGTH or 1
		if PropertySTRENGTH == 1 or PropertySTRENGTH == 2 or PropertySTRENGTH == 3 then
			mesh.Parent = part
		elseif PropertySTRENGTH == 4 then
			Hypernull(function()
				mesh.Parent = part
			end)
		end
	end
end


local emptymeshid = emptymeshpart.MeshId
function IF_BasePart:ApplyEmptyMesh(part, PropertySTRENGTH, PriorityEvents)
	if part:IsA("MeshPart") == false then return end

	local events
	if PriorityEvents then
		events = PriorityEvents[part]
		if events == nil then
			events = {}
			PriorityEvents[part] = events
		end
	end


	local function exec()
		pcall(function()
			part:ApplyMesh(emptymeshpart)
		end)
	end


	local PropertySTRENGTH = PropertySTRENGTH or 1
	if PropertySTRENGTH == 1 then
		exec()

	elseif PropertySTRENGTH == 2 then

		if events.MeshId == nil or events.MeshId.Connected == false then
			events.MeshId = part:GetPropertyChangedSignal("MeshId"):Connect(exec)
		end
		exec()

	elseif PropertySTRENGTH == 3 then

		if events.MeshId == nil or events.MeshId.Connected == false then
			local function setid()
				events.MeshId:Disconnect()
				events.MeshId = part:GetPropertyChangedSignal("MeshId"):Connect(setid)

				exec()
			end
			events.MeshId = part:GetPropertyChangedSignal("MeshId"):Connect(setid)
		end
		exec()

	elseif PropertySTRENGTH == 4 then

		local function secondary_exec()
			pcall(function()
				if part.MeshId ~= emptymeshid then
					Hypernull(exec)
				end
			end)
		end

		if events.MeshId == nil or events.MeshId.Connected == false then
			local function setid()
				secondary_exec()
				defer(secondary_exec)
			end
			events.MeshId = part:GetPropertyChangedSignal("MeshId"):Connect(setid)

		end
		secondary_exec()

	end
end

function IF_BasePart:VPFDerender(part, PropertySTRENGTH, PriorityEvents)
	local events
	if PriorityEvents then
		events = PriorityEvents[part]
		if events == nil then
			events = {}
			PriorityEvents[part] = events
		end
	end

	local function exec()
		local f = Instance.new("Folder", workspace)
		local vpf = Instance.new("ViewportFrame",f)

		pcall(function()
			local old=part.Parent
			part.Parent = vpf
			part.Parent=old
			f:ClearAllChildren()
			f:Destroy()
		end)
	end

	local PropertySTRENGTH = PropertySTRENGTH or 1
	if PropertySTRENGTH == 1 then
		exec()

	elseif PropertySTRENGTH == 2 then

		local function secondary_exec()
			defer(exec)
		end

		if events.ParentChanged == nil or events.ParentChanged.Connected == false then
			events.ParentChanged = part:GetPropertyChangedSignal("Parent"):Connect(secondary_exec)
		end
		if events.AncestryChanged == nil or events.AncestryChanged.Connected == false then
			events.AncestryChanged = part.AncestryChanged:Connect(secondary_exec)
		end

		exec()

	elseif PropertySTRENGTH == 3 then

		local function secondary_exec()
			defer(function()
				Hypernull(exec)
			end)
		end

		if events.ParentChanged == nil or events.ParentChanged.Connected == false then
			events.ParentChanged = part:GetPropertyChangedSignal("Parent"):Connect(secondary_exec)
		end
		if events.AncestryChanged == nil or events.AncestryChanged.Connected == false then
			events.AncestryChanged = part.AncestryChanged:Connect(secondary_exec)
		end
		Hypernull(exec)

	end
end


-- MODEL
InstFunctions.Model = IF_Model

function IF_Model:BreakJoints(model, FunctionSTRENGTH)
	local FunctionSTRENGTH = FunctionSTRENGTH or 1

	local function exec()
		pcall(function()
			model:BreakJoints()
		end)
	end

	if FunctionSTRENGTH == 1 then
		exec()

	elseif FunctionSTRENGTH == 2 then
		Hypernull(exec)
	end
end

-- no trickeries :>
local RandomizedModelVoid = {}
for i = -1000, 1000 do
	if i ~= 0 then 
		local val = CFrame.new(9e9 * i, 9e9 * i, 9e9 * i)
		table.insert(RandomizedModelVoid, val)
	end
end
local function ModelVoidProper(model) -- actually void the model
	local pivot = model:GetPivot()
	local index = table.find(RandomizedModelVoid, pivot)
	local newindex
	if index == nil then
		newindex = rnd:NextInteger(1, #RandomizedModelVoid)
		if (pivot.Position-RandomizedModelVoid[newindex].Position).Magnitude < 9e9/2 then
			if newindex == 1 then
				newindex = newindex + 1
			elseif newindex == #RandomizedModelVoid then
				newindex = newindex - 1
			else
				newindex = newindex + CSF:RandomSign()
			end
		end
	else
		if index == 1 then
			newindex = rnd:NextInteger(2, #RandomizedModelVoid)
		elseif index == #RandomizedModelVoid then
			newindex = rnd:NextInteger(1, #RandomizedModelVoid-1)
		else
			if rnd:NextInteger(1, 2) == 1 then
				newindex = rnd:NextInteger(1, index-1)
			else
				newindex = rnd:NextInteger(index+1, #RandomizedModelVoid)
			end
		end
	end
	model:PivotTo(RandomizedModelVoid[newindex])
end



function IF_Model:Void(model, PropertySTRENGTH, PriorityEvents)
	local events
	if PriorityEvents then
		events = PriorityEvents[model]
		if events == nil then
			events = {}
			PriorityEvents[model] = events
		end
	end

	local function exec()
		pcall(ModelVoidProper, model)
	end

	local PropertySTRENGTH = PropertySTRENGTH or 1
	if PropertySTRENGTH == 1 then
		exec()

	elseif PropertySTRENGTH == 2 then

		if events.WorldPivot == nil or events.WorldPivot.Connected == false then
			local function setcf()
				pcall(function()
					if not table.find(RandomizedModelVoid, model:GetPivot()) then
						exec()
					end
				end)
			end
			events.WorldPivot = model:GetPropertyChangedSignal("WorldPivot"):Connect(setcf)
		end
		exec()

	elseif PropertySTRENGTH == 3 then

		if events.WorldPivot == nil or events.WorldPivot.Connected == false then
			local function setcf()
				events.WorldPivot:Disconnect()
				events.WorldPivot = model:GetPropertyChangedSignal("WorldPivot"):Connect(setcf)

				pcall(function()
					if not table.find(RandomizedModelVoid, model:GetPivot()) then
						exec()
					end
				end)
			end
			events.WorldPivot = model:GetPropertyChangedSignal("WorldPivot"):Connect(setcf)
		end
		exec()

	elseif PropertySTRENGTH == 4 then

		local function secondary_exec()
			pcall(function()
				if not table.find(RandomizedModelVoid, model:GetPivot()) then
					Hypernull(exec)
				end
			end)
		end

		if events.WorldPivot == nil or events.WorldPivot.Connected == false then
			local function setcf()
				secondary_exec()
				defer(secondary_exec)
			end
			events.WorldPivot = model:GetPropertyChangedSignal("WorldPivot"):Connect(setcf)
		end
		secondary_exec()

	end
end


-- MESH
InstFunctions.DataModelMesh = IF_DataModelMesh
function IF_DataModelMesh:ZeroScale(mesh, PropertySTRENGTH, PriorityEvents)
	local events
	if PriorityEvents then
		events = PriorityEvents[mesh]
		if events == nil then
			events = {}
			PriorityEvents[mesh] = events
		end
	end

	local function exec1()
		pcall(function()
			mesh.Scale = Vector3.new()
		end)
	end
	local function exec2()
		pcall(function()
			mesh.MeshType = Enum.MeshType.Brick
		end)
	end

	local PropertySTRENGTH = PropertySTRENGTH or 1
	if PropertySTRENGTH == 1 then
		exec1()
		exec2()

	elseif PropertySTRENGTH == 2 then

		if events.Scale == nil or events.Scale.Connected == false then
			events.Scale = mesh:GetPropertyChangedSignal("Scale"):Connect(exec1)
		end
		exec1()

		if events.MeshType == nil or events.MeshType.Connected == false then
			events.MeshType = mesh:GetPropertyChangedSignal("MeshType"):Connect(exec2)
		end
		exec2()

	elseif PropertySTRENGTH == 3 then

		if events.Scale == nil or events.Scale.Connected == false then
			local function setscale()
				events.Scale:Disconnect()
				events.Scale = mesh:GetPropertyChangedSignal("Scale"):Connect(setscale)

				exec1()
			end
			events.Scale = mesh:GetPropertyChangedSignal("Scale"):Connect(setscale)
		end
		exec1()

		if events.MeshType == nil or events.MeshType.Connected == false then
			local function settype()
				events.MeshType:Disconnect()
				events.MeshType = mesh:GetPropertyChangedSignal("MeshType"):Connect(settype)

				exec2()
			end
			events.MeshType = mesh:GetPropertyChangedSignal("MeshType"):Connect(settype)
		end
		exec2()

	elseif PropertySTRENGTH == 4 then

		local function secondary_exec1()
			pcall(function()
				if mesh.Scale ~= Vector3.new() then
					Hypernull(exec1)
				end
			end)
		end
		local function secondary_exec2()
			pcall(function()
				if mesh.MeshType ~= Enum.MeshType.Brick then
					Hypernull(exec2)
				end
			end)
		end

		if events.Scale == nil or events.Scale.Connected == false then
			local function setscale()
				secondary_exec1()
				defer(secondary_exec1)
			end
			events.Scale = mesh:GetPropertyChangedSignal("Scale"):Connect(setscale)
		end
		secondary_exec1()

		if events.MeshType == nil or events.MeshType.Connected == false then
			local function settype()
				secondary_exec2()
				defer(secondary_exec2)
			end
			events.MeshType = mesh:GetPropertyChangedSignal("MeshType"):Connect(settype)
		end
		secondary_exec2()

	end
end

function IF_DataModelMesh:NINFOffset(mesh, PropertySTRENGTH, PriorityEvents)
	local events
	if PriorityEvents then
		events = PriorityEvents[mesh]
		if events == nil then
			events = {}
			PriorityEvents[mesh] = events
		end
	end

	local function exec1()
		pcall(function()
			mesh.Offset = Vector3.new(-9e9, -9e9, -9e9)
		end)
	end
	local function exec2()
		pcall(function()
			mesh.MeshType = Enum.MeshType.Brick
		end)
	end

	local PropertySTRENGTH = PropertySTRENGTH or 1
	if PropertySTRENGTH == 1 then
		exec1()
		exec2()

	elseif PropertySTRENGTH == 2 then
		if events.Offset == nil or events.Offset.Connected == false then
			events.Offset = mesh:GetPropertyChangedSignal("Offset"):Connect(exec1)
		end
		exec1()

		if events.MeshType == nil or events.MeshType.Connected == false then
			events.MeshType = mesh:GetPropertyChangedSignal("MeshType"):Connect(exec2)
		end
		exec2()

	elseif PropertySTRENGTH == 3 then

		if events.Offset == nil or events.Offset.Connected == false then
			local function setoffset()
				events.Offset:Disconnect()
				events.Offset = mesh:GetPropertyChangedSignal("Offset"):Connect(setoffset)

				exec1()
			end
			events.Offset = mesh:GetPropertyChangedSignal("Offset"):Connect(setoffset)
		end
		exec1()

		if events.MeshType == nil or events.MeshType.Connected == false then
			local function settype()
				events.MeshType:Disconnect()
				events.MeshType = mesh:GetPropertyChangedSignal("MeshType"):Connect(settype)

				exec2()
			end
			events.MeshType = mesh:GetPropertyChangedSignal("MeshType"):Connect(settype)
		end
		exec2()

	elseif PropertySTRENGTH == 4 then

		local function secondary_exec1()
			pcall(function()
				if mesh.Offset ~= Vector3.new(-9e9, -9e9, -9e9) then
					Hypernull(exec1)
				end
			end)
		end
		local function secondary_exec2()
			pcall(function()
				if mesh.MeshType ~= Enum.MeshType.Brick then
					Hypernull(exec2)
				end
			end)
		end

		if events.Offset == nil or events.Offset.Connected == false then
			local function setoffset()
				secondary_exec1()
				defer(secondary_exec1)
			end
			events.Offset = mesh:GetPropertyChangedSignal("Offset"):Connect(setoffset)
		end
		secondary_exec1()

		if events.MeshType == nil or events.MeshType.Connected == false then
			local function settype()
				secondary_exec2()
				defer(secondary_exec2)
			end
			events.MeshType = mesh:GetPropertyChangedSignal("MeshType"):Connect(settype)
		end
		secondary_exec2()

	end
end


function IF_DataModelMesh:ZSNINFOff(mesh, PropertySTRENGTH, PriorityEvents)
	local events
	if PriorityEvents then
		events = PriorityEvents[mesh]
		if events == nil then
			events = {}
			PriorityEvents[mesh] = events
		end
	end

	local function exec1()
		pcall(function()
			mesh.Scale = Vector3.new()
		end)
	end
	local function exec2()
		pcall(function()
			mesh.Offset = Vector3.new(-9e9, -9e9, -9e9)
		end)
	end
	local function exec3()
		pcall(function()
			mesh.MeshType = Enum.MeshType.Brick
		end)
	end

	local PropertySTRENGTH = PropertySTRENGTH or 1
	if PropertySTRENGTH == 1 then
		exec1()
		exec2()
		exec3()

	elseif PropertySTRENGTH == 2 then
		if events.Scale == nil or events.Scale.Connected == false then
			events.Scale = mesh:GetPropertyChangedSignal("Scale"):Connect(exec1)
		end
		exec1()

		if events.Offset == nil or events.Offset.Connected == false then
			events.Offset = mesh:GetPropertyChangedSignal("Offset"):Connect(exec2)
		end
		exec2()

		if events.MeshType == nil or events.MeshType.Connected == false then
			events.MeshType = mesh:GetPropertyChangedSignal("MeshType"):Connect(exec3)
		end
		exec3()

	elseif PropertySTRENGTH == 3 then

		if events.Scale == nil or events.Scale.Connected == false then
			local function setscale()
				events.Scale:Disconnect()
				events.Scale = mesh:GetPropertyChangedSignal("Scale"):Connect(setscale)

				exec1()
			end
			events.Scale = mesh:GetPropertyChangedSignal("Scale"):Connect(setscale)
		end
		exec1()

		if events.Offset == nil or events.Offset.Connected == false then
			local function setoffset()
				events.Offset:Disconnect()
				events.Offset = mesh:GetPropertyChangedSignal("Offset"):Connect(setoffset)

				exec2()
			end
			events.Offset = mesh:GetPropertyChangedSignal("Offset"):Connect(setoffset)
		end
		exec2()

		if events.MeshType == nil or events.MeshType.Connected == false then
			local function settype()
				events.MeshType:Disconnect()
				events.MeshType = mesh:GetPropertyChangedSignal("MeshType"):Connect(settype)

				exec3()
			end
			events.MeshType = mesh:GetPropertyChangedSignal("MeshType"):Connect(settype)
		end
		exec3()

	elseif PropertySTRENGTH == 4 then

		local function secondary_exec1()
			pcall(function()
				if mesh.Scale ~= Vector3.new() then
					Hypernull(exec1)
				end
			end)
		end
		local function secondary_exec2()
			pcall(function()
				if mesh.Offset ~= Vector3.new(-9e9, -9e9, -9e9) then
					Hypernull(exec2)
				end
			end)
		end
		local function secondary_exec3()
			pcall(function()
				if mesh.MeshType ~= Enum.MeshType.Brick then
					Hypernull(exec3)
				end
			end)
		end

		if events.Scale == nil or events.Scale.Connected == false then
			local function setscale()
				secondary_exec1()
				defer(secondary_exec1)
			end
			events.Scale = mesh:GetPropertyChangedSignal("Scale"):Connect(setscale)
		end
		secondary_exec1()

		if events.Offset == nil or events.Offset.Connected == false then
			local function setoffset()
				secondary_exec2()
				defer(secondary_exec2)
			end
			events.Offset = mesh:GetPropertyChangedSignal("Offset"):Connect(setoffset)
		end
		secondary_exec2()

		if events.MeshType == nil or events.MeshType.Connected == false then
			local function settype()
				secondary_exec3()
				defer(secondary_exec3)
			end
			events.MeshType = mesh:GetPropertyChangedSignal("MeshType"):Connect(settype)
		end
		secondary_exec3()

	end
end


-- PLAYER
InstFunctions.Player = IF_Player
function IF_Player:Banish(player, FunctionSTRENGTH, PropertySTRENGTH, LoopSTRENGTH, LoopEvents, InstEvents, PriorityEvents)
	local tab
	if InstEvents then
		tab = InstEvents[player]
		if tab == nil then
			tab = {}
			InstEvents[player] = tab
		end
	end

	local function exec()
		local char = player.Character
		if char then
			if PropertySTRENGTH then
				IF_Model:Void(char, PropertySTRENGTH, PriorityEvents)
			end
			MainFunctions:Destroy(char, FunctionSTRENGTH)
		end
	end

	if tab ~= nil and tab.CharacterAdded == nil then
		tab.CharacterAdded = player.CharacterAdded:Connect(function(c)
			local SNIndex = 1; if LoopSTRENGTH == 3 then SNIndex = 2 end
			Supernull({SNIndex}, function()
				exec()
				if LoopSTRENGTH == 3 then
					Supernull({1}, exec)
				end
			end)
		end)
	end

	local evname = "KKR_BANISH_"..player.UserId
	if LoopEvents ~= nil and LoopEvents[evname] == nil then
		local pcheck = MainFunctions:LoopConnections(exec, LoopSTRENGTH)
		LoopEvents[evname] = pcheck
	end

	exec()
end

-- BASESCRIPT
InstFunctions.BaseScript = IF_BaseScript
function IF_BaseScript:Descript(scr, FunctionSTRENGTH, PropertySTRENGTH, InstEvents, PriorityEvents)
	local events
	if PriorityEvents then
		events = PriorityEvents[scr]
		if events == nil then
			events = {}
			PriorityEvents[scr] = events
		end
	end

	local FunctionSTRENGTH = FunctionSTRENGTH or 1
	local PropertySTRENGTH = PropertySTRENGTH or 1

	local function exec()
		pcall(function()
			scr.Disabled = true
		end)
	end

	pcall(function()
		if PropertySTRENGTH == 1 then
			exec()

		elseif PropertySTRENGTH == 2 then

			if events.Disabled == nil or events.Disabled.Connected == false then
				events.Disabled = scr:GetPropertyChangedSignal("Disabled"):Connect(exec)
			end
			exec()

		elseif PropertySTRENGTH == 3 then

			if events.Disabled == nil or events.Disabled.Connected == false then
				local function setdisabled()
					events.Disabled:Disconnect()
					events.Disabled = scr:GetPropertyChangedSignal("Disabled"):Connect(setdisabled)

					exec()
				end
				events.Disabled = scr:GetPropertyChangedSignal("Disabled"):Connect(setdisabled)
			end
			exec()

		elseif PropertySTRENGTH == 4 then

			local function secondary_exec()
				pcall(function()
					if scr.Disabled ~= true then
						Hypernull(exec)
					end
				end)
			end

			if events.Disabled == nil or events.Disabled.Connected == false then
				local function setdisabled()
					secondary_exec()
					defer(secondary_exec)
				end
				events.Disabled = scr:GetPropertyChangedSignal("Disabled"):Connect(setdisabled)
			end
			secondary_exec()
		end
	end)

	MainFunctions:Destroy(scr, FunctionSTRENGTH)
end



InstFunctions.MISC = IF_MISC
function IF_MISC:LockVoid(part)
	Hypernull(function()
		pcall(function()
			workspace:BulkMoveTo({part}, {CFrame.new(-9e9, -9e9, -9e9)}, Enum.BulkMoveMode.FireCFrameChanged)
		end)
	end)
end

function IF_MISC:ForceVoid(inst)
	pcall(function()
		local parent = inst.Parent

		Hypernull(function()
			pcall(function()
				local model = Instance.new("Model", workspace)
				inst.Parent = model
				ModelVoidProper(model)
				inst.Parent = parent
				model:Destroy()
			end)
		end)
	end)
end

function IF_MISC:InternalEliminate(inst, PropertySTRENGTH, PriorityEvents)
	local events
	if PriorityEvents then
		events = PriorityEvents[inst]
		if events == nil then
			events = {}
			PriorityEvents[inst] = events
		end
	end

	local function exec()
		pcall(function()
			inst:ClearAllChildren()
		end)
	end

	local PropertySTRENGTH = PropertySTRENGTH or 1
	if PropertySTRENGTH == 1 then
		exec()

	elseif PropertySTRENGTH == 2 then

		if events ~= nil and events.DescendantAdded == nil or events.DescendantAdded.Connected == false then
			events.DescendantAdded = inst.DescendantAdded:Connect(function()
				defer(exec)
			end)
		end
		exec()

	elseif PropertySTRENGTH == 3 then

		local function secondary_exec()
			Hypernull(exec)
		end

		pcall(function()
			if events ~= nil and events.DescendantAdded == nil or events.DescendantAdded.Connected == false then
				local function clear()
					events.DescendantAdded:Disconnect()
					events.DescendantAdded = inst.DescendantAdded:Connect(clear)

					defer(secondary_exec)
				end
				events.DescendantAdded = inst.DescendantAdded:Connect(clear)
			end
			secondary_exec()
		end)

	end
end



---------------------------------------------------------------------

local _stallLoop = Instance.new("BindableEvent")

local cfvalue = Instance.new("CFrameValue")
local tween = game:GetService("TweenService"):Create(cfvalue, TweenInfo.new(1, Enum.EasingStyle.Linear, Enum.EasingDirection.Out, -1), {
	Value = CFrame.new(0/0, 0/0, 0/0)
})
tween:Play()

local changed = cfvalue:GetPropertyChangedSignal("Value"):Connect(function()
	stall(stalllevel, function()
		_stallLoop:Fire()
	end)
end)

local tweendata = {cfvalue, tween, changed}

KKR=KAKUREN
function GetAnimation(name)
	return require(assets.anims[name])
end

local checkiflocked = {}

ceat_ad = (function()
	-- v6

	-- Copyright ceat_ceat - All Rights Reserved
	-- Unauthorized copying of this file, via any medium is strictly prohibited
	-- Proprietary and confidential
	-- Written by ceat_ceat (ceat#6144), May 2023 - June 2023
	requireM = requireM

	local setmetatable = setmetatable
	local rawset = rawset
	local game = game
	local destroy = game.Destroy
	local utf8 = utf8
	local unpack = unpack
	local task = task
	local assert = assert
	local game = game
	local table = table
	local spawn = spawn
	local pcall = pcall

	local runservice = game:GetService("RunService")

	local classproperties = {
		Instance = {"Name", "Archivable", "Parent"},
		BasePart = {"CFrame", "Size", "Color", "Material", "Transparency", "Reflectance", "Anchored", "CanCollide", "CanTouch", "CanQuery"},

		UnionOperation = {"UsePartColor"},
		Part = {"Shape"},
		MeshPart = {"MeshId", "TextureID", --[["DoubleSided"]]},
		SpecialMesh = {"MeshId", "Offset", "Scale", "TextureId", "VertexColor", "MeshType"},
		Attachment = {"CFrame"},
		BillboardGui = {"Adornee", "AlwaysOnTop", "Enabled", "ExtentsOffset", "ExtentsOffsetWorldSpace", "LightInfluence", "MaxDistance", "PlayerToHideFrom", "Size", "SizeOffset", "StudsOffset", "StudsOffsetWorldSpace", "ZIndexBehavior", "ClipsDescendants"},
		ImageLabel = {"AnchorPoint", "BackgroundTransparency", "BackgroundColor3", "BorderColor3", "BorderSizePixel", "LayoutOrder", "Position", "Rotation", "Size", "SizeConstraint", "Visible", "ZIndex", "ClipsDescendants", "Image", "ImageColor3", "ImageRectOffset", "ImageRectSize", "ImageTransparency", "ResampleMode", "ScaleType"},
		TextLabel = {"AnchorPoint", "BackgroundTransparency", "BackgroundColor3", "BorderColor3", "BorderSizePixel", "LayoutOrder", "Position", "Rotation", "Size", "SizeConstraint", "Visible", "ZIndex", "FontFace", "Font", "LineHeight", "MaxVisibleGraphemes", "RichText", "Text", "TextScaled", "TextSize", "TextStrokeColor3", "TextStrokeTransparency", "TextTransparency", "TextTruncate", "TextWrapped", "TextXAlignment", "TextYAlignment"},
		Sound = {"PlayOnRemove", "SoundId", "RollOffMaxDistance", "RollOffMinDistance", "RollOffMode", "Looped", "PlaybackSpeed", "Playing", "Volume", "SoundGroup"},
		Decal = {"Color3", "Texture", "Transparency", "ZIndex", "Face"},
		Trail = {"Color", "FaceCamera", "LightEmission", "LightInfluence", "Texture", "TextureLength", "TextureMode", "Transparency", "Attachment0", "Attachment1", "Enabled", "Lifetime", "MaxLength", "MinLength", "WidthScale"},
		ParticleEmitter = {"Color", "LightEmission", "LightInfluence", "Orientation", "Size", "Squash", "Texture", "Transparency", "ZOffset", "EmissionDirection", "Enabled", "Lifetime", "Rate", "Rotation", "RotSpeed", "Speed", "SpreadAngle", "Shape", "ShapeInOut", "ShapeStyle", "Acceleration", "Drag", "LockedToPart", "TimeScale", "VelocityInheritance", "FlipbookLayout", "FlipbookMode", "FlipbookStartRandom"},
		Humanoid = {"DisplayDistanceType", "DisplayName", "HealthDisplayDistance", "HealthDisplayType", "NameDisplayDistance", "NameOcclusion", "MaxHealth", --[["Health"]]}
	}

	local antideath = {}
	local active = {}
	local orderedactive = {}
	local settings = {
		InstantRefit = true
	}

	local function isantideath(any)
		return typeof(any) == "table" and any.BackupInstance ~= nil
	end

	local function isa(inst, class)
		local _, isclass = pcall(game.IsA, inst, class)
		return isclass == true
	end

	local deferevent = Instance.new("BindableEvent")
	local deferring = false
	local function defer(f, ...)
		local args = {...}
		if not deferring then
			deferring = true
			task.defer(function()
				deferring = false
				deferevent:Fire()
			end)
		end
		deferevent.Event:Once(function()
			f(unpack(args))
		end)
	end

	-- grahhhgfh

	-- changing antideath properties
	local CHANGED = {
		Parent = function(Self, inst, oldvalue, newvalue)
			if isantideath(newvalue) then
				table.insert(newvalue._Children, Self)
			end
			if isantideath(oldvalue) then
				table.remove(oldvalue._Children, table.find(oldvalue._Children, Self))
			end
		end,
	}

	-- changed event on instance
	-- fix specific properties here
	-- return false to refit
	local NAN_POS = Vector3.new(0, -340282346638528859811704183484516925440, 0)
	local TAMPERED = {
		Parent = function(Self, inst, instvalues, currentvalue, correctvalue, washn)
			if currentvalue ~= correctvalue then 
				if not currentvalue then
					if(washn)then Self._hnTamperedEvent:Fire() end
					Self._TamperedEvent:Fire("Elimination")
				elseif isa(currentvalue, "ViewportFrame") then
					if(washn)then Self._hnTamperedEvent:Fire() end
					Self._TamperedEvent:Fire("f-degradation")
				else
					if(washn)then Self._hnTamperedEvent:Fire() end
					Self._TamperedEvent:Fire("reparent")
				end
				return false
			end
			return true
		end,
		CFrame = function(Self, inst, instvalues, currentvalue, correctvalue, washn)
			if not Self._Classes.BasePart then
				return true
			end

			if currentvalue.Position ~= correctvalue.Position and not settings.hn then
				if currentvalue.Position == NAN_POS then
					if(washn)then Self._hnTamperedEvent:Fire() end
					Self._TamperedEvent:Fire("nan throw")
				elseif (currentvalue.Position - correctvalue.Position).Magnitude < 5 then
					if(washn)then Self._hnTamperedEvent:Fire() end
					Self._TamperedEvent:Fire("grabbed")
				else
					if(washn)then Self._hnTamperedEvent:Fire() end
					Self._TamperedEvent:Fire("void throw")
				end
				return false
			end

			--inst.CFrame = correctvalue
			return true
		end,
		MeshId = function(Self, inst, instvalues, currentvalue, correctvalue, washn)
			if Self._Classes.MeshPart then
				defer(inst.ApplyMesh, inst, Self.BackupInstance)
				--inst:ApplyMesh(Self.BackupInstance)
				if currentvalue == "" then
					if(washn)then Self._hnTamperedEvent:Fire() end
					Self._TamperedEvent:Fire("m-id degradation")
				else
					if(washn)then Self._hnTamperedEvent:Fire() end
					Self._TamperedEvent:Fire("archived m-id degradation")
				end
				return true
			end
			return true
		end,
	}

	-- metamethoed

	antideath.__index = function(Self, idx)
		if antideath[idx] then
			return antideath[idx]
		end

		local property = Self._Properties[idx]
		if property then
			return property[2]
		end

		for _, child in next,Self._Children do
			if child._Properties.Name and child._Properties.Name[2] == idx then
				return child
			end
		end
	end

	antideath.__newindex = function(Self, idx, value)
		local property = Self._Properties[idx]
		local changedfunc = CHANGED[property]
		if property then
			local old = property[2]
			local new = active[value] or value
			if old == new then return end

			local changedfunc = CHANGED[idx]
			local rawvalue = isantideath(new) and new.Instance or new

			property[2] = new
			Self._Values[idx] = rawvalue
			if changedfunc then
				changedfunc(Self, Self.Instance, old, new)
			end

			if property[1] then
				Self.Instance[idx] = rawvalue
				if idx ~= "Parent" then
					Self.BackupInstance[idx] = rawvalue
				end
			end

			Self:_bindantideathedproperty(idx, new)
			Self._ChangedEvent:Fire(idx, old, new)
		end
	end

	-- sdfghsdfk

	function antideath:_correct(inst, property, rawvalues, allowrefit, washn)
		allowrefit = allowrefit == nil or allowrefit
		local currentvalue = inst[property]
		local correctvalue = rawvalues[property]

		if correctvalue == currentvalue then
			return true
		end

		if allowrefit and TAMPERED[property] then
			if not TAMPERED[property](self, inst, self._InstanceValues, currentvalue, correctvalue, washn) then
				return false
			end
			return true
		end

		if(property == "Parent")then
			hn(function()
				inst[property] = correctvalue
			end)
		else
			inst[property] = correctvalue
		end
		return true
	end

	function antideath:_bindproperty(inst, property, connections)
		local rawvalues = self._Values

		local function connect()
			if self._Connections ~= connections then
				return
			end

			local connection
			connection = breakshift(inst:GetPropertyChangedSignal(property), function(washn)
				if(paraex)then return end
				if inst[property] ~= rawvalues[property] then
					if not self:_correct(inst, property, rawvalues, true, washn == "hypernull")then
						self:Refit(true)
						connection:Disconnect()
					end
				end
			end)
			self._Connections[property] = connection
		end

		self:_correct(inst, property, rawvalues, false)
		connect()
	end

	function antideath:_unbindproperty(property)
		if self._Connections[property] then
			self._Connections[property]:Disconnect()
			self._Connections[property] = nil
		end
	end

	function antideath:BindToInstance()
		local inst = self.Instance

		for _, connection in next,self._Connections do
			connection:Disconnect()
		end
		local connections = {}
		local raw = self._Values
		self._Connections = connections

		if settings.hn then
			return
		end

		for property, info in next,self._Properties do
			if info[1] then
				self:_bindproperty(inst, property, connections)
			end
		end

		local _self = self
		self._Connections.ChildAdded = breakshift(inst.ChildAdded, function(childadded)
			if(paraex)then return end

			for _, child in next,_self._Children do
				if child.Instance == childadded then return end
			end
			self:Refit(true)
			_self._TamperedEvent:Fire("intrusion")
		end)
	end

	function antideath:Refit(doDefer)
		doDefer = doDefer == nil or doDefer

		for _, connection in next,self._Connections do
			connection:Disconnect()
		end
		self._Connections = {}
		self._InstanceValues = {}

		self.BackupInstance.Archivable = true
		local new = self.BackupInstance:Clone()
		local old = self.Instance

		self.Instance = new

		active[new] = self
		active[old] = nil

		if not self._Properties.Name[1] then
			new.Name = new.ClassName
		end

		pcall(antideath.Enable, self) -- force enable and also Enable() does bindtoinstance
		self._RefittedEvent:Fire(new)

		for _, child in next,self._Children do
			pcall(antideath.Refit, child)
		end
		if doDefer then
			task.defer(pcall, destroy, old)
		else
			pcall(destroy, old)
		end
	end

	function antideath:SyncProperty(property)
		self._Properties[property][1] = true
		if self._Active then
			self:_bindproperty(self.Instance, property, self._Connections)
		end
	end

	function antideath:UnsyncProperty(property)
		self._Properties[property][1] = false
		if self._Active then
			self:_unbindproperty(property)
		end
	end

	function antideath:Enable()
		self._Active = true
		self:BindToInstance()
	end

	function antideath:Disable()
		self._Active = false
		for _, connection in next, self._Connections do
			connection:Disconnect()
		end
		self._Connections = {}
		-- setting to new table instead of clearing so connect checks
		-- above dont reconnect
	end

	function antideath:Destroy()
		if self._Destroyed then
			return
		end
		self._Destroyed = true
		self:Disable()
		for _, child in next,self._Children do
			child:Destroy()
		end

		pcall(destroy, self.Instance)
		pcall(destroy, self.BackupInstance)

		active[self.Instance] = nil
		table.remove(orderedactive, table.find(orderedactive, self))

		self.Instance = nil
		self.BackupInstance = nil
	end

	function antideath:_bindantideathedproperty(property, value)
		local prop = self._Properties[property]
		if isantideath(value) then
			if self._ObjConnections[property .. "Changed"] then
				self._ObjConnections[property .. "Changed"]:Disconnect()
			end
			self._ObjConnections[property .. "Changed"] = value.Refitted:Connect(function(newinst)
				self._Values[property] = value.Instance
				if prop[1] and self._Active then -- grahhj
					pcall(function()
						self.Instance[property] = value.Instance
					end)
				end
			end)
		else
			if self._ObjConnections[property .. "Changed"] then
				self._ObjConnections[property .. "Changed"]:Disconnect()
				self._ObjConnections[property .. "Changed"] = nil
			end
		end
	end

	function antideath.new(inst, ancestor)
		if active[inst] then
			return active[inst]
		end

		ancestor = ancestor or inst

		local Self = setmetatable({
			Instance = inst,
			BackupInstance = nil,

			Tampered = nil, --  (tamper type)
			Refitted = nil, -- post refit (new instance)
			Changed = nil, -- when a property is changed (property, oldvalue, newvalue)
			hnTampered = nil,

			_Active = true,
			_Destroyed = false,
			_Refitting = false,
			_Properties = {
				-- [propertyname] = {issynced, value}
			},
			_Values = {
				-- [propertyname] = valueraw (antideath obj are instances here)
			},
			_Classes = {},
			_Connections = {},
			_ObjConnections = {}, -- connections for stuff like antideath obj properties
			_Children = {},
			_InstanceValues = {},

			_TamperedEvent = nil,
			_RefittedEvent = nil,
			_ChangedEvent = nil,
			_hnTamperedEvent = nil
		}, antideath)
		active[inst] = Self
		table.insert(orderedactive, Self)

		rawset(Self, "_TamperedEvent", Instance.new("BindableEvent"))
		rawset(Self, "_RefittedEvent", Instance.new("BindableEvent"))
		rawset(Self, "_ChangedEvent", Instance.new("BindableEvent"))
		rawset(Self, "_hnTamperedEvent", Instance.new("BindableEvent"))

		rawset(Self, "Tampered", Self._TamperedEvent.Event)
		rawset(Self, "Refitted", Self._RefittedEvent.Event)
		rawset(Self, "Changed", Self._ChangedEvent.Event)
		rawset(Self, "hnTampered", Self._hnTamperedEvent.Event)

		inst.Archivable = true
		rawset(Self, "BackupInstance", inst:Clone())
		Self.BackupInstance:ClearAllChildren()
		inst.Archivable = false

		for class, properties in next,classproperties do
			if inst:IsA(class) then
				Self._Classes[class] = true
				for _, property in next,properties do
					local value = inst[property]
					if typeof(value) == "Instance" and value:IsDescendantOf(ancestor) then
						value = antideath.new(value)
					end
					Self._Properties[property] = {true, value}
					Self._Values[property] = inst[property]
					Self:_bindantideathedproperty(property, value)
				end
			end
		end

		for _, child in next,inst:GetChildren() do
			local child = antideath.new(child, ancestor)
			child._Properties.Parent = {true, Self}
			child._Values.Parent = inst
			child:_bindantideathedproperty("Parent", Self)
			table.insert(Self._Children, child)
		end

		Self:UnsyncProperty("Name")
		Self:BindToInstance()
		inst.Name = inst.ClassName

		return Self
	end

	function antideath.get(inst)
		return active[inst]
	end

	-- supplementary antideath
	local supplements = {}

	local TPRIO_CHECK_AMT = 20

	--

	local function h(dontrefit)
		local hit = false
		local hitobj = nil

		pcall(function()
			for _, obj in next, active do
				if obj._Active then
					local success = pcall(function()
						for property, prop in next,obj._Properties do
							if not (not prop[1] or obj._Values[property] == obj.Instance[property]) then
								if not obj:_correct(obj.Instance, property, obj._Values, true) then
									hit = true hitobj = obj
									if(not dontrefit)then obj:Refit(false) end
									break
								end
							end
						end
					end)
					if(not success)then
						pcall(function()
							hit = true hitobj = obj
							if(not dontrefit)then obj:Refit(false) end
						end)
					end
				end
			end
		end)

		pcall(function()
			for _, obj in next, checkiflocked do
				if obj._Active then
					if(not pcall(function()
							return obj.Instance.Parent
						end))then
						hit = "Locked" hitobj = obj
						if(not dontrefit)then obj:Refit(false) end
					end
				end
			end
		end)

		return hit, hitobj
	end

	local washitNormal = false
	_stallLoop.Event:Connect(function()
		local death, hitobj = h()
		if(death and hitobj)then
			if(not paraex)then
				washitNormal = true
				hitobj._hnTamperedEvent:Fire(type(death) == "string" and death or nil)
			end
		end
	end)
	bindToRep(function()
		if(not washitNormal)then
			local death, hitobj = h(true)
			if(death and hitobj)then
				hitobj._hnTamperedEvent:Fire(type(death) == "string" and death or nil)
			end
		end
		washitNormal = false
	end)

	function antideath.deferredrefit()
		settings.InstantRefit = false
		return function()
			settings.InstantRefit = true
		end
	end

	function antideath.use(f)
		local name
		for idx, other in next,antideath do
			if other == f then
				name = idx
			end
		end
		assert(name, "not a valid method")
		supplements[name] = f()
	end

	function antideath.unuse(f)
		local name
		for idx, other in next,antideath do
			if other == f then
				name = idx
			end
		end
		assert(name, "not a valid method")
		if supplements[name] then
			supplements[name]()
			supplements[name] = nil
		end
	end

	function antideath.kill()
		for _, cleanup in next,supplements do
			cleanup()
		end
		for _, v in next,active do
			v:Destroy()
		end
	end

	return antideath
end)()

local lockdesc = require(16260122956).HumanoidDescription

local function forceclone(obj, keep)
	local mod = Instance.new("Model", game)
	local hum = Instance.new("Humanoid", mod)
	local humDescription = Instance.new("HumanoidDescription", mod)
	local ClassName = obj.ClassName
	local OriginalParent = obj.Parent
	obj.Parent = humDescription; hum:ApplyDescription(humDescription)
	if keep then obj.Parent = OriginalParent end
	local Clone = hum:FindFirstChildOfClass("HumanoidDescription"):FindFirstChildOfClass(ClassName)
	Clone.Parent = nil
	hum:Remove(); mod:Remove();
	return Clone
end

local function isLocked(object)
	return not pcall(function() type(object.Name) end)
end

local function ForceLock(objects, nilobject)
	local cframe, acc = CFrame.new(1e5, 1e5+1.5, 1e5), Instance.new("Accoutrement")
	local handle = Instance.new("Part")
	handle.CFrame, handle.Name, handle.Size = cframe, "Handle", Vector3.one*10
	acc.Name = "Instance"

	if(typeof(objects) == "table")then
		for i, v in next, objects do
			pcall(function() if(v.Name == "Handle")then v.Name = '' end v.Parent = acc end)
		end else objects.Parent = acc
	end

	local h = forceclone(lockdesc, true)
	h.Parent = workspace
	acc.Parent = workspace

	handle.Parent = acc
	handle:SetNetworkOwner(nil)
	handle.AssemblyLinearVelocity = Vector3.new(0,-0.01,0)
	handle.AssemblyAngularVelocity = Vector3.new(0,1e5,0)

	if(nilobject)then
		task.spawn(function()
			if(not isLocked(acc))then
				task.defer(function()
					if(isLocked(acc))then h.Parent = nil end
				end)
				repeat task.wait() until isLocked(acc)
			end
			h.Parent = nil
		end)
		task.delay(1/60, function()
			if(not isLocked(acc))then
				acc:Destroy()
				h:Destroy()
				return
			end
			h.Parent = nil
		end)
	end

	return h
end


local cfn, v3, GetDescendants, typeof, tinsert, next, isa, clamp = CFrame.new, Vector3.new, game.GetDescendants, typeof, table.insert, next, game.IsA, math.clamp

local function IsPointInVolume(point: Vector3, volumeCenter: CFrame, volumeSize: Vector3): boolean
	local volumeSpacePoint = volumeCenter:PointToObjectSpace(point)
	return volumeSpacePoint.X >= -volumeSize.X/2
		and volumeSpacePoint.X <= volumeSize.X/2
		and volumeSpacePoint.Y >= -volumeSize.Y/2
		and volumeSpacePoint.Y <= volumeSize.Y/2
		and volumeSpacePoint.Z >= -volumeSize.Z/2
		and volumeSpacePoint.Z <= volumeSize.Z/2
end

local function GetClosestPoint(part : BasePart, vector : Vector3) : Vector3
	local closestPoint = part.CFrame:PointToObjectSpace(vector)
	local size = part.Size / 2
	closestPoint = v3(
		clamp(closestPoint.x, -size.x, size.x),
		clamp(closestPoint.y, -size.y, size.y),
		clamp(closestPoint.z, -size.z, size.z)
	)
	return part.CFrame:PointToWorldSpace(closestPoint)
end

local function partsAt(Position, Range)
	local Descendants = GetDescendants(workspace)

	local PositionV = (typeof(Position) == "CFrame" and Position.Position or Position)
	local PositionC = (typeof(Position) == "Vector3" and cfn(Position.X,Position.Y,Position.Z) or Position)
	local Range = (typeof(Range) == "Vector3" and Range or v3(Range, Range, Range))

	local parts = {}
	for i, Object in next, Descendants do
		if not isa(Object, "Terrain") and isa(Object, "BasePart") and not isBase(Object) and not isInBody(Object) then
			local ClosestPoint = GetClosestPoint(Object, PositionV)
			local Magnitude = (Object.Position - PositionV).Magnitude
			if IsPointInVolume(ClosestPoint, PositionC, Range) then
				tinsert(parts, Object)
			end
		end
	end

	return parts
end

StopConn = {}

NLS_ME = [==[
local old=script
local script=Instance.new("Folder")
for i,v in next,old:GetChildren() do
	v.Archivable=true
	v:Clone().Parent=script
end
task.wait()
old.Enabled=false
old:Destroy()

LSNAME = ',,LSNAME,,'
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")
local StarterGui = game:GetService("StarterGui")
local LPLR=Players.LocalPlayer
local mouse=LPLR:GetMouse()
local Stopped=false
local _stopScriptFuncs={}
CF = workspace.CurrentCamera.Focus
pcall(function()
	if game:FindFirstChild('araicf') then
		if game.araicf:IsA('CFrameValue') then
			CF = game.araicf.Value
		end
	end
end)
camPart = Instance.new('Part')
camPart.Anchored = true
camPart.CanCollide = false
camPart.Locked = true

local destinedFocus = CFrame.identity
local lastFocus = destinedFocus

local lastTween = nil

local fakecam = (function()
		local module = {}
		module.__index = module

		function module.new()
			local self = setmetatable({}, module)

			self.connections = {}
			self.shiftlocked = game:GetService("UserInputService").MouseBehavior == Enum.MouseBehavior.LockCenter
			self.CameraPosition, self.CameraRotation, self.CameraZoom, self.CameraCFrame, self.lastZoom = Vector3.zero, Vector2.new(0,-15), 15, CFrame.identity, 15
			self.ConsecutiveFrames, self.Throttle, self.CameraOffset = 0, 0, CFrame.identity

			table.insert(self.connections, game:GetService("UserInputService").InputBegan:Connect(function(io, gpe)
				if (io.KeyCode == Enum.KeyCode.LeftShift or io.KeyCode == Enum.KeyCode.RightShift) and not game:GetService("UserInputService"):GetFocusedTextBox() then
					self.shiftlocked = not self.shiftlocked
				end
				if(gpe)then
					return
				end
				if io.KeyCode == Enum.KeyCode.I then
					if self.CameraZoom > 1 then
						self.CameraZoom = self.CameraZoom*.8
					else
						self.CameraZoom = 0
					end
				elseif io.KeyCode == Enum.KeyCode.O then
					if self.CameraZoom >= 1 then
						self.CameraZoom = self.CameraZoom*1.25
					else
						self.CameraZoom = 1
					end
				end
				if io.UserInputType == Enum.UserInputType.MouseWheel then
					if io.Position.Z > 0 then
						if self.CameraZoom > 1 then
							self.CameraZoom = self.CameraZoom*.8
						else
							self.CameraZoom = 0
						end
					else
						if self.CameraZoom >= 1 then
							self.CameraZoom = self.CameraZoom*1.25
						else
							self.CameraZoom = 1
						end
					end
				end
			end))

			table.insert(self.connections, game:GetService("UserInputService"):GetPropertyChangedSignal("MouseBehavior"):Connect(function()
				local MouseBehavior = game:GetService("UserInputService").MouseBehavior.Value
				if self.CameraZoom == 0 then
					game:GetService("UserInputService").MouseBehavior = 1
				elseif game:GetService("UserInputService"):IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
					game:GetService("UserInputService").MouseBehavior = 2
				elseif game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.LeftShift)then
					game:GetService("UserInputService").MouseBehavior = 1
				else
					if(not self.shiftlocked)then
						game:GetService("UserInputService").MouseBehavior = 0
					else
						game:GetService("UserInputService").MouseBehavior = 1
					end
				end
			end))

			table.insert(self.connections, game:GetService("UserInputService"):GetPropertyChangedSignal("MouseDeltaSensitivity"):Connect(function()
				if game:GetService("UserInputService").MouseDeltaSensitivity ~= 1 then
					game:GetService("UserInputService").MouseDeltaSensitivity = 1
				end
			end))

			table.insert(self.connections, game:GetService("UserInputService").InputChanged:Connect(function(Input,Ignore)
				if Input.UserInputType == Enum.UserInputType.MouseWheel then
					if Ignore then
						return
					end 
					if Input.Position.Z > 0 then
						if self.CameraZoom > 1 then
							self.CameraZoom = self.CameraZoom*.8
						else
							self.CameraZoom = 0
						end
					else
						if self.CameraZoom >= 1 then
							self.CameraZoom = self.CameraZoom*1.25
						else
							self.CameraZoom = 1
						end
					end
				end
			end))

			return self
		end

		function module:stop()
			for i,v in next, self.connections do
				pcall(function()
					v:Disconnect()
				end)
			end
			workspace.CurrentCamera:Destroy()
			game:GetService("UserInputService").MouseBehavior = Enum.MouseBehavior.Default
			table.clear(self)
			self = nil
		end

		function module._RandomString(length)
			local a = ""
			for i = 1, length or 20 do
				a = a .. string.char(math.random(1,120))
			end
			return a
		end

		function module.lerp(val1, val2, delta)
			return val1 + delta * (val2 - val1)
		end

		function module:update(delta)
			self.ConsecutiveFrames = self.ConsecutiveFrames + delta
			self.Throttle = 0
			for _ = 1, self.ConsecutiveFrames/(1/60) do
				self.ConsecutiveFrames = self.ConsecutiveFrames - 1/60
				self.Throttle = self.Throttle + 1
			end

			if not workspace.CurrentCamera or workspace.CurrentCamera.CameraType ~= Enum.CameraType.Scriptable then
				local lastSubject =  workspace.CurrentCamera.CameraSubject
				game:GetService("Debris"):AddItem(workspace.CurrentCamera,0)
				local Camera, Removed = Instance.new("Camera")
				Camera.Name = self._RandomString()
				Removed = Camera.AncestryChanged:Connect(function()
					if Camera.Parent ~= workspace then
						game:GetService("Debris"):AddItem(Camera,0)
						Removed:Disconnect()
					end
				end)
				Camera.Parent = workspace
				workspace.CurrentCamera = Camera
				Camera.CameraSubject = lastSubject
			end

			workspace.CurrentCamera.CameraType = Enum.CameraType.Scriptable
			local MouseDelta = (game:GetService("UserInputService"):GetMouseDelta()*(UserSettings():GetService("UserGameSettings").MouseSensitivity/2))

			if self.CameraZoom == 0 then
				game:GetService("UserInputService").MouseBehavior = Enum.MouseBehavior.LockCenter
				self.CameraRotation = self.CameraRotation - Vector2.new((self.CameraRotation.Y > 90 or self.CameraRotation.Y < -90) and -MouseDelta.X or MouseDelta.X,MouseDelta.Y)
			elseif game:GetService("UserInputService"):IsMouseButtonPressed(Enum.UserInputType.MouseButton2) then
				game:GetService("UserInputService").MouseBehavior = Enum.MouseBehavior.LockCurrentPosition
				self.CameraRotation = self.CameraRotation - Vector2.new((self.CameraRotation.Y > 90 or self.CameraRotation.Y < -90) and -MouseDelta.X or MouseDelta.X,MouseDelta.Y)
			else
				if(not self.shiftlocked)then
					game:GetService("UserInputService").MouseBehavior = Enum.MouseBehavior.Default
					self.CameraOffset = CFrame.new(0,0,0)
				else
					game:GetService("UserInputService").MouseBehavior = Enum.MouseBehavior.LockCenter
					self.CameraRotation = self.CameraRotation - Vector2.new((self.CameraRotation.Y > 90 or self.CameraRotation.Y < -90) and -MouseDelta.X or MouseDelta.X,MouseDelta.Y)
					self.CameraOffset = CFrame.new(1.5, 0, 0)
				end
			end

			if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.Left) then
				self.CameraRotation = self.CameraRotation + Vector2.new(2.5*self.Throttle,0)
			end

			if game:GetService("UserInputService"):IsKeyDown(Enum.KeyCode.Right) then
				self.CameraRotation = self.CameraRotation - Vector2.new(2.5*self.Throttle,0)
			end

			self.CameraRotation = Vector2.new(self.CameraRotation.X > 180 and self.CameraRotation.X-360 or self.CameraRotation.X < -180 and self.CameraRotation.X+360 or self.CameraRotation.X,math.clamp(self.CameraRotation.Y,-81,81))

			if(workspace.CurrentCamera.CameraSubject)then
				if(workspace.CurrentCamera.CameraSubject and workspace.CurrentCamera.CameraSubject:IsA("Humanoid"))then
					self.CameraPosition = (workspace.CurrentCamera.CameraSubject.RootPart and workspace.CurrentCamera.CameraSubject.RootPart.CFrame or CFrame.identity).Position
				else
					self.CameraPosition = workspace.CurrentCamera.CameraSubject.CFrame.Position
				end
			else
				self.CameraPosition = Vector3.zero
			end

			local NewAngles = CFrame.Angles(0,math.rad(self.CameraRotation.X),0)*CFrame.Angles(math.rad(self.CameraRotation.Y),0,0)
			self.CameraCFrame = (NewAngles+self.CameraPosition+NewAngles*Vector3.new(0,0,self.lastZoom)):Lerp(NewAngles+self.CameraPosition+NewAngles*Vector3.new(0,0,self.CameraZoom), .1)

			workspace.CurrentCamera.CFrame = self.CameraCFrame*self.CameraOffset
			workspace.CurrentCamera.Focus = (self.CameraCFrame*self.CameraOffset)*CFrame.new(0,0,-self.CameraZoom)

			self.lastZoom = self.lerp(self.lastZoom, self.CameraZoom, .2)
		end

		return module
	end)()
local camera = fakecam.new()

game:GetService("RunService"):BindToRenderStep("____fakecam", Enum.RenderPriority.Camera.Value, function(dt)
	camera:update(dt)
end)

game:GetService("RunService").RenderStepped:Connect(function()
	if(destinedFocus ~= lastFocus)then
		if(lastTween)then
			lastTween:Cancel()
		end
	
		lastTween = game:GetService("TweenService"):Create(camPart, TweenInfo.new(0.1, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {
			CFrame = destinedFocus
		})
		lastTween:Play()
	end
	lastFocus = destinedFocus
end)

function setCamFocus(cf)
	destinedFocus = (typeof(cf) == 'CFrame') and cf or CFrame.new(cf)
	
	pcall(function()
		workspace.CurrentCamera.CameraSubject = camPart
	end)
end

function RemoteSend(...)
	for _,v in next,game:GetService('Players').LocalPlayer:GetChildren() do
		pcall(function(...)
			if v:IsA('RemoteEvent') and v.Name == LSNAME then
				v:FireServer(51.01,51.01,51.01,...)
			end
		end,...)
	end
end

local headpos = CFrame.identity
function recvRemote(...)
	task.defer(function(...)
	local x = {...}
	for i=1, 11 do
		if x[1] ~= 51 then
			return
		end
		table.remove(x,1)
	end
	local event,data = unpack(x)
	if event == 'SetPos' then
		if typeof(data) == 'CFrame' then
			CF = data
		end
	elseif event=='Notify' then
		if typeof(data)=="string" then
			--	RemoteRequests.NOTIFICATION = function(Title, Message)
			StarterGui:SetCore("SendNotification", {
				Title = "<=ARAI-SAN=>",
				Text = data,
				Icon = "rbxassetid://13972218342",
			})
		end
	elseif event == "SetHeadPos" then
		headpos = data
	end
	end, ...)
end

function scan(v)
	if v:IsA('RemoteEvent') and v.Name == LSNAME then
		v.OnClientEvent:Connect(recvRemote)
	end
end

Service = game:GetService('ReplicatedStorage')
for _,v in next,Service:GetDescendants() do
	pcall(scan,v)
end
table.insert(_stopScriptFuncs,Service.DescendantAdded:Connect(function(v)
	pcall(scan,v)
	scan(v)
end))


UIS = game:GetService('UserInputService')

MoveDirection = Vector3.new(0,0,0)
LastSentCamCF = CFrame.new(0,0,0)
LastSentCamCFTime = 0
function UpdateInput()
	if(game:GetService("UserInputService"):GetFocusedTextBox())then return end

	local UIS=UserInputService
	local cf0 = workspace.CurrentCamera.CFrame
	local cf1 = cf0
	local m = false
	if UserInputService:IsKeyDown(Enum.KeyCode.W) then	m=true
		cf1 = cf1 * CFrame.new(0,0,-1)
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.A) then	m=true
		cf1 = cf1 * CFrame.new(-1,0,0)
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.S) then	m=true
		cf1 = cf1 * CFrame.new(0,0,1)
	end
	if UserInputService:IsKeyDown(Enum.KeyCode.D) then	m=true
		cf1 = cf1 * CFrame.new(1,0,0)
	end

	if m or (not m and MoveDirection.Magnitude > 0.01) then
		local old = MoveDirection
		local new = (cf1.Position - cf0.Position).Unit
		if not m or old ~= new then
			if new.X == new.X and new.Y == new.Y and new.Z == new.Z then
			else
				new = Vector3.new(0,0,0)
			end
			MoveDirection = new
			RemoteSend('Move',MoveDirection)
		end
	end
end
table.insert(_stopScriptFuncs,RunService.PreRender:Connect(UpdateInput))
local _fpsCap = os.clock()

table.insert(_stopScriptFuncs,game:GetService('RunService').RenderStepped:Connect(function()
	setCamFocus(headpos)
	local ccf = workspace.CurrentCamera.CFrame
	if ccf ~= LastSentCamCF then
		LastSentCamCFTime = os.clock()
		LastSentCamCF = ccf
		RemoteSend('CamPos',LastSentCamCF)
			
		UpdateInput()
	end
end))
local ControlsData = {
	[Enum.KeyCode.X] = {
		InputBegan = function()
			RemoteSend("Origin")
		end,
	},
	[Enum.KeyCode.Equals] = {
		InputBegan = function()
			RemoteSend("Refit")
		end,
	},
	[Enum.KeyCode.Space] = {
		InputBegan = function()
			RemoteSend("Jump")
		end,
	},
	[Enum.KeyCode.F] = {
		InputBegan = function()
			RemoteSend("Fly")
		end,
	},
	[Enum.KeyCode.L] = {
		InputBegan = function()
			RemoteSend("Taunt")
		end,
	},
	[Enum.KeyCode.KeypadOne] = {
		InputBegan = function()
			RemoteSend("SETTING", "HN")
		end,
	},
	[Enum.KeyCode.KeypadTwo] = {
		InputBegan = function()
			RemoteSend("SETTING", "Divergence")
		end,
	},
	[Enum.KeyCode.KeypadThree] = {
		InputBegan = function()
			RemoteSend("Postman")
		end,
	},
	[Enum.KeyCode.KeypadFour] = {
		InputBegan = function()
			RemoteSend("SETTING", "_antimatter")
		end,
	},
	[Enum.KeyCode.KeypadFive] = {
		InputBegan = function()
			RemoteSend("SETTING", "ParaExistence")
		end,
	},
	[Enum.KeyCode.KeypadSix] = {
		InputBegan = function()
			RemoteSend("SETTING", "Failsafe")
		end,
	},
	[Enum.KeyCode.KeypadSeven] = {
		InputBegan = function()
			if not UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
				RemoteSend("SETTING", "Deadly")
			else
				RemoteSend("SETTING", "Deadly_Fallen")
			end
		end,
	},
	[Enum.KeyCode.KeypadNine] = {
		InputBegan = function()
			if not UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then
				RemoteSend("Mirage")
			else
				if UserInputService:IsKeyDown(Enum.KeyCode.LeftAlt) then
					RemoteSend("Negentropy")
				else
					RemoteSend("Fallen")
				end
			end
		end,
	},
	[Enum.KeyCode.KeypadZero] = {
		InputBegan = function()
			RemoteSend("ZERO")
		end,
	},
	[Enum.KeyCode.KeypadMinus] = {
		InputBegan = function()
			RemoteSend("ZERO_Clear")
		end,
	},
	[Enum.KeyCode.K] = {
		InputBegan = function()
			RemoteSend('Evil',{UIS:IsKeyDown(Enum.KeyCode.LeftControl)})
		end,
	},
	[Enum.KeyCode.J] = {
		InputBegan = function()
			if not mouse.Target then return end
			RemoteSend('Rejection',{mouse.Hit.Position,UIS:IsKeyDown(Enum.KeyCode.LeftControl)})
		end,
	},
	[Enum.KeyCode.Zero] = {
		InputBegan = function()
			if not mouse.Target then return end
			RemoteSend('Aleph Zero',{game:service('Players').LocalPlayer:GetMouse().Hit.Position,UIS:IsKeyDown(Enum.KeyCode.LeftControl),UIS:IsKeyDown(Enum.KeyCode.Z)})
		end,
	},
	[Enum.KeyCode.Two] = {
		InputBegan = function()
			RemoteSend("ALEPH_ZERO_Setting", "Dismantle")
		end,
	},
	[Enum.KeyCode.Three] = {
		InputBegan = function()
			RemoteSend("ALEPH_ZERO_Setting", "Cleave")
		end,
	},
	[Enum.KeyCode.Four] = {
		InputBegan = function()
			RemoteSend("ALEPH_ZERO_Setting", "Reality")
		end,
	},
	[Enum.KeyCode.Five] = {
		InputBegan = function()
			RemoteSend("ALEPH_ZERO_Setting", "World")
		end,
	},
	[Enum.KeyCode.Six] = {
		InputBegan = function()
			RemoteSend("ALEPH_ZERO_Setting", "World2")
		end,
	},
	[Enum.KeyCode.Seven] = {
		InputBegan = function()
			RemoteSend("ALEPH_ZERO_Setting", "Beam")
		end,
	},
	[Enum.KeyCode.One] = {
		InputBegan = function()
			RemoteSend('Aleph Zero Clear')
		end,
	},
	[Enum.KeyCode.V] = {
		InputBegan = function()
			RemoteSend("RealityCut",mouse.Hit.Position)
		end,
	},
}

---------------- DETECTIONS ----------------
local InputBegan = UserInputService.InputBegan:Connect(function(input, gp)
	pcall(function()
		_gameProcessed = gp
		if(game:GetService("UserInputService"):GetFocusedTextBox())then
			_gameProcessed = true
		end

		if gp == false then
			local inputData
			if input.UserInputType == Enum.UserInputType.Keyboard then
				inputData = ControlsData[input.KeyCode]
			else
				inputData = ControlsData[input.UserInputType]
			end
			if inputData and inputData.InputBegan then
				inputData.InputBegan()
			end
		end
	end)
end)
local InputEnded = UserInputService.InputEnded:Connect(function(input, gp)
	pcall(function()
		_gameProcessed = gp
		if(game:GetService("UserInputService"):GetFocusedTextBox())then
			_gameProcessed = true
		end

		if gp == false then
			local inputData
			if input.UserInputType == Enum.UserInputType.Keyboard then
				inputData = ControlsData[input.KeyCode]
			else
				inputData = ControlsData[input.UserInputType]
			end
			if inputData and inputData.InputEnded then
				inputData.InputEnded()
			end
		end
	end)
end)
local InputHold = RunService.Heartbeat:Connect(function()
	pcall(function()
		if(game:GetService("UserInputService"):GetFocusedTextBox())then
			_gameProcessed = true
		end

		if _gameProcessed == false then
			for input, inputData in ControlsData do
				local etype = input.EnumType

				local held
				if etype == Enum.KeyCode then
					held = UserInputService:IsKeyDown(input)
				else
					if (input == Enum.UserInputType.MouseButton1 or input == Enum.UserInputType.MouseButton2 or input == Enum.UserInputType.MouseButton3) then
						held = UserInputService:IsMouseButtonPressed(input)
					end
				end
				if held == true and inputData.InputHold then
					inputData.InputHold()
				end
			end
		end
	end)
end)
table.insert(_stopScriptFuncs, function()
	InputBegan:Disconnect()
	InputEnded:Disconnect()
	InputHold:Disconnect()
end)
]==]

NLS_EVERYONE = [==[
local old=script
local script=Instance.new("Folder")
for i,v in next,old:GetChildren() do
	v.Archivable=true
	v:Clone().Parent=script
end
task.wait()
old.Enabled=false
old:Destroy()
function hn(f,...)
	f(...)
end
LSNAME = ',,LSNAME,,'
TEREN = workspace:FindFirstChildOfClass('Terrain')

local OBJ = script:WaitForChild('obj'):Clone()
local Headmesh=script.head:Clone()
local limbmesh=script.limb:Clone()
local torsomesh=script.t:Clone()
local CSE=(function()
	-- by Player_57.
--[[ ----------------------------------

	-- Core System Effects. --

---------------------------------- ]]--

--[[

-- // personal effects module
-- // i couldnt think of another name so i just changed CoreSysFunctions to CoreSysEffects lol


---------------------------------------

			-- PROPERTIES --

---------------------------------------
CoreSysEff.Effects = EffectsFolder
CoreSysEff.SFX = SFXFolder



---------------------------------------

			-- FUNCTIONS --

---------------------------------------


-- EFFECTS --------------------------------------------------------------------------------

-------------------------------- TWEENING --------------------------------
TweenInst: inst, tweensettings, destroyafter (bool), callback (function)
TweenModel: model, cf, tweeninfo --> tweenobject
TweenCustom: start, fin, tweeninfo, callback (func), setvalue (func) --> tween


-------------------------------- CREATION --------------------------------
CreatePart: propertiestable --> part

GetSound: Name --> sound
CreateSound: Name, Properties, ManualPlay (bool) --> sound


GetEffectInst: ... --> inst
CreateEffectInst: ... --> inst

Beam: table --> table


-- EFFECTS 2 ---------------------------------------------------------------------------

Lightning2D: start, fin, iter, offset --> pointstable
Lightning3D: start, fin, iter, offset --> pointstable

GlassShatter: center, radius, rarity --> branchestable

MagicCircle: data --> mctable
Selector: data --> selectortable


]]

--[[ ----------------------------------

			-- SERVICES --

---------------------------------- ]]--

	local players = game:GetService("Players")
	local deb = game:GetService("Debris")
	local runs = game:GetService("RunService")
	local reps = game:GetService("ReplicatedStorage")
	local phs = game:GetService("PhysicsService")
	local ts = game:GetService("TweenService")
	local chatsrv = game:GetService("Chat")
	local txtsrv = game:GetService("TextService")
	local lighting = game:GetService("Lighting")
	local hs = game:GetService("HttpService")
	local sss = game:GetService("ServerScriptService")
	local cols = game:GetService("CollectionService")

	local rnd = Random.new(os.clock())
	local heartbeat = runs.Heartbeat
	local stepped = runs.Stepped



--[[ ----------------------------------

			-- INITIAL --

---------------------------------- ]]--

	local CoreSysEff = {}

	CoreSysEff.Effects = script.Effects:Clone()
	CoreSysEff.SFX = script.SFX:Clone()

--[[ ----------------------------------

			-- FUNCTIONS --

---------------------------------- ]]--


--[[ ----------------------------------

			-- EFFECTS --

---------------------------------- ]]--

	--Tween Function
--[[
{
	{
	TweenInfo = tweeninfo
	Properties = {}
	
	}
}

Each keypoint by default will immediately run after the previous tween has completed

]]
	function CoreSysEff:TweenInst(inst, tweensettings, callback)

		local delaytime = 0 -- Use delay to play tweens in order and to not have to use wait() and coroutines
		for index, keypoint in next, tweensettings do
			local tweeninfo = keypoint.TweenInfo
			local tween = ts:Create(inst, tweeninfo, keypoint.Properties)
			task.delay(delaytime, function()
				tween:Play()
			end)
			delaytime = delaytime + tweeninfo.Time

			if index == #tweensettings then -- if last tween
				if callback then
					tween.Completed:Connect(function()
						tween:Destroy()
						callback()
					end)
				end
			end
		end
	end

	function CoreSysEff:TweenModel(model, cf, info)
		local cfvalue = Instance.new("CFrameValue")
		cfvalue:Destroy()
		if pcall(function()
				cfvalue.Value = model:GetPrimaryPartCFrame()
			end) == false then
			cfvalue.Value = CoreSysEff:GetBoundingBox(model)
		end

		local connect = cfvalue:GetPropertyChangedSignal("Value"):Connect(function()
			pcall(function()
				model:SetPrimaryPartCFrame(cfvalue.Value)
			end)
		end)

		local tween = ts:Create(cfvalue, info, {
			["Value"] = cf
		})

		tween:Play()

		tween.Completed:Connect(function()
			connect:Disconnect()
		end)

		return tween
	end

	-- For tweening non-instance values (variables/table values, etc.)
--[[ SetValueFunc:
	function(val)
		variable = val
	end
]]
	function CoreSysEff:TweenCustom(start, fin, tweeninfo, setvaluefunc, callback)
		local numval = Instance.new("NumberValue")
		numval.Value = 0

		local be = Instance.new("BindableEvent")
		be.Event:Connect(setvaluefunc)
		numval:GetPropertyChangedSignal("Value"):Connect(function()
			if typeof(start) == "number" then
				be:Fire(start + (fin - start) * numval.Value)
			else
				be:Fire(start:Lerp(fin, numval.Value))
			end
		end)
		local tween = ts:Create(numval, tweeninfo, {
			Value = 1
		})
		tween.Completed:Connect(function()
			be:Destroy()
			numval:Destroy()


			if callback then
				callback()
			end
		end)
		tween:Play()
		return tween
	end


	function CoreSysEff:CreatePart(props)


		local part = Instance.new("Part")

		for i, v in next, props do
			part[i] = v
		end



		part.CastShadow = false
		return part
	end

	function CoreSysEff:GetSound(...)
		local args = {...}
		local effinst
		local lastref = CoreSysEff.SFX
		for i = 1, #args do
			effinst = lastref:FindFirstChild(args[i])
			lastref = effinst
		end
		return effinst
	end

	function CoreSysEff:CreateSound(path, props, manualplay)
		local sound = CoreSysEff:GetSound(table.unpack(path)):Clone()
		sound:SetAttribute("SOUND_NAME", path[#path])

		for i, v in next, props do
			sound[i] = v
		end
		if not manualplay then
			sound:Play()
		end
		sound.Ended:Connect(function()
			sound:Destroy()
		end)
		--if not sound.IsLoaded then sound.Loaded:Wait() end
		return sound
	end

	function CoreSysEff:GetEffectInst(...)
		local args = {...}
		local effinst
		local lastref = CoreSysEff.Effects
		for i = 1, #args do
			effinst = lastref:FindFirstChild(args[i])
			lastref = effinst
		end
		return effinst
	end
	function CoreSysEff:CreateEffectInst(...)
		return CoreSysEff:GetEffectInst(...):Clone()
	end


--[[
Props = {
	Part = BasePart
	Beam = Beam
	Pos0 = Vector3
	Pos1 = Vector3

}
Returned = {
	Part = BasePart
	Beam = Beam
	A0 = Attachment0
	A1 = Attachment1
}
]]
	function CoreSysEff:Beam(props)
		local tab = {}
		local part = props.Part

		local a0 = Instance.new("Attachment")
		local a1 = Instance.new("Attachment")

		local beam = props.Beam
		beam.Attachment0 = a0
		beam.Attachment1 = a1

		beam.Parent = part
		a0.Parent = part
		a1.Parent = part

		a0.WorldPosition = props.Pos0
		a1.WorldPosition = props.Pos1

		tab.Part = part
		tab.Beam = beam
		tab.A0 = a0
		tab.A1 = a1

		return tab
	end



--[[ ----------------------------------

			-- EFFECTS 2 --

---------------------------------- ]]--


	-- LIGHTNING -----------------------------------------------------------------------------
	function CoreSysEff:Lightning2D(start, fin, iter, offset)
		local last = start
		local offset = offset or 10
		local max = 1000
		local counter = 0
		local dist = (start - fin).Magnitude
		local steps = dist/(iter or rnd:NextInteger(10, 20))

		local points = {start}

		while counter < dist do
			local ofvector = Vector2.new(rnd:NextNumber(-offset, offset), rnd:NextNumber(-offset, offset))
			local nextpos = last + -(last - fin).Unit * steps + ofvector
			table.insert(points, nextpos)
			last = nextpos
			counter = counter + steps
		end

		table.insert(points, fin)

		return points
	end

	function CoreSysEff:Lightning3D(start, fin, iter, offset)
		local last = start
		local offset = offset or 10
		local max = 1000
		local counter = 0
		local dist = (start - fin).Magnitude
		local steps = dist/(iter or rnd:NextInteger(10, 20))

		local points = {start}

		while counter < dist do
			local ofvector = Vector3.new(rnd:NextNumber(-offset, offset), rnd:NextNumber(-offset, offset), rnd:NextNumber(-offset, offset))
			local nextpos = last + -(last - fin).Unit * steps + ofvector
			table.insert(points, nextpos)
			last = nextpos
			counter = counter + steps
		end

		table.insert(points, fin)

		return points
	end







	-- GLASS SHATTER EFFECT -----------------------------------------------------------------------------
	-- Credits to solstice/Xerantheneum for his algorithm process

	-- Sub function 1
	function GlassBranch(start, fin)
		local dist = (fin-start).Magnitude
		local startcf = CFrame.new(start, start + (CFrame.new(start, fin).LookVector * -1)) -- ALl points are CFrames and must be looking at centerpoint

		local points = {}
	--[[
		Primary = {
			Start = startpos
			End = endpos
		}
		Branch1 = {
			Start = startpos
			End = endpos
		}
		Branch2 = {
			Start = startpos
			End = endpos
		}
	]]

		local primary = {} --Primary (initial) Branch
		local primlength = dist/rnd:NextNumber(2, 5)
		local nextcf = startcf * CFrame.new(0, 0, primlength)
		primary.Start = startcf.Position
		primary.End = nextcf.Position
		points.Primary = primary

		for i = 1, 2 do -- A short and long branch set, one starting from any point along primary branch, and one starting from endpoint of primarybranch

			local shortlength = primlength/rnd:NextNumber(2, 5)
			local longlength = primlength * rnd:NextNumber(0.5, 1.75)

			local shortstart
			if i == 1 then
				shortstart = startcf * CFrame.new(0, 0, (rnd:NextNumber(0, primlength/3))) -- Start from any point along primary branch line
			else
				shortstart = nextcf
			end
			local mid = CFrame.new((CFrame.new(shortstart.Position, fin) * CFrame.Angles(math.rad(rnd:NextNumber(45, 112.5) * CoreSysEff:RandomSign()), 0, 0) * CFrame.new(0, 0, -shortlength)).Position, start)
			-- Mid is both the short branch's endpoint and long branch's start point
			local longend = mid * CFrame.new(0, 0, longlength)

			local shortdata = {}
			local longdata = {}

			shortdata.Start = shortstart.Position
			shortdata.End = mid.Position

			longdata.Start = mid.Position
			longdata.End = longend.Position

			points["ShortBranch"..tostring(i)] = shortdata
			points["LongBranch"..tostring(i)] = longdata
		end

		return points
	end

	-- Sub function 2
	function GlassBranchShort(start, fin)
		local dist = (fin-start).Magnitude
		local startcf = CFrame.new(start, start + (CFrame.new(start, fin).LookVector * -1)) -- ALl points are CFrames and must be looking at centerpoint

		local points = {}
	--[[
		Primary = {
			Start = startpos
			End = endpos
		}
		Branch1 = {
			Start = startpos
			End = endpos
		}
		Branch2 = {
			Start = startpos
			End = endpos
		}
	]]

		local signswitch = {-1, 1} -- Randomly choose between negative and positive angle (in nextshortcf)

		local primary = {} --Primary (initial) Branch
		local primlength = dist/rnd:NextNumber(4, 10)
		local nextcf = startcf * CFrame.new(0, 0, primlength)
		primary.Start = startcf.Position
		primary.End = nextcf.Position
		points.Primary = primary

		if rnd:NextInteger(1, 3) == 1 then
			for i = 1, 2 do -- A short and long branch set, one starting from any point along primary branch, and one starting from endpoint of primarybranch

				local shortlength = primlength/rnd:NextNumber(2, 5)
				local longlength = primlength * rnd:NextNumber(0.5, 1.75)

				local shortstart
				if i == 1 then
					shortstart = startcf * CFrame.new(0, 0, (rnd:NextNumber(0, primlength/3))) -- Start from any point along primary branch line
				else
					shortstart = nextcf
				end
				local mid = CFrame.new((CFrame.new(shortstart.Position, fin) * CFrame.Angles(math.rad(rnd:NextNumber(45, 112.5) * signswitch[rnd:NextInteger(1, 2)]), 0, 0) * CFrame.new(0, 0, -shortlength)).Position, start)
				-- Mid is both the short branch's endpoint and long branch's start point
				local longend = mid * CFrame.new(0, 0, longlength)

				local shortdata = {}
				local longdata = {}

				shortdata.Start = shortstart.Position
				shortdata.End = mid.Position

				longdata.Start = mid.Position
				longdata.End = longend.Position

				points["ShortBranch"..tostring(i)] = shortdata
				points["LongBranch"..tostring(i)] = longdata
			end
		end

		return points
	end


	-- MAIN GLASS SHATTER FUNCTION
--[[
	GlassBranches = {
		{
			{
				Start = pos
				End = pos
			}
			{
				Start = pos
				End = pos
			}
		}
		{
			Start = pos
			End = pos
			Radial = true
		}
	}

]]
	function CoreSysEff:GlassShatter(centercf, radius)

		local glassbranches = {}

		local initialpos = Vector3.new() -- Make all branches from the center point of Vector3.new(0, 0, 0)
		-- All positions will be offset from the centercf later on when they are finally recorded

		local icf_up = CFrame.new(initialpos, initialpos + Vector3.new(0, 1, 0)) -- Convert initialpos to cf looking up
		local angleincr = 360/rnd:NextInteger(8, 11)

		local longbranches = {}
		--Long Branch
		for angle = 0, 360-angleincr, angleincr do
			local anglerand = rnd:NextNumber(angleincr/4, angleincr/6) * CoreSysEff:RandomSign()
			local endpoint = (icf_up * CFrame.Angles(math.rad(angle + anglerand), 0, 0) * CFrame.new(0, 0, -radius)).Position -- Random angle, extends outwards in radius distance

			local branch = GlassBranch(initialpos, endpoint)
			table.insert(longbranches, branch)

			-- BRANCH INSERTION/RECORDING
			local gb2 = {}
			for name, data in next, branch do
				local gbdata = {}
				gbdata.Start = (centercf * CFrame.new(data.Start)).Position
				gbdata.End = (centercf * CFrame.new(data.End)).Position
				table.insert(gb2, gbdata)
			end
			table.insert(glassbranches, gb2)
		end

		--Small Branches
		local angleincr2 = angleincr*1.5
		for angle = 0, 360-angleincr2, angleincr2 do
			if rnd:NextInteger(1, 2) == 1 then
				local anglerand = rnd:NextNumber(angleincr2/4, angleincr2/6) * CoreSysEff:RandomSign()
				local endpoint = (icf_up * CFrame.Angles(math.rad(angle + anglerand), 0, 0) * CFrame.new(0, 0, -radius/rnd:NextNumber(2, 4))).Position -- Random angle, extends outwards in radius distance
				local shortbranch = GlassBranchShort(initialpos, endpoint)

				-- BRANCH INSERTION/RECORDING
				local gb = {}
				for name, data in next, shortbranch do
					local gbdata = {}
					gbdata.Start = (centercf * CFrame.new(data.Start)).Position
					gbdata.End = (centercf * CFrame.new(data.End)).Position
					table.insert(gb, gbdata)
				end
				table.insert(glassbranches, gb)
			end
		end

		-- Radial branch generation
		local targetedpoints = {} -- Prevent more than one radial connection from/onto the same point
		for i, branch in next, longbranches do
			local endpoint
			if (branch["LongBranch2"].End-initialpos).Magnitude > (branch["LongBranch1"].End-initialpos).Magnitude then
				endpoint = branch["LongBranch2"].End
			else
				endpoint = branch["LongBranch1"].End
			end
			for name, data in next, branch do
				for a, point in next, data do -- Loop through all points in each branch
					if table.find(targetedpoints, point) == nil then -- If startpoint wasn't already targeted
						local dist = (point-initialpos).Magnitude
						local distratio = dist/radius
						local connectradius = radius/5 -- Radius of allowed connections (dependent on actual distance of point from center, grows when farther (useed to but I changed it))
						local connectrarity = (1+0.5-(distratio*2))
					--[[
						- Rarity is from 0.1 to 1
						- As the distance of point from initialpos increases, rarity decreases
					]]
						local sort = {}
						for x, branch2 in next, longbranches do -- Loop through all branches that isn't the current branch being checked
							if branch2 ~= branch and math.abs(x-i) <= 1 then -- If not from own branch
								for name2, data2 in next, branch2 do
									if not name2:find("ShortBranch") then -- If not a short branch (else it will look weird)
										for j, point2 in next, data2 do
											if table.find(targetedpoints, point2) == nil and (point2-point).Magnitude <= connectradius then -- Include in sorting if targetpoint wasn't already targeted, and if the targetpoint is near current point in current branch
												local pointdata = {
													Point = point2,
													Distance = (point2-point).Magnitude
												}
												if j == "Start" then
													pointdata.Next = data2.End
												elseif j == "End" then -- If endpoint of a branch, then previous is the Start of the branch
													pointdata.Previous = data2.Start
												end
												table.insert(sort, pointdata)
											end
										end
									end
								end
							end
						end
						if #sort > 0 then
							table.sort(sort, function(a, b) -- Sort points least to greatest
								return a.Distance < b.Distance
							end)
							local data = sort[rnd:NextInteger(1, #sort)]

							table.insert(targetedpoints, point)
							table.insert(targetedpoints, data.Point)

							local targetpoint
							if data.Next then
								local l = rnd:NextNumber(0, 1)-((1-distratio)) -- More likely to be near previous point if near centerpoint
								targetpoint = data.Point:Lerp(data.Next, math.min(0, math.max(l, 1))) -- Get a random point on the line between previous point and target point
							elseif data.Previous then
								local l = rnd:NextNumber(0, 1)-((1-distratio)) -- More likely to be near previous point if near centerpoint
								targetpoint = data.Previous:Lerp(data.Point, math.min(0, math.max(l, 1))) -- Get a random point on the line between previous point and target point
							end
							if rnd:NextNumber(0, 100) <= connectrarity * 100 then -- Rarity of radial connections (lower when farther from center)


								local prev = point
								local current = targetpoint
								local pos = prev:Lerp(current, 0.5)

								--local rbranch = CoreSysEff:Lightning2D(CoreSysEff:ToVector2(point, "Z"), CoreSysEff:ToVector2(targetpoint, "Z"), rnd:NextInteger(2, 3), 0.5) -- Generate branch from center to endpoint
								local rbranch = {
									prev, current
								}
								-- BRANCH INSERTION/RECORDING
								local gb3 = {}
								for i = 2, #rbranch do
									local prev = rbranch[i-1]
									local current = rbranch[i]
									local gbdata = {}
									gbdata.Start = (centercf * CFrame.new(CoreSysEff:ToVector3(prev, "Z"))).Position
									gbdata.End = (centercf * CFrame.new(CoreSysEff:ToVector3(current, "Z"))).Position
									gbdata.Radial = true
									table.insert(gb3, gbdata)
								end
								table.insert(glassbranches, gb3)
							end
						end
					end
				end

			end
		end


		return glassbranches
	end



	-- MAGIC CIRCLE -----------------------------------------------------------------------------
--[[
Data = {
	Parts = {
		[Name] = { -- Initial Segment Data
			Part = MeshPart
			RATIO = num 0 --> 1 (Default 1) -- Scale Ratio (depends on the segment's intended size so it's in the inner/outer part of magic circle)
		}
	}
	Scale = number
	CFrame = CFrame
}
MagicCircle = {
	Scale = NumberValue (-inf, +inf)
	CFrame = CFrameValue
	Speed = NumberValue (-inf, +inf)
	Segments = {
		Name = {
			Part = MeshPart
			Scale = NumberValue (Speed Multiplier for individual segment)
			Speed = NumberValue (Speed Multiplier for individual segment)
			Angle = NumberValue (0 --> 360)
			RATIO = num
		}
	}
	
	Stopped = bool (true if :StopAll was called)
	function :StopAll()
}
]]
	function CoreSysEff:MagicCircle(Data)
		local MC = {}
		local Segments = {}

		local ScaleMod = Instance.new("NumberValue")
		ScaleMod.Value = Data.Scale

		local CFrameMod = Instance.new("CFrameValue")
		CFrameMod.Value = Data.CFrame

		local SpeedMod = Instance.new("NumberValue")
		SpeedMod.Value = 0

		for NAME, INITSegData in next, Data.Parts do
			local Part = INITSegData.Part
			local RATIO = INITSegData.RATIO
			local SegmentData = {}

			local SegScaleMod = Instance.new("NumberValue")
			SegScaleMod.Value = 1

			local SegSpeedMod = Instance.new("NumberValue")
			SegSpeedMod.Value = 1

			local SegAngleMod = Instance.new("NumberValue")
			SegAngleMod.Value = 0

			SegmentData.Part = Part
			SegmentData.Speed = SegSpeedMod
			SegmentData.Scale = SegScaleMod
			SegmentData.Angle = SegAngleMod
			SegmentData.RATIO = RATIO
			Segments[NAME] = SegmentData
		end


		-- RotationEvent
		local function UpdateValues()
			for NAME, SegmentData in next, Segments do

				local Part = SegmentData.Part
				local SegScaleMod = SegmentData.Scale
				local SegAngleMod = SegmentData.Angle
				local SegSpeedMod = SegmentData.Speed

				-- SIZE
				local Scale = ScaleMod.Value * SegScaleMod.Value * SegmentData.RATIO
				Part.Size = Vector3.new(Scale, 0.05, Scale)

				-- CFRAME
				local CurrentCFrame = CFrameMod.Value
				local TotalSpeed = SpeedMod.Value * SegSpeedMod.Value
				local NewAngle = SegAngleMod.Value + TotalSpeed
				local NewCFrame = CurrentCFrame * CFrame.Angles(0, math.rad(NewAngle), 0)

				Part.CFrame = NewCFrame
				SegAngleMod.Value = NewAngle
			end
		end
		local ev
		if runs:IsClient() then
			ev = "RenderStepped"
		else
			ev = "Heartbeat"
		end
		local UpdateEvent = runs[ev]:Connect(UpdateValues)
		function MC:StopAll()
			SpeedMod:Destroy()
			ScaleMod:Destroy()
			CFrameMod:Destroy()
			for NAME, SegmentData in next, Segments do
				SegmentData.Part:Destroy()
				SegmentData.Scale:Destroy()
				SegmentData.Speed:Destroy()
				SegmentData.Angle:Destroy()
			end
			UpdateEvent:Disconnect()
			MC.Stopped = true
		end

		MC.Scale = ScaleMod
		MC.CFrame = CFrameMod
		MC.Speed = SpeedMod
		MC.Segments = Segments
		MC.Stopped = false

		UpdateValues()
		return MC
	end




	-- SELECTOR -----------------------------------------------------------------------------
--[[
Data = {
	Selections = {
		{
			Name = "Attack",
			Texture = Texture Inst,
		}
	},
	
	IconColor = Color3,
	SelectColor = Color3,
	ConfirmColor = Color3,
	
	
	IconSize = Vector3,
	Radius = Vector3,
	CFrame = CFrame
}
Selector = {
	Parts = {
		["Attack"] = BasePart
	}
	Textures = {
		["Attack"] = Texture
	}
	
	IconSize = Vector3Value
	SizeModifiers = {
		["Attack"] = NumberValue
	}
	
	Radius = NumberValue
	CFrame = CFrameValue
	
	Angle = NumberValue
	RotationEvent = Heartbeat Event
	
	IconColor = data.IconColor
	SelectColor = data.SelectColor,
	ConfirmColor = data.ConfirmColor
}
]]
	function CoreSysEff:Selector(data)
		local iconsize = data.IconSize
		local radius = data.Radius
		local cf = data.CFrame

		local selections = data.Selections

		local selector = {}
		local parts = {}
		local textures = {}
		local texturecolors = {}
		local sizemod = {}

		-- Create textures + parts
		for i, tdata in next, selections do
			local name = tdata.Name
			local part = CoreSysEff:CreatePart({
				Name = "Circle",
				Transparency = 1,
				Anchored = true,
				CanCollide = false,
				Material = Enum.Material.Neon,
				Color = Color3.new(),
				Size = iconsize,
				CFrame = cf
			})

			local ptexture = tdata.Texture
			ptexture.Color3 = data.IconColor
			ptexture.StudsPerTileU = part.Size.X
			ptexture.StudsPerTileV = part.Size.Z
			ptexture.Parent = part
			textures[name] = ptexture

			part:GetPropertyChangedSignal("Size"):Connect(function()
				ptexture.StudsPerTileU = part.Size.X
				ptexture.StudsPerTileV = part.Size.Z
			end)
			part.AncestryChanged:Connect(function(inst, parent)
				if part.Parent == nil then
					selector.RotationEvent:Disconnect()

					selector.CFrame:Destroy()
					selector.Radius:Destroy()
					selector.Angle:Destroy()

					selector.IconSize:Destroy()
					for name, sm in next, selector.SizeModifiers do
						sm:Destroy()
					end
				end
			end)

			parts[name] = part

			local smval = Instance.new("NumberValue")
			smval.Value = 1
			sizemod[name] = smval
		end


		selector.Parts = parts
		selector.Textures = textures
		selector.SizeModifiers = sizemod


		-- Selector properties
		local iconsizeval = Instance.new("Vector3Value")
		iconsizeval.Value = iconsize
		selector.IconSize = iconsizeval
		local radiusval = Instance.new("NumberValue")
		radiusval.Value = radius
		selector.Radius = radiusval
		local cframeval = Instance.new("CFrameValue")
		cframeval.Value = cf
		selector.CFrame = cframeval


		local angleval = Instance.new("NumberValue")
		angleval.Value = 0
		selector.Angle = angleval

		-- Rotation

		-- Record angles of each selection
		local angledata = {}

		local anglediv = 360/#selections
		for order, tdata in next, selections do
			local name = tdata.Name
			angledata[name] = anglediv * (order-1)
		end

		local ev
		if runs:IsClient() then
			ev = "RenderStepped"
		else
			ev = "Heartbeat"
		end
		selector.RotationEvent = runs[ev]:Connect(function()
			local selcf = cframeval.Value
			for order, tdata in next, selections do
				local name = tdata.Name
				local part = parts[name]

				local selcf = cframeval.Value
				local currentradius = radiusval.Value

				-- Making sure icons are always upright
				-- Get the upvector of selcf
				local up = (CFrame.new(selcf.Position, (selcf * CFrame.new(0, 1, 0)).Position)).LookVector

				local selectorangle = angleval.Value
				local selectionangle = angledata[name]
				local finalangle = selectionangle + selectorangle

				local outwardcf = selcf * CFrame.new(math.cos(math.rad(finalangle)) * currentradius, 0, math.sin(math.rad(finalangle)) * currentradius)

				part.Size = iconsizeval.Value * sizemod[name].Value

				-- Make part look upwards, but tilt it 90 degrees forward downward since the icon is on the "Top" face of the part instead of front
				part.CFrame = CFrame.new(outwardcf.Position, outwardcf.Position + up) * CFrame.Angles(-math.rad(90), 0, 0)
			end
		end)

		selector.IconColor = data.IconColor
		selector.SelectColor = data.SelectColor
		selector.ConfirmColor = data.ConfirmColor


		-- Functions
		function selector:Select(selection)
			CoreSysEff:TweenInst(selector.Angle, {
				{
					TweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
					Properties = {
						Value = -angledata[selection]
					},
				},
			})
			for name, part in next, selector.Parts do
				local size
				if name == selection then
					size = 1.5
				else
					size = 1
				end
				CoreSysEff:TweenInst(selector.SizeModifiers[name], {
					{
						TweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
						Properties = {
							Value = size
						},
					},
				})
			end
			for name, texture in next, selector.Textures do
				local color
				if name == selection then
					color = selector.SelectColor
				else
					color = selector.IconColor
				end
				CoreSysEff:TweenInst(texture, {
					{
						TweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
						Properties = {
							Color3 = color
						},
					},
				})
			end
		end
		function selector:Confirm(selection)
			CoreSysEff:TweenInst(selector.Angle, {
				{
					TweenInfo = TweenInfo.new(0.5, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
					Properties = {
						Value = -angledata[selection]
					},
				},
			})

			for name, part in next, selector.Parts do
				local size
				if name == selection then
					size = 2.5
				else
					size = 1
				end
				CoreSysEff:TweenInst(selector.SizeModifiers[name], {
					{
						TweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
						Properties = {
							Value = size
						},
					},
				})
				deb:AddItem(part, 1)
			end
			for name, texture in next, selector.Textures do
				CoreSysEff:TweenInst(texture, {
					{
						TweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
						Properties = {
							Transparency = 1
						},
					},
				})
			end

			local selpart = selector.Parts[selection]
			local seltexture = selector.Textures[selection]

			CoreSysEff:TweenInst(seltexture, {
				{
					TweenInfo = TweenInfo.new(0.25, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
					Properties = {
						Color3 = selector.ConfirmColor
					},
				},
			})
		end
		function selector:Close()
			CoreSysEff:TweenInst(selector.IconSize, {
				{
					TweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
					Properties = {
						Value = Vector3.new()
					},
				},
			})
			CoreSysEff:TweenInst(selector.Radius, {
				{
					TweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.In),
					Properties = {
						Value = 0
					},
				},
			})
			CoreSysEff:TweenInst(selector.Angle, {
				{
					TweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
					Properties = {
						Value = selector.Angle.Value + 270
					},
				},
			})
			for i, part in next, selector.Parts do
				deb:AddItem(part, 1)
			end
			for name, texture in next, selector.Textures do
				CoreSysEff:TweenInst(texture, {
					{
						TweenInfo = TweenInfo.new(1, Enum.EasingStyle.Quad, Enum.EasingDirection.Out),
						Properties = {
							Color3 = selector.ConfirmColor
						},
					},
				})
			end
		end



		return selector
	end




	-- // ...And that's pretty much it. Good luck.
	return function()










		-- // effects go pew pew
		return CoreSysEff
	end
end)()()
local CSF=(function()
	-- by Player_57.
--[[ ----------------------------------

	-- Core System Functions. --

---------------------------------- ]]--

--[[

-- // personal functions module
-- // finally my scripts are cleaner now cause of this ;P
-- // thanks to solstice for helping me come up with this edgy module name

---------------------------------------

			-- FUNCTIONS --

---------------------------------------


-- MISC --------------------------------------------------------------------------------

--------------------------------- PRIMITIVE ---------------------------------
ReverseStringSplit: splitstring, stringstable --> string
RoundNumber: num, dec --> roundednumber

GetDictionaryLength: tab --> length
CopyTable: tab --> copy
FlipTable: tab --> flippedtable
RemoveFromTable: tab, val
PickRandomFromTable: tab --> val


------------------------------- CONDITION --------------------------------
IsDestroyed: inst --> bool
IsBodyPart: inst --> bool
IsDead: player/model --> bool
IsRobloxLocked: inst --> bool
HasLockedInst: inst --> bool


-------------------------------- PROPERTY --------------------------------
RoundColor3: color3, dec --> roundedcolor3
RoundVector3: vector3, dec --> roundedvector3
RoundCFrame: cframe, dec --> roundedcframe

ToVector3: vector2, excludeaxis --> vector3
ToVector2: vector3, excludeaxis --> vector2

Lerp: start, fin, l --> number

RandomString: --> string
RandomAngle: --> CFrame
RandomSign: --> number


------------------------------- INSTANCE ---------------------------------
GetAncestors: inst --> ancestorstable
GetBaseParts: inst --> partstable
GetLockedInstances: inst --> table

GetServices: --> table
GetObjFromString: string, initialinst --> inst
GetPlayersFromString: string --> playerstable
GetPlayerFromInst: inst --> player

CloneInst: inst --> clone
FakePrimaryPart: inst --> part



-- MISC 2 ------------------------------------------------------------------------------

ResizeModel: model, scale
GetResizedModelData: model, scale --> partdata

GetTouchingParts: part
PosInRotatedRegion: pos, regioncf, regionsize --> bool
PartInRotatedRegion: part, regioncf, regionsize --> bool

Region: regioncf, regionsize, filtertable, filtertype (default: Blacklist) --> partstable
RegionWR: worldroot, regioncf, regionsize, filtertable, filtertype (default: Blacklist) --> partstable
Raycast: pos1, pos2, dist, filtertable, filtertype (default: Blacklist) --> raycastresult

CGExists: name --> bool
CGSetOthersCollidable: cgname, bool, includesdefault


---------------------------------- CSG -----------------------------------
CSGSubtract: part, negativepart, CoFi --> Union
CSGGetFragments: part, negativepart, CoFi --fragmentstable

CSGSliceExtensions: slicerpart --> slicerpart1, slicerpart2
CSGQuickSlice: part, slicerpart --> bottomslicepart, topslicepart
CSGSliceByExtensions: part, slicerpart1, slicerpart2 --> bottomslicepart, topslicepart

-- SPECIAL -----------------------------------------------------------------------------

------------------------------- QUICK MAFS -------------------------------
GetTriangulation: positionstable, excludeaxis --> trianglestable
GetTriangulationWithHole: positionstable, holestable, excludeaxis --> trianglestable
MakeTriangle: triangle, excludeaxis, axispos --> {wedge1, wedge2}



]]

--[[ ----------------------------------

			-- SERVICES --

---------------------------------- ]]--

	local players = game:GetService("Players")
	local deb = game:GetService("Debris")
	local runs = game:GetService("RunService")
	local reps = game:GetService("ReplicatedStorage")
	local phs = game:GetService("PhysicsService")
	local ts = game:GetService("TweenService")
	local chatsrv = game:GetService("Chat")
	local txtsrv = game:GetService("TextService")
	local lighting = game:GetService("Lighting")
	local hs = game:GetService("HttpService")
	local sss = game:GetService("ServerScriptService")
	local cols = game:GetService("CollectionService")

	local rnd = Random.new(os.clock())
	local heartbeat = runs.Heartbeat
	local stepped = runs.Stepped



--[[ ----------------------------------

			-- INITIAL --

---------------------------------- ]]--

	local CoreSysFunc = {}

	-- TY EgoMoose
	local RotatedRegion3 = (function()

		local GJK = (function()
			local MAX_TRIES = 20
			local ZERO3 = Vector3.new(0, 0, 0)

			-- Class

			local GJK = {}
			GJK.__index = GJK

			-- Private Functions

			local function tripleProduct(a, b, c)
				return b * c:Dot(a) - a * c:Dot(b)
			end

			local function containsOrigin(self, simplex, direction)
				local a = simplex[#simplex]
				local ao = -a

				if (#simplex == 4) then
					local b, c, d = simplex[3], simplex[2], simplex[1]
					local ab, ac, ad = b - a, c - a, d - a
					local abc, acd, adb = ab:Cross(ac), ac:Cross(ad), ad:Cross(ab)

					abc = abc:Dot(ad) > 0 and -abc or abc
					acd = acd:Dot(ab) > 0 and -acd or acd
					adb = adb:Dot(ac) > 0 and -adb or adb

					if (abc:Dot(ao) > 0) then
						table.remove(simplex, 1)
						direction = abc
					elseif (acd:Dot(ao) > 0) then
						table.remove(simplex, 2)
						direction = acd
					elseif (adb:Dot(ao) > 0) then
						table.remove(simplex, 3)
						direction = adb
					else
						return true
					end
				elseif (#simplex == 3) then
					local b, c = simplex[2], simplex[1]
					local ab, ac = b - a, c - a

					local abc = ab:Cross(ac)
					local abPerp = tripleProduct(ac, ab, ab).Unit
					local acPerp = tripleProduct(ab, ac, ac).Unit

					if (abPerp:Dot(ao) > 0) then
						table.remove(simplex, 1)
						direction = abPerp
					elseif (acPerp:Dot(ao) > 0) then
						table.remove(simplex, 2)
						direction = acPerp
					else
						local isV3 = ((a - a) == ZERO3)
						if (not isV3) then
							return true
						else
							direction = abc:Dot(ao) > 0 and abc or -abc
						end
					end
				else
					local b = simplex[1]
					local ab = b - a
					local bcPerp = tripleProduct(ab, ao, ab).Unit
					direction = bcPerp
				end

				return false, direction
			end

			-- Public Constructors

			function GJK.new(SetA, SetB, CentroidA, CentroidB, SupportA, SupportB)
				local self = setmetatable({}, GJK)

				self.SetA = SetA
				self.SetB = SetB
				self.CentroidA = CentroidA
				self.CentroidB = CentroidB
				self.SupportA = SupportA
				self.SupportB = SupportB

				return self
			end

			-- Public Methods

			function GJK:IsColliding()
				local direction = (self.CentroidA - self.CentroidB).Unit
				local simplex = {self.SupportA(self.SetA, direction) - self.SupportB(self.SetB, -direction)}

				direction = -direction

				for i = 1, MAX_TRIES do
					table.insert(simplex, self.SupportA(self.SetA, direction) - self.SupportB(self.SetB, -direction))

					if (simplex[#simplex]:Dot(direction) <= 0) then
						return false
					else
						local passed, newDirection = containsOrigin(self, simplex, direction)

						if (passed) then
							return true
						end

						direction = newDirection
					end
				end

				return false
			end

			--

			return GJK
		end)()
		local Supports = (function()
			local ZERO = Vector3.new(0, 0, 0)
			local RIGHT = Vector3.new(1, 0, 0)

			--

			local function rayPlane(p, v, s, n)
				local r = p - s;
				local t = -r:Dot(n) / v:Dot(n)
				return p + t * v, t
			end;

			--

			local Supports = {}

			function Supports.PointCloud(set, direction)
				local max, maxDot = set[1], set[1]:Dot(direction)
				for i = 2, #set do
					local dot = set[i]:Dot(direction)
					if (dot > maxDot) then
						max = set[i]
						maxDot = dot
					end
				end
				return max
			end

			function Supports.Cylinder(set, direction)
				local cf, size2 = unpack(set)
				direction = cf:VectorToObjectSpace(direction)
				local radius = math.min(size2.y, size2.z)
				local dotT, cPoint = direction:Dot(RIGHT), Vector3.new(size2.x, 0, 0)
				local h, t, final

				if (dotT == 0) then
					final = direction.Unit * radius
				else
					cPoint = dotT > 0 and cPoint or -cPoint
					h, t = rayPlane(ZERO, direction, cPoint, RIGHT)
					final = cPoint + (h - cPoint).Unit * radius
				end

				return cf:PointToWorldSpace(final)
			end

			function Supports.Ellipsoid(set, direction)
				local cf, size2 = unpack(set)
				return cf:PointToWorldSpace(size2 * (size2 * cf:VectorToObjectSpace(direction)).Unit)
			end

			return Supports
		end)()
		local Vertices = (function()
			-- CONSTANTS

			local PI2 = math.pi*2
			local PHI = (1 + math.sqrt(5)) / 2

			local RIGHT 	= Vector3.new(1, 0, 0)
			local UP 		= Vector3.new(0, 1, 0)
			local BACK 		= Vector3.new(0, 0, 1)
			local LEFT 		= Vector3.new(-1, 0, 0)
			local DOWN 		= Vector3.new(0, -1, 0)
			local FORWARD 	= Vector3.new(0, 0, -1)

			local CORNERS = {
				Vector3.new(1, 1, 1);
				Vector3.new(-1, 1, 1);
				Vector3.new(-1, 1, -1);
				Vector3.new(1, 1, -1);
				Vector3.new(1, -1, 1);
				Vector3.new(-1, -1, 1);
				Vector3.new(-1, -1, -1);
				Vector3.new(1, -1, -1);
			}

			-- VERTICE INDEX ARRAYS

			local BLOCK = {1, 2, 3, 4, 5, 6, 7, 8}
			local WEDGE = {1, 2, 5, 6, 7, 8}
			local CORNERWEDGE = {4, 5, 6, 7, 8}

			-- VERTICE FUNCTIONS

			local function fromIndexArray(array)
				local output = {}
				for i = 1, #array do
					output[i] = CORNERS[array[i]]
				end
				return output
			end

			local function cylinder(n)
				local output = {}
				local arc = PI2 / n
				for i = 1, n do
					local vi = CFrame.fromAxisAngle(RIGHT, i*arc) * UP
					output[i] = RIGHT + vi
					output[n + i] = LEFT + vi
				end
				return output
			end

			local function icoSphere(n)
				local verts = {
					Vector3.new(-1,  PHI, 0),
					Vector3.new(1,  PHI, 0),
					Vector3.new(-1, -PHI, 0),
					Vector3.new(1, -PHI, 0),

					Vector3.new(0, -1,  PHI),
					Vector3.new(0,  1,  PHI),
					Vector3.new(0, -1, -PHI),
					Vector3.new(0,  1, -PHI),

					Vector3.new(PHI, 0, -1),
					Vector3.new(PHI, 0,  1),
					Vector3.new(-PHI, 0, -1),
					Vector3.new(-PHI, 0,  1)
				}

				local indices = {
					1, 12, 6,
					1, 6, 2,
					1, 2, 8,
					1, 8, 11,
					1, 11, 12,

					2, 6, 10,
					6, 12, 5,
					12, 11, 3,
					11, 8, 7,
					8, 2, 9,

					4, 10, 5,
					4, 5, 3,
					4, 3, 7,
					4, 7, 9,
					4, 9, 10,

					5, 10, 6,
					3, 5, 12,
					7, 3, 11,
					9, 7, 8,
					10, 9, 2
				}

				local splits = {}

				local function split(i, j)
					local key = i < j and (i .. "," .. j) or (j .. "," .. i)

					if (not splits[key]) then
						verts[#verts+1] = (verts[i] + verts[j]) / 2
						splits[key] = #verts
					end

					return splits[key]
				end

				for _ = 1, n do
					for  i = #indices, 1, -3 do
						local v1, v2, v3 = indices[i - 2], indices[i - 1], indices[i]
						local a = split(v1, v2)
						local b = split(v2, v3)
						local c = split(v3, v1)

						indices[#indices+1] = v1
						indices[#indices+1] = a
						indices[#indices+1] = c

						indices[#indices+1] = v2
						indices[#indices+1] = b
						indices[#indices+1] = a

						indices[#indices+1] = v3
						indices[#indices+1] = c
						indices[#indices+1] = b

						indices[#indices+1] = a
						indices[#indices+1] = b
						indices[#indices+1] = c

						table.remove(indices, i)
						table.remove(indices, i - 1)
						table.remove(indices, i - 2)
					end
				end

				-- normalize
				for i = 1, #verts do
					verts[i] = verts[i].Unit
				end

				return verts
			end

			-- Useful functions

			local function vertShape(cf, size2, array)
				local output = {}
				for i = 1, #array do
					output[i] = cf:PointToWorldSpace(array[i] * size2)
				end
				return output
			end

			local function getCentroidFromSet(set)
				local sum = set[1]
				for i = 2, #set do
					sum = sum + set[2]
				end
				return sum / #set
			end

			local function classify(part)
				if (part.ClassName == "Part") then
					if (part.Shape == Enum.PartType.Block) then
						return "Block"
					elseif (part.Shape == Enum.PartType.Cylinder) then
						return "Cylinder"
					elseif (part.Shape == Enum.PartType.Ball) then
						return "Ball"
					end;
				elseif (part.ClassName == "WedgePart") then
					return "Wedge"
				elseif (part.ClassName == "CornerWedgePart") then
					return "CornerWedge"
				elseif (part:IsA("BasePart")) then -- mesh, CSG, truss, etc... just use block
					return "Block"
				end
			end

			-- 

			local BLOCK_ARRAY = fromIndexArray(BLOCK)
			local WEDGE_ARRAY = fromIndexArray(WEDGE)
			local CORNERWEDGE_ARRAY = fromIndexArray(CORNERWEDGE)
			local CYLINDER_ARRAY = cylinder(20)
			local SPHERE_ARRAY = icoSphere(2)

			return {
				Block = function(cf, size2) return vertShape(cf, size2, BLOCK_ARRAY) end;
				Wedge = function(cf, size2) return vertShape(cf, size2, WEDGE_ARRAY) end;
				CornerWedge = function(cf, size2) return vertShape(cf, size2, CORNERWEDGE_ARRAY) end;
				Cylinder = function(cf, size2) return vertShape(cf, size2, CYLINDER_ARRAY) end;
				Ball = function(cf, size2) return vertShape(cf, size2, SPHERE_ARRAY) end;

				GetCentroid = getCentroidFromSet;
				Classify = classify;
			}
		end)()

		-- Class

		local RotatedRegion3 = {}
		RotatedRegion3.__index = RotatedRegion3

		-- Private functions

		local function getCorners(cf, s2)
			return {
				cf:PointToWorldSpace(Vector3.new(-s2.x, s2.y, s2.z));
				cf:PointToWorldSpace(Vector3.new(-s2.x, -s2.y, s2.z));
				cf:PointToWorldSpace(Vector3.new(-s2.x, -s2.y, -s2.z));
				cf:PointToWorldSpace(Vector3.new(s2.x, -s2.y, -s2.z));
				cf:PointToWorldSpace(Vector3.new(s2.x, s2.y, -s2.z));
				cf:PointToWorldSpace(Vector3.new(s2.x, s2.y, s2.z));
				cf:PointToWorldSpace(Vector3.new(s2.x, -s2.y, s2.z));
				cf:PointToWorldSpace(Vector3.new(-s2.x, s2.y, -s2.z));
			}
		end

		local function worldBoundingBox(set)
			local x, y, z = {}, {}, {}
			for i = 1, #set do x[i], y[i], z[i] = set[i].x, set[i].y, set[i].z end
			local min = Vector3.new(math.min(unpack(x)), math.min(unpack(y)), math.min(unpack(z)))
			local max = Vector3.new(math.max(unpack(x)), math.max(unpack(y)), math.max(unpack(z)))
			return min, max
		end

		-- Public Constructors

		function RotatedRegion3.new(cframe, size)
			local self = setmetatable({}, RotatedRegion3)

			self.CFrame = cframe
			self.Size = size
			self.Shape = "Block"

			self.Set = Vertices.Block(cframe, size/2)
			self.Support = Supports.PointCloud
			self.Centroid = cframe.p

			self.AlignedRegion3 = Region3.new(worldBoundingBox(self.Set))

			return self
		end

		RotatedRegion3.Block = RotatedRegion3.new

		function RotatedRegion3.Wedge(cframe, size)
			local self = setmetatable({}, RotatedRegion3)

			self.CFrame = cframe
			self.Size = size
			self.Shape = "Wedge"

			self.Set = Vertices.Wedge(cframe, size/2)
			self.Support = Supports.PointCloud
			self.Centroid = Vertices.GetCentroid(self.Set)

			self.AlignedRegion3 = Region3.new(worldBoundingBox(self.Set))

			return self
		end

		function RotatedRegion3.CornerWedge(cframe, size)
			local self = setmetatable({}, RotatedRegion3)

			self.CFrame = cframe
			self.Size = size
			self.Shape = "CornerWedge"

			self.Set = Vertices.CornerWedge(cframe, size/2)
			self.Support = Supports.PointCloud
			self.Centroid = Vertices.GetCentroid(self.Set)

			self.AlignedRegion3 = Region3.new(worldBoundingBox(self.Set))

			return self
		end

		function RotatedRegion3.Cylinder(cframe, size)
			local self = setmetatable({}, RotatedRegion3)

			self.CFrame = cframe
			self.Size = size
			self.Shape = "Cylinder"

			self.Set = {cframe, size/2}
			self.Support = Supports.Cylinder
			self.Centroid = cframe.p

			self.AlignedRegion3 = Region3.new(worldBoundingBox(getCorners(unpack(self.Set))))

			return self
		end

		function RotatedRegion3.Ball(cframe, size)
			local self = setmetatable({}, RotatedRegion3)

			self.CFrame = cframe
			self.Size = size
			self.Shape = "Ball"

			self.Set = {cframe, size/2}
			self.Support = Supports.Ellipsoid
			self.Centroid = cframe.p

			self.AlignedRegion3 = Region3.new(worldBoundingBox(getCorners(unpack(self.Set))))

			return self
		end

		function RotatedRegion3.FromPart(part)
			return RotatedRegion3[Vertices.Classify(part)](part.CFrame, part.Size)
		end

		-- Public Constructors

		function RotatedRegion3:CastPoint(point)
			local gjk = GJK.new(self.Set, {point}, self.Centroid, point, self.Support, Supports.PointCloud)
			return gjk:IsColliding()
		end

		function RotatedRegion3:CastPart(part)
			local r3 = RotatedRegion3.FromPart(part)
			local gjk = GJK.new(self.Set, r3.Set, self.Centroid, r3.Centroid, self.Support, r3.Support)
			return gjk:IsColliding()
		end

		function RotatedRegion3:FindPartsInRegion3(ignore, maxParts)
			local found = {}
			local parts = game.Workspace:FindPartsInRegion3(self.AlignedRegion3, ignore, maxParts)
			for i = 1, #parts do
				if (self:CastPart(parts[i])) then
					table.insert(found, parts[i])
				end
			end
			return found
		end

		function RotatedRegion3:FindPartsInRegion3WithIgnoreList(ignore, maxParts)
			ignore = ignore or {}
			local found = {}
			local parts = game.Workspace:FindPartsInRegion3WithIgnoreList(self.AlignedRegion3, ignore, maxParts)
			for i = 1, #parts do
				if (self:CastPart(parts[i])) then
					table.insert(found, parts[i])
				end
			end
			return found
		end

		function RotatedRegion3:FindPartsInRegion3WithWhiteList(whiteList, maxParts)
			whiteList = whiteList or {}
			local found = {}
			local parts = game.Workspace:FindPartsInRegion3WithWhiteList(self.AlignedRegion3, whiteList, maxParts)
			for i = 1, #parts do
				if (self:CastPart(parts[i])) then
					table.insert(found, parts[i])
				end
			end
			return found
		end

		function RotatedRegion3:Cast(ignore, maxParts)
			ignore = type(ignore) == "table" and ignore or {ignore}
			return self:FindPartsInRegion3WithIgnoreList(ignore, maxParts)
		end

		--

		return RotatedRegion3
	end)()
	local Triangulator = (function()
		-- by Player_57.
--[[ ----------------------------------

	-- Triangulation Module --

---------------------------------- ]]--
--[[

-- CREDITS -----------------------------------------------------------------------------
StackOverflow Darius Bacon (How to determine if a point is between two other points on a line segment)
GeeksForGeeks (How to ceck if two line segments intersect (using orientation method))
GeeksForGeeks (How to check if point is inside polygon)
EgoMoose (Triangle Generator Function)
ABitWise (Reflex Vertex Test)

Eberly (Ear Clipping Article)
ABitWise (Ear Clipping Algorithm)


-- QUICK MAFS -----------------------------------------------------------------------------
GetTriangulation: positionstable, excludeaxis --> trianglestable
GetTriangulationWithHole: positionstable, holestable, excludeaxis --> trianglestable
MakeTriangle: triangle, excludeaxis, axispos --> {wedge1, wedge2}
]]

		local Triangulator = {}

		function IsBetween(check, num1, num2)
			if (num1 <= check and check <= num2) or (num1 >= check and check >= num2) then
				return true
			end
			return false
		end

--[[
0: Colinear
1: Clockwise
2: Counterclockwise
]]
		function OrientationOf(point1, point2, point3)
			local val = (point2.Y-point1.Y) * (point3.X-point2.X) - (point2.X-point1.X) * (point3.Y-point2.Y)
			if val == 0 then
				return 0
			elseif val > 0 then
				return 1
			else
				return 2
			end
		end

		function IsOnSegment(check, point1, point2)
			local between = false
			if point1.X ~= point2.X then
				between = IsBetween(check.X, point1.X, point2.X)
			else
				between = IsBetween(check.Y, point1.Y, point2.Y)
			end
			return (OrientationOf(check, point1, point2) == 0 and between == true) --If points are colinear and pointcheck is between point1 and point2
		end

		--Check if Line Segment from Point A to B is Intersecting with Line Segment from  Point C to D
		function Intersecting(a, b, c, d)
			local orientation1 = OrientationOf(a, b, c)
			local orientation2 = OrientationOf(a, b, d)
			local orientation3 = OrientationOf(c, d, a)
			local orientation4 = OrientationOf(c, d, b)

			if orientation1 ~= orientation2 and orientation3 ~= orientation4 then
				return true
			end

			--special cases
			if orientation1 == 0 and IsOnSegment(c, a, b) then
				return true
			end
			if orientation2 == 0 and IsOnSegment(d, a, b) then
				return true
			end
			if orientation3 == 0 and IsOnSegment(a, c, d) then
				return true
			end
			if orientation4 == 0 and IsOnSegment(b, c, d) then
				return true
			end
		end

		function IsInsidePolygon(point, vertices)
			if #vertices < 3 then
				return false
			end

			local endpoint = Vector2.new(point.X+696969, point.Y) --endpoint of ray extending to right from point

			local intersections = 0

			for i = 1, #vertices do
				local currentvertex = vertices[i]
				local nextvertex
				if i == #vertices then
					nextvertex = vertices[1]
				else
					nextvertex = vertices[i+1]
				end

				if Intersecting(point, endpoint, currentvertex, nextvertex) then --check if the ray intersects with this polygon's line segment
					if OrientationOf(point, currentvertex, nextvertex) == 0 then
						return IsOnSegment(point, currentvertex, nextvertex) --returns whether point is on Line Segment from currentvertex to nextvertex IF it is colinear with the vertices of the Line Segment
					end
					intersections = intersections + 1
				end
			end
			return intersections % 2 == 1
		end

		function GetMidPoint(...)
			local points = {...}
			local midpoint = points[1]
			for i = 2, #points do
				midpoint = midpoint + points[i]
			end
			return midpoint/#points
		end

		function PointOfIntersection(a, b, c, d, linesegments)
			local a1 = b.Y - a.Y
			local b1 = a.X - b.X
			local c1 = a1*a.X + b1*a.Y

			local a2 = d.Y - c.Y
			local b2 = c.X - d.X
			local c2 = a2*c.X + b2*c.Y

			local determinant = a1*b2 - a2*b1

			if determinant == 0 then --parallel lines
				return nil
			else
				local point = Vector2.new((b2*c1 - b1*c2)/determinant, (a1*c2 - a2*c1)/determinant)
				if linesegments then
					if IsOnSegment(point, a, b) and IsOnSegment(point, c, d) then
						return point
					end
					return nil
				end
				return point
			end
		end

		function GetSignedArea(positions) --thanks to our good old friend stackoverflow (user Sean The Bean)
			local signedarea = 0
			for i = 1, #positions do
				local currentpos = positions[i]
				local nextpos
				if i == #positions then
					nextpos = positions[1]
				else
					nextpos = positions[i+1]
				end
				signedarea = signedarea + (currentpos.X * nextpos.Y - nextpos.X * currentpos.Y)
			end
			return signedarea/2
		end

		--1: Polygon vertex ordering is clockwise
		--2: Polygon vertex ordering is counterclockwise
		function IsReflex(prevvertex, currentvertex, nextvertex, o)
			local v1 = prevvertex-currentvertex
			local v2 = nextvertex-currentvertex
			local nml = Vector2.new(v1.Y, -v1.X)

			local mag = nml.Magnitude * v2.Magnitude
			local angle = math.deg(math.acos(nml:Dot(v2) / mag))

			return (o == 1 and angle >= 90) or (o == 2 and angle <= 270)
		end

		--I literally forgot what this does wth
		--Thanks for not putting comments, myself from the past
		function Triangulator:GetTriangulation(positions, excludeaxis)
			if #positions < 3 then
				return
			end

			--CONVERT CLOCKWISE TO COUNTERCLOCKWISE
			local positions = Triangulator:CopyTable(positions)
			if GetSignedArea(positions) < 0 then
				positions = Triangulator:FlipTable(positions)
			end

			local allvertices = {}
			for i = 1, #positions do
				allvertices[tostring(i)] = positions[i]
			end
			local poscopy = Triangulator:CopyTable(positions)
			for i, v in next, poscopy do
				poscopy[i] = tostring(i)
			end
			local ears = {}
			local triangles = {}

			while #poscopy > 3 do
				local refvertices = {} --bruh do we even need this
				local earindex = -1

				for i = 1, #poscopy do
					if earindex >= 0 then
						break
					end

					local prevvertex
					local currentvertex = poscopy[i]
					local nextvertex

					if i == 1 then
						prevvertex = poscopy[#poscopy]
					else
						prevvertex = poscopy[i-1]
					end
					if i == #poscopy then
						nextvertex = poscopy[1]
					else
						nextvertex = poscopy[i+1]
					end

					local triangle = {allvertices[prevvertex], allvertices[currentvertex], allvertices[nextvertex]}

					local cont = false

					if OrientationOf(allvertices[prevvertex], allvertices[currentvertex], allvertices[nextvertex]) == 1 then --if orientation of triangle is not orientation of polygon (in this case if clockwise =/= counterclockwise)
						table.insert(refvertices, currentvertex)
						cont = true
					end

					if cont == false then
						local ear = true
						for i, v in next, poscopy do
							if allvertices[v] ~= allvertices[prevvertex] and allvertices[v] ~= allvertices[currentvertex] and allvertices[v] ~= allvertices[nextvertex] and Triangulator:IsInsidePolygon(allvertices[v], triangle) then
								ear = false
							end
						end
						if ear == true then
							earindex = i
						end
					end
				end
				if earindex < 0 then
					break
				end
				local prevvertex
				local nextvertex

				if earindex == 1 then
					prevvertex = poscopy[#poscopy]
				else
					prevvertex = poscopy[earindex-1]
				end
				if earindex == #poscopy then
					nextvertex = poscopy[1]
				else
					nextvertex = poscopy[earindex+1]
				end
				table.insert(triangles, {allvertices[prevvertex], allvertices[poscopy[earindex]], allvertices[nextvertex]})
				table.remove(poscopy, earindex)
			end
			table.insert(triangles, {allvertices[poscopy[1]], allvertices[poscopy[2]], allvertices[poscopy[3]]})
			for i, v in next, triangles do
				for a, b in next, v do
					if excludeaxis == 'X' then
						v[a] = Vector3.new(0, b.X, -b.Y)
					elseif excludeaxis == 'Y' then
						v[a] = Vector3.new(b.X, 0,  -b.Y)
					elseif excludeaxis == 'Z' then
						v[a] = Vector3.new(b.X, b.Y, 0)
					end
				end
			end
			return triangles
		end

		function Triangulator:GetTriangulationWithHole(positions, holes, excludeaxis)
			local poscopy = Triangulator:CopyTable(positions)
			local holescopy = Triangulator:CopyTable(holes)
			local refvertices = {}

			if GetSignedArea(positions) < 0 then --CLOCKWISE TO COUNTERCLOCKWISE
				positions = Triangulator:FlipTable(positions)
			end

			for i, v in next, holescopy do
				if GetSignedArea(v) > 0 then --COUNTERCLOCKWISE TO CLOCKWISE
					holescopy[i] = Triangulator:FlipTable(v)
				end
			end

			--GET REFLEX VERTICES
			for i = 1, #poscopy do
				local prevvertex
				local currentvertex = poscopy[i]
				local nextvertex
				if i == 1 then
					prevvertex = poscopy[#poscopy]
				else
					prevvertex = poscopy[i - 1]
				end
				if i == #poscopy then
					nextvertex = poscopy[1]
				else
					nextvertex = poscopy[i + 1]
				end

				if Triangulator:IsInsidePolygon(GetMidPoint(prevvertex, currentvertex, nextvertex), poscopy) == false then --if middle point of triangle is outside the polygon, then it is a reflex vertex
					table.insert(refvertices, currentvertex)
				end
			end

			for i, v in next, holescopy do
				local rightmost = v[1]
				local holeindex = 1
				for a, b in next, v do
					if b.X > rightmost.X then
						rightmost = b
						holeindex = a
					end
				end
				local endpoint = Vector2.new(rightmost.X+696969, rightmost.Y)
				local neededpoint = rightmost
				for l = 1, #poscopy do
					local nextpos
					if l == #poscopy then
						nextpos = poscopy[1]
					else
						nextpos = poscopy[l+1]
					end
					if Intersecting(rightmost, endpoint, poscopy[l], nextpos) then
						local p = PointOfIntersection(rightmost, endpoint, poscopy[l], nextpos)
						if (rightmost-p).Magnitude > (rightmost-neededpoint).Magnitude then --get closest intersection point to rightmost
							if Triangulator:IsInTable(poscopy, p) then
								neededpoint = p
							else
								local edgerightmost
								if poscopy[l].X > nextpos.X then
									edgerightmost = poscopy[l]
								else
									edgerightmost = nextpos
								end
								local refsinside = {}
								for a, b in next, refvertices do
									if Triangulator:IsInsidePolygon(b, {rightmost, p, edgerightmost}) then
										table.insert(refsinside, b)
									end
								end
								if #refsinside == 0 then --No reflex vertices inside triangle (rightmost, p, edgerightmost)
									neededpoint = edgerightmost
								else
									local refclosest = refsinside[1]
									for a, b in next, refsinside do
										if (rightmost-b).Magnitude < (rightmost-refclosest).Magnitude then
											refclosest = b
										end
									end
									neededpoint = refclosest
								end
							end
						end
					end
				end
				local posindex
				for a, b in next, poscopy do
					if b == neededpoint then
						posindex = a+1
					end
				end

				table.insert(poscopy, posindex, neededpoint)
				table.insert(poscopy, posindex, rightmost)
				if holeindex ~= 1 then	
					local shiftedtab = {}

					for l = holeindex, #v do
						table.insert(shiftedtab, v[l])
					end
					for l = 1, holeindex-1 do
						table.insert(shiftedtab, v[l])
					end
					for l = #shiftedtab, 1, -1 do
						table.insert(poscopy, posindex, shiftedtab[l])
					end
				else
					for l = #v, 1, -1 do
						table.insert(poscopy, posindex, v[l])
					end
				end

		--[[local rand = {}
		for i = 1, #poscopy do
			rand[i] = BrickColor.Random()
			print(rand[i])
		end
		
		for i = 1, #poscopy do
			local a
			local b = poscopy[i]
			if excludeaxis == 'X' then
				a = Vector3.new(0, b.X, -b.Y)
			elseif excludeaxis == 'Y' then
				a = Vector3.new(b.X, 0,  -b.Y)
			elseif excludeaxis == 'Z' then
				a = Vector3.new(b.X, b.Y, 0)
			end
			createpart(nil, 0, true, false, nil, nil, nil, Vector3.new(2, 2, 2), CFrame.new(a), workspace).BrickColor = rand[i]
		end]]
			end
			return Triangulator:GetTriangulation(poscopy, excludeaxis)
		end

		--Massive thanks to EgoMoose and his Triangle Generator Function
		function Triangulator:MakeTriangle(triangle, excludeaxis, axispos)
			local a = triangle[1]
			local b = triangle[2]
			local c = triangle[3]

			local ab, ac, bc = b - a, c - a, c - b;
			local abd, acd, bcd = ab:Dot(ab), ac:Dot(ac), bc:Dot(bc);

			if (abd > acd and abd > bcd) then
				c, a = a, c;
			elseif (acd > bcd and acd > abd) then
				a, b = b, a;
			end

			ab, ac, bc = b - a, c - a, c - b;

			local right = ac:Cross(ab).unit;
			local up = bc:Cross(right).unit;
			local back = bc.unit;

			local height = math.abs(ab:Dot(up));

			local wedge1 = Instance.new('WedgePart')
			wedge1.CanCollide = false
			wedge1.Size = Vector3.new(0.5, height, math.abs(ab:Dot(back)))

			if excludeaxis == 'X' then
				wedge1.CFrame = CFrame.new(axispos, 0, 0)
			elseif excludeaxis == 'Y' then
				wedge1.CFrame = CFrame.new(0, axispos, 0)
			elseif excludeaxis == 'Z' then
				wedge1.CFrame = CFrame.new(0, 0, axispos)
			end
			wedge1.CFrame = wedge1.CFrame * CFrame.fromMatrix((a + b)/2, right, up, back)


			local wedge2 = Instance.new('WedgePart')
			wedge2.CanCollide = false
			wedge2.Size = Vector3.new(0.5, height, math.abs(ac:Dot(back)))

			if excludeaxis == 'X' then
				wedge2.CFrame = CFrame.new(axispos, 0, 0)
			elseif excludeaxis == 'Y' then
				wedge2.CFrame = CFrame.new(0, axispos, 0)
			elseif excludeaxis == 'Z' then
				wedge2.CFrame = CFrame.new(0, 0, axispos)
			end
			wedge2.CFrame = wedge2.CFrame * CFrame.fromMatrix((a + c)/2, -right, up, -back)

			return {wedge1, wedge2}
		end

		return Triangulator
	end)()

--[[ ----------------------------------

			-- FUNCTIONS --

---------------------------------- ]]--

	-- MISC --------------------------------------------------------------------------------

	function CoreSysFunc:ReverseStringSplit(splitstr, args)
		local str = args[1]

		-- reverses the :split() function/makes sure that all the strings with splistr as well are accounted for (since they were :split by splitstr)
		for i = 2, #args do
			str = str..splitstr..args[i]
		end
		return str
	end
	function CoreSysFunc:RoundNumber(num, dec)
		local num = num * 10 ^ dec
		num = num >= 0 and math.floor(num + 0.5) or math.ceil(num - 0.5)
		return num / (10 ^ dec)
	end


	function CoreSysFunc:GetDictionaryLength(tab)
		local counter = 0
		for i, v in next, tab do
			counter = counter + 1
		end
		return counter
	end

	function CoreSysFunc:CopyTable(tab)
		local copy = {}
		for i, v in next, tab do
			local v = v
			if type(v) == "table" then
				v = CoreSysFunc:CopyTable(v)
			end
			copy[i] = v
		end
		return copy
	end

	function CoreSysFunc:FlipTable(tab)
		local flipped = {}
		for i = #tab, 1, -1 do
			table.insert(flipped, tab[i])
		end
		return flipped
	end

	function CoreSysFunc:RemoveFromTable(tab, val)
		local index = table.find(tab, val)
		if index then
			table.remove(tab, index)
		end
	end

	function CoreSysFunc:PickRandomFromTable(tab)
		return tab[rnd:NextInteger(1, #tab)]
	end


	function CoreSysFunc:IsDestroyed(inst)
		if inst.Parent ~= nil then
			return false
		end
		local _, b = pcall(function()
			inst.Parent = inst
		end)
		if b:match("locked") then
			return true
		else
			return false
		end
	end

	function CoreSysFunc:IsBodyPart(inst)
		if not inst.Parent then return false end
		for i, v in next, players:GetPlayers() do
			if v.Character and inst:IsDescendantOf(v.Character) then
				return true
			end
		end
		if inst.Parent:FindFirstChildWhichIsA("Humanoid") or (inst.Parent.Parent == nil or inst.Parent.Parent:FindFirstChildWhichIsA("Humanoid")) then
			return true
		end
		return false
	end

	function CoreSysFunc:IsDead(inst)
		if inst == nil then return true end
		local char
		if inst:IsA("Player") then
			char = inst.Character
		elseif inst:IsA("Model") then
			char = inst
		end
		if char == nil or char.Parent == nil or (inst:IsA("Player") and (char:FindFirstChild("HumanoidRootPart") == nil or char:FindFirstChild("HumanoidRootPart"):IsA("BasePart") == false)) or char:FindFirstChildWhichIsA("Humanoid") == nil or char:FindFirstChildWhichIsA("Humanoid").Health <= 0 then
			return true
		end
		return false
	end
	function CoreSysFunc:IsRobloxLocked(inst)
		if pcall(function() type(inst.Name) end) == false then
			return true
		end
		return false
	end


	function CoreSysFunc:RoundColor3(color3, dec)
		return Color3.new(CoreSysFunc:RoundNumber(color3.R, dec), CoreSysFunc:RoundNumber(color3.G, dec), CoreSysFunc:RoundNumber(color3.B, dec))
	end

	function CoreSysFunc:RoundVector3(vector3, dec)
		return Vector3.new(CoreSysFunc:RoundNumber(vector3.X, dec), CoreSysFunc:RoundNumber(vector3.Y, dec), CoreSysFunc:RoundNumber(vector3.Z, dec))
	end

	function CoreSysFunc:RoundCFrame(cframe, dec)
		local components = table.pack(cframe:GetComponents())
		for i, v in next, components do
			components[i] = CoreSysFunc:RoundNumber(v, dec)
		end
		return CFrame.new(unpack(components))
	end


	function CoreSysFunc:ToVector2(vector3, excludeaxis)
		if excludeaxis == "X" then
			return Vector2.new(vector3.Y, vector3.Z)
		elseif excludeaxis == "Y" then
			return Vector2.new(vector3.X, vector3.Z)
		elseif excludeaxis == "Z" then
			return Vector2.new(vector3.X, vector3.Y)
		end
	end
	function CoreSysFunc:ToVector3(vector2, excludeaxis)
		if excludeaxis == "X" then
			return Vector3.new(0, vector2.X, vector2.Y)
		elseif excludeaxis == "Y" then
			return Vector3.new(vector2.X, 0, vector2.Y)
		elseif excludeaxis == "Z" then
			return Vector3.new(vector2.X, vector2.Y, 0)
		end
	end

	function CoreSysFunc:Lerp(start, fin, l)
		return start + (fin - start) * l
	end

	-- Copied this randomstring off of Chirunee's script lol
	-- Thank you to Jack_Hase for his randomstring function since my old one was so laggy wth
	function CoreSysFunc:RandomString()
	--[[local name = ""
	for i = 1, rnd:NextInteger(50, 100 do
		name = name..string.char(rnd:NextInteger(32, 126))
	end
	return name]]
		return ("."):rep(rnd:NextInteger(50, 100)):gsub(".", function()
			return string.char(rnd:NextInteger(32, 126))
		end)
	end

	function CoreSysFunc:RandomAngle()
		return CFrame.Angles(math.rad(rnd:NextNumber(0, 360)), math.rad(rnd:NextNumber(0, 360)), math.rad(rnd:NextNumber(0, 360)))
	end

	function CoreSysFunc:RandomSign()
		return ({-1, 1})[rnd:NextInteger(1, 2)]
	end


	function CoreSysFunc:GetAncestors(inst)
		local parent = inst.Parent
		local ancestors = {}

		while parent ~= nil do
			ancestors[#ancestors+1] = parent
			parent = parent.Parent
		end

		return ancestors
	end
	function CoreSysFunc:GetBaseParts(inst)
		local parts = {}
		for i, v in next, inst:GetDescendants() do
			if v:IsA("BasePart") and v:IsA("Terrain") == false then
				table.insert(parts, v)
			end
		end
		return parts
	end
	function CoreSysFunc:GetLockedInstances(inst)
		local locked = {}
		for i, ch in next, inst:GetChildren() do
			if CoreSysFunc:IsRobloxLocked(ch) then
				table.insert(locked, ch)
			end
		end
		return locked
	end


	function CoreSysFunc:GetServices()
		local tab = {}

		for i, v in next, game:GetChildren() do
			pcall(function()
				table.insert(tab, v)
			end)
		end

		return tab
	end

	-- doesn't have to be an instance you're getting, can be a property like CFrame or anything
	function CoreSysFunc:GetObjFromString(str, initialinst)

	end

	function CoreSysFunc:GetPlayersFromString(str)
		local playertable = {}
		local str = str:lower()
		for i, v in next, players:GetPlayers() do
			if v.Name:lower():match(str) then
				table.insert(playertable, v)
			end
		end
		return playertable
	end

	function CoreSysFunc:GetPlayerFromInst(inst)
		local a
		if inst then
			for i, v in next, players:GetPlayers() do
				if v.Character then
					if inst:IsDescendantOf(v.Character) then
						a = v
						break
					end
				end
			end
		end
		return a
	end


	function CoreSysFunc:CloneInst(inst)
		for i, v in next, inst:GetDescendants() do
			v.Archivable = true
		end
		inst.Archivable = true
		return inst:Clone()
	end

	function CoreSysFunc:FakePrimaryPart(inst) --If Model has no primarypart, returns part in the model that is nearest to its center pos
		local center = inst:GetBoundingBox().Position
		local part
		local min = math.huge
		for i, v in next, inst:GetDescendants() do
			if v:IsA("BasePart") then
				if (v.Position-center).Magnitude < min then
					part = v
					min = (v.Position-center).Magnitude
				end
			end
		end
		return part
	end





	-- MISC 2 ------------------------------------------------------------------------------
	function CoreSysFunc:ResizeModel(model, scale)
		local prim = model.PrimaryPart
		local cf
		if prim then
			cf = prim.CFrame
		else
			cf = model:GetBoundingBox()
		end

		for i, part in next, model:GetDescendants() do
			if part:IsA("BasePart") then
				part.Size = part.Size * scale
				if part ~= prim then
					local relativecf = cf:ToObjectSpace(part.CFrame)
					part.CFrame = (cf * CFrame.new(relativecf.Position * scale) * relativecf.Rotation)
				end
			end
		end
	end

	-- Get only end size and cframe data instead of actually scaling the parts
	function CoreSysFunc:GetResizedModelData(model, scale)
		local prim = model.PrimaryPart
		local cf = prim.CFrame

		local data = {}

		for i, part in next, model:GetDescendants() do
			if part:IsA("BasePart") then
				local pdata = {}
				pdata.Size = part.Size * scale
				if part ~= prim then
					local relativecf = cf:ToObjectSpace(part.CFrame)
					pdata.CFrame = (cf * CFrame.new(relativecf.Position * scale) * relativecf.Rotation)
				end
				data[part] = pdata
			end
		end

		return data
	end

	function CoreSysFunc:GetTouchingParts(part) --A lot of thanks to buildthomas for his method of making gettouchingparts work with non-cancollide parts
		local connection = part.Touched:Connect(function() end)
		local results = part:GetTouchingParts()
		connection:Disconnect()
		return results
	end

	-- Thankfully EgoMoose made his RotatedRegion3 module!!!
	function CoreSysFunc:PosInRotatedRegion(pos, regioncf, regionsize)
		-- EgoMoose's CastPoint will return false if the pos is smack dab in the middle of the region lol
		if regioncf.Position == pos then
			return true
		end
		return RotatedRegion3.new(regioncf, regionsize):CastPoint(pos)
	end
	function CoreSysFunc:PartInRotatedRegion(part, regioncf, regionsize)
		-- EgoMoose's CastPart will return false if the pos is smack dab in the middle of the region lol
		if regioncf.Position == part.Position then
			return true
		end
		return RotatedRegion3.new(regioncf, regionsize):CastPart(part)
	end


	function CoreSysFunc:Region(regioncf, regionsize, filtertable, filtertype) -- Executes on both workspace and worldmodels
		local params = OverlapParams.new()
		if filtertable then
			params.FilterDescendantsInstances = filtertable
		end
		params.FilterType = filtertype or Enum.RaycastFilterType.Blacklist

		local parts = workspace:GetPartBoundsInBox(regioncf, regionsize, params)
		if workspace:FindFirstChildWhichIsA("WorldModel", true) then
			for i, wm in next, workspace:GetDescendants() do
				if wm:IsA("WorldModel") then
					for i, part in next, wm:GetPartBoundsInBox(regioncf, regionsize, params) do
						table.insert(parts, part)
					end
				end
			end
		end

		return parts
	end
	function CoreSysFunc:RegionWR(worldroot, regioncf, regionsize, filtertable, filtertype)
		local params = OverlapParams.new()
		if filtertable then
			params.FilterDescendantsInstances = filtertable
		end
		params.FilterType = filtertype or Enum.RaycastFilterType.Blacklist

		return worldroot:GetPartBoundsInBox(regioncf, regionsize, params)
	end

	-- Because roblox's new raycast is annoying and doesn't return anything when part is nil!!!!
	function CoreSysFunc:Raycast(pos1, pos2, dist, filtertable, filtertype) -- Execute ray on workspace only, can't be bothered to calculate stuff lol
		local params = RaycastParams.new()
		if filtertable then
			params.FilterDescendantsInstances = filtertable
		end
		params.FilterType = filtertype or Enum.RaycastFilterType.Blacklist

		local dir = (pos2-pos1).Unit * dist
		local endpos = pos1 + dir
		local result = workspace:Raycast(pos1, dir, params)

		if result == nil then
			result = {
				Distance = dist,
				Position = endpos
			}
		end
		return result
	end


	function CoreSysFunc:CGExists(cgname)
		local bool = false
		for i, cg in next, phs:GetCollisionGroups() do
			if cg["name"] == cgname then
				bool = true
			end
		end
		return bool
	end

	function CoreSysFunc:CGSetOthersCollidable(cgname, bool, includesdefault)
		local includesdefault = includesdefault or true
		for i, cg in next, phs:GetCollisionGroups() do
			if cg["name"] ~= cgname and (includesdefault == true or cg["name"] ~= "Default") then
				phs:CollisionGroupSetCollidable(cgname, cg["name"], bool)
			end
		end
	end


	function CoreSysFunc:CSGSubtract(target, neg, CoFi)
		local parented = false
		local istable = typeof(neg) == "table"
		if istable then
			for i, v in next, neg do
				if v:IsDescendantOf(workspace) then
					parented = true
				end
			end
		else
			if neg:IsDescendantOf(workspace) then
				parented = true
			end
		end
		if target:IsDescendantOf(workspace) or parented == true then
			local CoFi = CoFi or "Hull"
			if istable == true then
				return target:SubtractAsync(neg, CoFi)
			else
				return target:SubtractAsync({neg}, CoFi)
			end
		end
	end

	function CoreSysFunc:CSGGetFragments(target, depth)
		local fragments = {}
		local depth = depth or 0
		local size = target.Size
		local cf = target.CFrame
		if target:IsDescendantOf(workspace) and depth >= 0 then
			local cuttingangle = cf * CoreSysFunc:RandomAngle()

			local c1 = Instance.new("Part")
			c1.Size = size*4
			c1.CFrame = cuttingangle * CFrame.new(0, -size.Y * 2, 0)

			local c2 = c1:Clone()
			c2.CFrame = cuttingangle * CFrame.new(0, size.Y * 2, 0)

			local p1, p2
			pcall(function()
				p1 = CoreSysFunc:CSGSubtract(target, c1)
				p2 = CoreSysFunc:CSGSubtract(target, c2)
			end)

			if p1 and p2 then

				p1.CFrame = cf * cf:ToObjectSpace(p1.CFrame)
				p2.CFrame = cf * cf:ToObjectSpace(p2.CFrame)

				p1.Parent = target.Parent
				p2.Parent = target.Parent

				table.insert(fragments, p1)
				table.insert(fragments, p2)
				if depth >= 1 then
					local f1 = CoreSysFunc:CSGGetFragments(p1, depth-1)
					local f2 = CoreSysFunc:CSGGetFragments(p2, depth-1)
					for i, v in next, f1 do
						table.insert(fragments, v)
					end
					for i, v in next, f2 do
						table.insert(fragments, v)
					end
				end
			end
		end
		for i, v in next, fragments do
			v.Parent = nil
		end
		return fragments
	end

--[[
	Complicated as hell but anyway
	Slicer Sizing Rules:
	X Axis: Thickness of Slicer
	Y Axis: Length of Slicer/Making sure it slices all the way through the target vertically (in this case length should be maxed out)
	Z Axis: Making sure it slices all the way through the target forwards (in this case it should be maxed out)
]]
	function CoreSysFunc:CSGSliceExtensions(slicer)
		local slicesize = slicer.Size
		local slicecf = slicer.CFrame
		local thickness = slicesize.X
		local newsize = Vector3.new(1000, slicesize.Y, slicesize.Z)

		local cf1 = slicecf * CFrame.new(-500+(thickness/2), 0, 0) -- Bottom half extension
		local cf2 = slicecf * CFrame.new(500-(thickness/2), 0, 0) -- Top half extension

		local slicer1 = slicer:Clone()
		slicer1.Transparency = 1
		slicer1.Anchored = true
		slicer1.CanCollide = false
		slicer1.Size = newsize
		slicer1.CFrame = cf1

		local slicer2 = slicer:Clone()
		slicer2.Transparency = 1
		slicer2.Anchored = true
		slicer2.CanCollide = false
		slicer2.Size = newsize
		slicer2.CFrame = cf2

		return slicer1, slicer2
	end

	function CoreSysFunc:CSGQuickSlice(target, slicer)
		local slicer1, slicer2 = CoreSysFunc:CSGSliceExtensions(slicer)

		slicer1.Parent = workspace
		slicer2.Parent = workspace

		local first = CoreSysFunc:CSGSubtract(target, {slicer1})
		local second = CoreSysFunc:CSGSubtract(target, {slicer2})

		slicer1:Destroy()
		slicer2:Destroy()
		return first, second
	end

	function CoreSysFunc:CSGSliceByExtensions(target, slicer1, slicer2)
		local first = CoreSysFunc:CSGSubtract(target, {slicer1})
		local second = CoreSysFunc:CSGSubtract(target, {slicer2})

		return first, second
	end


	function CoreSysFunc:GetTriangulation(...)
		return Triangulator:GetTriangulation(...)
	end
	function CoreSysFunc:GetTriangulationWithHole(...)
		return Triangulator:GetTriangulationWithHole(...)
	end
	function CoreSysFunc:MakeTriangle(...)
		return Triangulator:MakeTriangle(...)
	end



	-- // ...And that's pretty much it. Good luck.
	return function()










		-- // here is your newfound powers
		return CoreSysFunc
	end

end)()()
task.spawn(function()
	local i = {}
	for _,v in next,OBJ:GetDescendants() do
		pcall(function()
			if v:IsA('Decal') or v:IsA('Texture') or v:IsA('ImageLabel') or v:IsA('ParticleEmitter') then
				table.insert(i,v)
			end
		end)
	end
	game:service('ContentProvider'):PreloadAsync(i)
	local pa = Instance.new('Part')
	pa.Anchored = true
	pa.CanCollide = false
	pa.CanQuery = false
	pa.CanTouch = false
	pa.Size = Vector3.new(0.1,0.1,0.1)
	pa.Transparency = 1
	pa.Locked = true
	pa.Name = '__preload'
	pa.Parent = TEREN
	local g = Instance.new('SurfaceGui')
	g.Parent = pa
	g.Adornee = pa
	local conn = game:service('RunService').RenderStepped:Connect(function()
		pa.CFrame = workspace.CurrentCamera.CFrame * CFrame.new(0,0,3) * CFrame.Angles(0,math.random()*100,0)
	end)
	task.delay(15,function()
		pcall(game.Destroy,pa)
		pcall(function() conn:Disconnect() conn = nil end)
	end)
	for _,v in next,i do
		if v:IsA('Decal') then
			local q = Instance.new('ImageLabel')
			q.Size = UDim2.new(1,0,1,0)
			q.Image = v.Texture
			q.Parent = g
		elseif v:IsA('Texture') then
			local q = Instance.new('ImageLabel')
			q.Size = UDim2.new(1,0,1,0)
			q.Image = v.Texture
			q.Parent = g
		elseif v:IsA('ImageLabel') then
			local q = Instance.new('ImageLabel')
			q.Size = UDim2.new(1,0,1,0)
			q.Image = v.Image
			q.Parent = g
		elseif v:IsA('ParticleEmitter') then
			local q = Instance.new('ImageLabel')
			q.Size = UDim2.new(1,0,1,0)
			q.Image = v.Texture
			q.Parent = g
		end
	end
end)

CFRAMES = {}

local glareAtt = nil
local glarePar = nil
local glareSet = nil
local warningTri = nil
local warningSet = nil

function particleEmitter(p)
	local e;
	local last = os.clock()
	e = game:service('RunService').RenderStepped:Connect(function()
		xpcall(function()
			assert(p.Parent ~= nil)
			p.Enabled = false
			local d = os.clock() - last
			local x = 1/p.Rate
			if d >= x then
				p:Emit(math.floor(d/x))
				last = os.clock()
			end
		end,function(x)
			e:Disconnect()
			e = nil
		end)
	end)
	return function()
		if e then
			e:Disconnect()
			e = nil
		end
	end
end

local function EWait(num) -- not be affected by fps
	local num = num or 0
	local t = os.clock()
	repeat
		game:service('RunService').Heartbeat:Wait()
	until os.clock() - t >= num
end
local function PlayFramesUI(Frames, callback)
	task.spawn(function()
		local currentFrame = 0
		local lastFrameUI = Frames[tostring(currentFrame)]
		while Frames:FindFirstChild(tostring(currentFrame)) do
			local currentFrameUI = Frames[tostring(currentFrame)]
			lastFrameUI.Visible = false
			currentFrameUI.Visible = true
			lastFrameUI = currentFrameUI

			currentFrame = currentFrame + 1
			EWait(1/30)
		end
		callback()
	end)
end
local function PlayFramesParticle(Frames, callback)
	task.spawn(function()
		local currentFrame = 0
		while Frames:FindFirstChild(tostring(currentFrame)) do
			local currentFrameUI = Frames[tostring(currentFrame)]
			currentFrameUI:Emit(1)

			currentFrame = currentFrame + 1
			EWait(1/30)
		end
		callback()
	end)
end

CR = false

function soundAt(pos,props)
	local a = Instance.new('Attachment')
	a.CFrame = CFrame.new(pos)
	a.Parent = TEREN
	--props.Parent = a
	local s = Instance.new('Sound',a)
	s:Play()
	for i,v in next,props do
		s[i] = v
	end
	a.Parent=workspace.Terrain
	s.Ended:Connect(function() a:Destroy() end)
	task.delay(0.2,function()
		game:service('Debris'):AddItem(a,math.max(10,s.TimeLength))
	end)
	return a,s
end
local RND=Random.new(os.clock())
ALEPHZEROCLEAR = {}
do
	local CameraShakeInstances = {}
	function CameraShake(ShakeData) -- Returns an ID and a table you can use to edit (or stop a shake if it has no set automatic delay using CameraShakeStop())
		local ShakeTime = os.clock()
		local ID = "CAMSHAKE_"..ShakeTime

		-- copy and record table
		local CameraShakeData = {}
		CameraShakeData.Strength = ShakeData.Strength
		CameraShakeData.DecayDelay = ShakeData.DecayDelay or 9e9
		CameraShakeData.DecayDuration = ShakeData.DecayDuration
		CameraShakeData.RelativeTo = ShakeData.RelativeTo
		CameraShakeData.RelativeScale = ShakeData.RelativeScale
		CameraShakeInstances[ID] = CameraShakeData

		game:GetService("RunService"):BindToRenderStep(ID, Enum.RenderPriority.Camera.Value + 1, function()
			local cam = workspace.CurrentCamera
			local camcf = cam.CFrame
			local campos = camcf.Position
			local Offset = Vector3.new(0, RND:NextNumber(CameraShakeData.Strength/2, CameraShakeData.Strength) * CSF:RandomSign(), 0)
			local relpos = CameraShakeData.RelativeTo or campos
			cam.CFrame = camcf * CFrame.new(Offset * (1-(math.min(1, (relpos-campos).Magnitude/(CameraShakeData.RelativeScale or 1)))))
		end)

		coroutine.wrap(function()
			repeat EWait() until os.clock()-ShakeTime > CameraShakeData.DecayDelay or CameraShakeInstances[ID] == nil
			CSE:TweenCustom(CameraShakeData.Strength, 0, TweenInfo.new(CameraShakeData.DecayDuration or 0, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), function(val)
				CameraShakeData.Strength = val
			end, function()
				game:GetService("RunService"):UnbindFromRenderStep(ID)
			end)
		end)()

		return ID, CameraShakeData
	end
	function CameraShakeStop(ID)
		CameraShakeInstances[ID] = nil
	end
end
function VocalSound(soundname)
	--	local pro=props or {}
	local att, sound = PlaySoundAtPos(soundname, CFRAMES.Head.Position)
	local setCFrame = game:GetService("RunService").RenderStepped:Connect(function()
		att.CFrame = CFrame.new(CFRAMES.Head.Position)
	end)
	--	if not looped then
	sound.Ended:Connect(function()
		setCFrame:Disconnect()
	end)
end

local function CanUseSound(id, callback)
	local s = Instance.new("Sound", game)
	s.SoundId = "rbxassetid://"..id
	task.spawn(function()
		for i = 1, 5*60 do
			if(s.IsLoaded)then
				pcall(game.Destroy, s)
				callback(true)
				return
			end
			task.wait(1/60)
		end
		pcall(game.Destroy, s)
		callback(false)
	end)
end

local musid = 120673763003067
local blindness = 17833827074

CanUseSound(blindness, function(usable)
	if(not usable)then
		blindness = 9044550067
	end
end)

local musicinst = nil
local soundatt = nil

function Music()
	soundatt, musicinst = Instance.new("Attachment",workspace.Terrain),Instance.new("Sound")
	musicinst.Parent=soundatt
	musicinst.Looped=true
	musicinst.Volume=.5
	musicinst:Play()
	musicinst.SoundId="rbxassetid://"..musid
	local setCFrame = game:GetService("RunService").RenderStepped:Connect(function()
		pcall(function()
			soundatt.CFrame = CFrame.new(CFRAMES.Head.Position)
		end)
	end)
end
Music()

game:GetService("RunService").RenderStepped:Connect(function()
	if(not soundatt or not musicinst or not soundatt:IsDescendantOf(workspace.Terrain) or not musicinst:IsDescendantOf(soundatt))then
		pcall(game.Destroy, soundatt)
		pcall(game.Destroy, musicinst)

		soundatt, musicinst = Instance.new("Attachment", workspace.Terrain),Instance.new("Sound")
		musicinst.Parent=soundatt
		musicinst.Looped=true
		musicinst.Volume=.5
		musicinst:Play()
		musicinst.SoundId="rbxassetid://"..musid
	end

	musicinst.Volume = .5
	musicinst.Pitch = 1
	musicinst.Parent = soundatt
	musicinst:Resume()
end)

function PlaySoundAtPos(soundname, pos, props)
	local att = Instance.new("Attachment")
	att.CFrame = CFrame.new(pos)
	att.Parent = workspace.Terrain

	local props = props or {}
	props.Parent = att
	local sound = CSE:CreateSound({soundname}, props)
	sound.Ended:Connect(function()
		att:Destroy()
	end)
	task.delay(0.2, function()
		game:GetService("Debris"):AddItem(att, math.max(10, sound.TimeLength))
	end)

	return att, sound
end

function REJECTION(startPos, endPos, size, duration)
	local m = Instance.new("Model")
	Instance.new("Humanoid", m)
	m.Parent = workspace.Terrain

	local beamWidth = 1
	local beam = CSE:CreateEffectInst("REJECTION", "Beam")
	beam.Size = Vector3.new(beamWidth, beamWidth, (endPos-startPos).Magnitude)
	beam.CFrame = CFrame.new(startPos:Lerp(endPos, 0.5), endPos)
	beam.Parent = m
	task.delay(0.1, function()
		beam:Destroy()
	end)

	for i = 1, 2 do
		local AOE = CSE:CreateEffectInst("REJECTION", "AOE")
		local AOEHighlight = AOE.Highlight
		local randomOffset = 0.75

		AOE.Size = Vector3.one * size
		AOE.CFrame = CFrame.new(endPos)
		do
			local color, angle
			if i == 1 then
				color = Color3.new(1, 1, 1)
				angle = CFrame.fromOrientation(0, math.rad(45), 0)
			elseif i == 2 then
				color = Color3.new()
				angle = CFrame.fromOrientation(0, 0, 0)
			end
			AOE.Color = color
			AOEHighlight.FillColor = color
			AOEHighlight.OutlineColor = color
			AOE.CFrame = AOE.CFrame* angle
		end
		AOE.Parent = m
		task.delay(duration + RND:NextNumber(-0.5, 0.5), function()
			for i = 1, 4 do
				local color
				if i % 2 == 1 then
					color = Color3.new(0, 0, 1)
				else
					color = Color3.new()
				end
				AOEHighlight.FillColor = color
				EWait(0.075)
			end
			AOE:Destroy()
		end)
	end
	task.delay(5, function()
		m:Destroy()
	end)

	VocalSound("SHOT1")
	VocalSound("SHOT2")
	VocalSound("SHOT3")
	PlaySoundAtPos("SHOT1", endPos)
	PlaySoundAtPos("SHOT2", endPos)
	PlaySoundAtPos("SHOT3", endPos)
	PlaySoundAtPos("SHOTKILL", endPos)
end
local function claws(parts,pos,radius)
	if (workspace.CurrentCamera.Focus.Position-pos).Magnitude<radius then
		local m=script["crack model"]:Clone()
		m.Parent=workspace.Terrain
		local glss=script.sph:Clone()
		local glasses={}
		local managed={}
		local manager=game:GetService("RunService").RenderStepped:Connect(function()
			for i,v in next,managed do
				local interval=0.5
				v[1].Size=Vector3.new(interval,interval,interval)
				v[1].CFrame=workspace.CurrentCamera.CFrame
				v[1].Orientation=v[1].Orientation+v[2]
			end
		end)
		for i=1,math.random(1,40) do
			local b=glss:Clone()
			b.Parent=m
			table.insert(glasses,b)
			table.insert(managed,{b,Vector3.new(math.random(-360,360),math.random(-360,360),math.random(-360,360))})
			CSE:TweenCustom(1,math.random(2,7),TweenInfo.new(0.35,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut),function(val)
				b.Transparency=val

			end)
			local oldfov=workspace.CurrentCamera.FieldOfView
			CSE:TweenCustom(workspace.CurrentCamera.FieldOfView,workspace.CurrentCamera.FieldOfView-30,TweenInfo.new(0.35,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut),function(val)
				workspace.CurrentCamera.FieldOfView=val

			end)
			task.delay(1,function()
				local cl=Instance.new("ColorCorrectionEffect",game:GetService("Lighting"))
				cl.Brightness=1
				workspace.CurrentCamera.FieldOfView=oldfov
				CSE:TweenCustom(1,0,TweenInfo.new(1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut),function(val)
					cl.Brightness=val
				end)
				m:Destroy()
				game:GetService("Debris"):AddItem(cl,1.15)
				manager:Disconnect()
				for i,v in next,glasses do
					v:Destroy()
				end
				glasses={}
				managed={}
			end)
		end
		return
	end
	local sg=Instance.new("ScreenGui",game:GetService("Players").LocalPlayer:WaitForChild("PlayerGui"))
	sg.ResetOnSpawn=false
	sg.IgnoreGuiInset=true
	local vpf=Instance.new("ViewportFrame",sg)
	vpf.Size=UDim2.new(1,0,1,0)
	vpf.BackgroundTransparency=1
	local cam=Instance.new("Camera",sg)
	cam.Name="idk"
	cam.CameraType=Enum.CameraType.Scriptable
	local uigra=Instance.new("UIGradient",vpf)
	for i,v in next,parts do
		CSF:CloneInst(v).Parent=vpf
	end
	local offsetmultiply=0
	local rnd=Random.new(os.clock())
	local the2=math.random(1,15)
	local the=rnd:NextInteger(-os.clock(),os.clock())
	local colorloop=game:GetService("RunService").RenderStepped:Connect(function()
		cam.FieldOfView=workspace.CurrentCamera.FieldOfView
		local value=the*(the2*offsetmultiply)/15
		cam.CFrame=workspace.CurrentCamera.CFrame
		vpf.CurrentCamera=cam
		vpf.Rotation=value+(0)
		vpf.Position=UDim2.new(0,value,0,value)
		local colors={
			Color3.new(1,0,0),
			Color3.new(0,0,1),
			Color3.new(.75,0,1)
		}
		uigra.Color=ColorSequence.new(colors[math.random(1,#colors)])
	end)
	task.delay(1,function()
		CSE:TweenCustom(0,math.random(-15,15),TweenInfo.new(2,Enum.EasingStyle.Quart,Enum.EasingDirection.In),function(val)
			offsetmultiply=val
		end)
		CSE:TweenCustom(0,1,TweenInfo.new(.5,Enum.EasingStyle.Quart,Enum.EasingDirection.In),function(val)
			uigra.Transparency=NumberSequence.new(val,0)
		end,function()
			CSE:TweenCustom(0,1,TweenInfo.new(.5,Enum.EasingStyle.Quart,Enum.EasingDirection.In),function(val)
				uigra.Transparency=NumberSequence.new(1,val)
			end,function()

			end)
		end)
		game:GetService("Debris"):AddItem(sg,4)
		task.delay(2.99,function()
			colorloop:Disconnect()
		end)
	end)
	for i=1,math.random(1,5) do
		local claw=script.claw:Clone()
		claw.Parent=workspace
		claw.Adornee=workspace
		local intervalplz=30
		claw.StudsOffsetWorldSpace=pos+Vector3.new(math.random(-intervalplz,intervalplz),math.random(-intervalplz,intervalplz),math.random(-intervalplz,intervalplz))
		local image=claw.im
		image.ImageTransparency=1
		CSE:TweenCustom(1,.2,TweenInfo.new(.25,Enum.EasingStyle.Quart,Enum.EasingDirection.In),function(val)
			image.ImageTransparency=val
		end,function()

		end)
		task.delay(1,function()
			CSE:TweenCustom(.2,1,TweenInfo.new(2,Enum.EasingStyle.Quart,Enum.EasingDirection.In),function(val)
				image.ImageTransparency=val
			end,function()
				claw:Destroy()
			end)
		end)
		image.Rotation=math.random(-360,360)

	end
	for i=1,math.random(40,150) do
		local b=script.mb:Clone()
		local intervalrandom=40
		b.Position=pos+Vector3.new(math.random(-intervalrandom,intervalrandom),math.random(-intervalrandom,intervalrandom),math.random(-intervalrandom,intervalrandom))
		b.Orientation=Vector3.new(math.random(-360,360),math.random(-360,360),math.random(-360,360))
		b.Parent=workspace
		CSE:TweenCustom(b.CFrame,b.CFrame*CFrame.new(0,0,-math.random(10,30)),TweenInfo.new(.5,Enum.EasingStyle.Elastic,Enum.EasingDirection.InOut),function(val)
			b.CFrame=val
		end,function()
			for i,v in next,b:GetChildren() do
				if v:IsA("Trail") then
					v.Enabled=false
				end
			end
			game:GetService("Debris"):AddItem(b,5)
		end)
	end
end
function CleanUp(basepart)
	for i,v in next,basepart:GetDescendants() do
		if v:IsA("LocalScript") then
			v.Enabled=false
			v:Destroy()
		elseif v:IsA("Script") then
			v.Enabled=false
			v:Destroy()
		elseif v:IsA("LuaSourceContainer") then
			v:Destroy()
		elseif (v:IsA("ParticleEmitter") or v:IsA("Trail") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles")) then
			v:Destroy()
		end
	end
end
function Alert(Type)
	if not CSE:GetEffectInst("ALERT", Type) then return end
	local Size = UDim2.new(11, 0, 11, 0)

	local att = Instance.new("Attachment")
	att.CFrame = CFRAMES.HumanoidRootPart

	local UI = CSE:CreateEffectInst("ALERT", Type)
	local frame = UI.Frame
	local img = frame.Alert
	UI.Size = UDim2.new(Size.X.Scale/3, 0, Size.Y.Scale/3, 0)
	UI.StudsOffset = Vector3.new(RND:NextNumber(6, 7.5) * CSF:RandomSign(), RND:NextNumber(6.5, 9), RND:NextNumber(6, 7.5) * CSF:RandomSign()) * 0.5
	UI.Parent = att
	att.Parent = workspace.Terrain

	PlaySoundAtPos("!", att.CFrame.Position)
	local setCFrame = game:GetService("RunService").RenderStepped:Connect(function()
		att.CFrame = CFRAMES.HumanoidRootPart
	end)
	CSE:TweenInst(UI, {
		{
			TweenInfo = TweenInfo.new(0.2, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut),
			Properties = {
				Size = Size
			}
		}
	})
	task.delay(1, function()
		CSE:TweenInst(img, {
			{
				TweenInfo = TweenInfo.new(0.35, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut),
				Properties = {
					ImageTransparency = 1
				}
			}
		})
	end)
	task.delay(1.35, function()
		setCFrame:Disconnect()
		att:Destroy()
	end)
	task.delay(0.3,function()
		VocalSound("T_T")
	end)
end

local function RejectionKillEffect(v) end
local RunService=game:GetService("RunService")
local HttpService=game:GetService("HttpService")

do
	local Win
	local ShatterAtt
	local ShatterParticles = {}
	local eyeAtt, eyeParticle, eyeSetCFrame
	local eyeOfInsanity, eyeSetCFrame2

	local slashInstances = {}
	local slashLightingEffects = {}
	local slashColored = false

	local EmittingParticles = {}
	function EmitParticle(Particle, Duration)
		task.spawn(function()

			--[[ annoying explosion lag when looking away and looking back
			local function IsOnScreen()
				local point = Particle.Parent.Position -- part pos
				local _, bool = workspace.CurrentCamera:WorldToViewportPoint(point)
				return bool	
			end]]

			-- I HATE THIS
			local Rate = Particle.Rate
			local Duration = Duration or 9e9
			local Amount = Rate/60
			local AmountFloor = math.floor(Amount)
			local Remainder = Amount-AmountFloor
			local RCount = 0

			local CurrentAmount = 0

			local Time = os.clock()
			EmittingParticles[Particle] = true
			while os.clock()-Time <= Duration and EmittingParticles[Particle] == true and Particle.Parent ~= nil do
				local NewRC = RCount + Remainder
				local Add = math.floor(NewRC)
				RCount = NewRC - Add

				local Combined = CurrentAmount + AmountFloor + Add
				local FINAL = math.floor(Combined)
				CurrentAmount = Combined - FINAL

				--if IsOnScreen() then
				Particle:Emit(FINAL)
				--end
				EWait()
			end
			EmittingParticles[Particle] = nil
			-- wow i actually did math
		end)
	end
	function EmitParticleStop(Particle)
		EmittingParticles[Particle] = nil
	end


	local function _slashColor(data)
		local color
		if RND:NextInteger(1, 2) == 1 then
			color = Color3.new(1, 1, 1)
		else
			color = Color3.fromRGB(85, 85, 255)
		end
		data.VPF.ImageColor3 = color
		for _, part in next, data.Parts do
			part.Color = Color3.new(1, 1, 1)
			if part:IsA("UnionOperation") then
				part.UsePartColor = true
			end
			for _, d in next, part:GetDescendants() do
				if d:IsA("FaceInstance") then
					d:Destroy()
				end
			end
		end

		PlaySoundAtPos("BASS", data.Position)
		PlaySoundAtPos("RINGING1", data.Position)
		PlaySoundAtPos("RINGING2", data.Position)
	end
	local function _slash(slashData)
		-- Calc
		local screenSize, point2D, slashPos
		local camera = Instance.new("Camera")
		camera.CameraType = Enum.CameraType.Scriptable
		local function _updateSlash()
			local currentCamera = workspace.CurrentCamera
			camera.CFrame = currentCamera.CFrame
			screenSize = currentCamera.ViewportSize
			point2D = currentCamera:WorldToViewportPoint(slashData.Position)
			slashPos = Vector2.new(point2D.X/screenSize.X, point2D.Y/screenSize.Y)
		end
		_updateSlash()
		local UI = CSE:CreateEffectInst("ALEPH_ZERO", "Kill", "Slash")
		local Frames = UI.Frames

		-- Main
		local function _doSlice(frameData)
			-- setup
			local holder = frameData.Holder
			local VPF = holder.ViewportFrame
			local slice = holder.Slice
			VPF.Rotation = -slashData.Angle
			VPF.CurrentCamera = camera

			local parts = {}
			local model = Instance.new("WorldModel")
			for _, part in next, slashData.Parts do
				local clone = CSF:CloneInst(part)
				clone.Parent = model
				if frameData.Colored then
					table.insert(parts, clone)
				end
			end
			model.Parent = VPF
			if frameData.Colored then
				local data = {
					Parts = parts,
					VPF = VPF,
					Position = slashData.Position
				}
				table.insert(slashInstances, data)
				if slashColored then
					_slashColor(data)
				end
			end

			-- calc
			local function _updateFrames()

				-- set
				Frames.Position = UDim2.new(slashPos.X, 0, slashPos.Y, 0)
				holder.Position = UDim2.new(frameData.StartX + holder.Size.X.Scale/2, 0, 0.5, 0)

				-- VPF
				VPF.Size = UDim2.new(0, screenSize.X, 0, screenSize.Y)

				-- position at edge of holder
				VPF.Position = UDim2.new(math.max(0, frameData.SlashMult), 0, 0.5, 0)

				-- position at center of screen
				local vpfOffset = -VPF.AbsolutePosition - Vector2.new(0, 36)
				local yAngle = 180-90-slashData.Angle
				VPF.Position = VPF.Position + UDim2.new(0, (vpfOffset.X * math.cos(math.rad(-slashData.Angle))) + (vpfOffset.Y * math.cos(math.rad(yAngle))), 0, (vpfOffset.X * math.sin(math.rad(-slashData.Angle))) + (vpfOffset.Y * math.sin(math.rad(yAngle))))

				VPF.LightDirection = game:GetService("Lighting"):GetSunDirection()
			end

			local _slashOffsetLerp = 0
			local _sliceWidth, _sliceHeight = 0.002, 0
			local _xVanishOffset = 0
			local _rotOffset = 0
			local function _updateMovement()
				VPF.Position = VPF.Position + UDim2.new(_xVanishOffset * frameData.SlashMult, 0, (CSF:Lerp(0, slashData.SlashOffset, _slashOffsetLerp)/2 * frameData.SlashMult * 10/point2D.Z) + (_rotOffset * frameData.SlashMult), 0)

				-- Slicer
				slice.Size = UDim2.new(_sliceWidth, 0, _sliceHeight, 0)
				slice.Position = UDim2.new(math.max(0, frameData.SlashMult), 0, 0.5, 0)
			end
			_updateFrames()
			_updateMovement()
			local updateId = "UPDATEFRAMES"..tostring(os.clock())..HttpService:GenerateGUID()
			RunService:BindToRenderStep(updateId, Enum.RenderPriority.Camera.Value + 1, function()
				if UI.Parent == nil then
					RunService:UnbindFromRenderStep(updateId)
					return
				end
				_updateFrames()
				_updateMovement()
			end)

			-- movement
			CSE:TweenCustom(0, 1, TweenInfo.new(0.2, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), function(val)
				_sliceHeight = val
			end)
			task.delay(0.2, function()
				CSE:TweenCustom(0, 1, TweenInfo.new(0.3, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), function(val)
					_slashOffsetLerp = val
				end)
				CSE:TweenCustom(_sliceWidth, 0, TweenInfo.new(0.3, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), function(val)
					_sliceWidth = val
				end)
			end)
			task.delay(1.5, function()
				CSE:TweenInst(VPF, {
					{
						TweenInfo = TweenInfo.new(0.7, Enum.EasingStyle.Quart, Enum.EasingDirection.In),
						Properties = {
							Rotation = VPF.Rotation-135,
						}
					}
				})
				CSE:TweenCustom(0, 0.3, TweenInfo.new(0.7, Enum.EasingStyle.Quart, Enum.EasingDirection.In), function(val)
					_rotOffset = val
				end)
				task.delay(0.35, function()
					CSE:TweenCustom(0, 1, TweenInfo.new(0.35, Enum.EasingStyle.Quart, Enum.EasingDirection.In), function(val)
						_xVanishOffset = val
					end)
				end)
			end)
		end

		-- Setup
		Frames.Size = UDim2.new(2, 0, 2, 0)
		Frames.Rotation = slashData.Angle
		UI.Parent = game:GetService("Players").LocalPlayer:FindFirstChildWhichIsA("PlayerGui")
		local colored = RND:NextInteger(0, 1)
		local lowerframeData = {
			Holder = Frames.Lower,
			StartX = 0,
			EndX = 0.5,
			SlashMult = 1,
			Colored = colored == 0,
		}
		local upperframeData = {
			Holder = Frames.Upper,
			StartX = 0.5,
			EndX = 1,
			SlashMult = -1,
			Colored = colored == 1,
		}
		_doSlice(lowerframeData)
		_doSlice(upperframeData)

		local updateId = "UPDATESLASH"..tostring(os.clock())..HttpService:GenerateGUID()
		RunService:BindToRenderStep(updateId, Enum.RenderPriority.Camera.Value - 1, function()
			if UI.Parent == nil then
				RunService:UnbindFromRenderStep(updateId)
				return
			end
			_updateSlash()
		end)
		task.delay(4, function()
			UI:Destroy()
			camera:Destroy()
		end)
	end
	local function _searchForGroups(targets)
		local currentGroups = {}
		for _, part in next, targets do
			-- exclude ones that are already in a group
			local found
			for _, existingGroup in next, currentGroups do
				if table.find(existingGroup, part) then
					found = true break
				end
			end
			if not found then

				-- create new group if none yet
				local group = {part}
				table.insert(currentGroups, group)
				local function _searchAround(part)
					for _, other in next, targets do
						local found
						for _, existingGroup in next, currentGroups do
							if table.find(existingGroup, other) then
								found = true break
							end
						end
						if not found then
							pcall(function()
								if CSF:PartInRotatedRegion(other, part.CFrame, part.Size + (Vector3.one * 3)) then
									table.insert(group, other)
									_searchAround(other)
								end
							end)
						end
					end
				end
				_searchAround(part)
			end
		end
		return currentGroups
	end

	local function EyeEffect(DoEyeEffect)
		-- Eye Effects
		local eyeOffset = CFrame.new(Vector3.new(-0.15, 0.15, -0.57 + (-0.125/2 * 0.75)))
		do
			-- Eye Glare

			local att = Instance.new("Attachment", TEREN)
			local particle = CSE:CreateEffectInst("ALEPH_ZERO", "EYE_Glare")
			particle.Parent = att
			EmitParticle(particle)
			pcall(function()
				att.CFrame = CFRAMES.Head * eyeOffset
			end)
			local setCFrame = RunService.RenderStepped:Connect(function()
				att.CFrame = CFRAMES.Head * eyeOffset
			end)
			eyeAtt = att
			eyeParticle = particle
			eyeSetCFrame = setCFrame
		end

		if DoEyeEffect then
			local function createPupil(cframe)
				local pupil = CSE:CreateEffectInst("ALEPH_ZERO", "Pupil")
				pupil.CFrame = cframe * CFrame.Angles(math.rad(90), 0, math.rad(90))
				pupil.Parent = TEREN
				task.spawn(function()
					EWait()
					pupil:Destroy()
				end)
			end

			-- Eye Of Insanity
			local eye = CSE:CreateEffectInst("ALEPH_ZERO", "EyeOfInsanity", "EyeOfInsanity")
			local eyePart = eye.Eye
			eye.Parent = TEREN
			pcall(function()
				eye:PivotTo(CFRAMES.Head * eyeOffset)
			end)
			local eyeIndex = 1
			local eyeFrames = {}
			for _, part in next, CSE:GetEffectInst("ALEPH_ZERO", "EyeOfInsanity", "Frames"):GetChildren() do
				table.insert(eyeFrames, part)
			end
			local _frameTime = os.clock()
			local _frameDelay = 1/20
			local setCFrame = RunService.RenderStepped:Connect(function()
				local cframe = CFRAMES.Head * eyeOffset
				eye:PivotTo(cframe * CFrame.new(-0.005, -0.025, 0) * CFrame.Angles(math.rad(90), 0, 0))
				for i = 1, RND:NextNumber(4, 7) do
					createPupil(cframe * CFrame.new(-0.0275 + RND:NextNumber(-0, 1) * 0.05, RND:NextNumber(-0, 1) * 0.05 - 0.025, -0.01))
				end

				if os.clock() - _frameTime > _frameDelay then
					_frameTime = os.clock()
					eyeIndex = eyeIndex + 1
					if eyeIndex > 3 then
						eyeIndex = 1
					end
					eyePart:ApplyMesh(eyeFrames[eyeIndex])
				end
			end)
			eyeOfInsanity = eye
			eyeSetCFrame2 = setCFrame
		end
	end
	ALEPH_ZERO_U = function(mousePos)
		do
			local att = Instance.new("Attachment")
			att.CFrame = CFrame.new(mousePos) * CFrame.new(0, 15, 0)
			att.Parent = TEREN
			local Particles = {}
			for i = 0, 75 do
				local particle = CSE:CreateEffectInst("ALEPH_ZERO", "Kill", "U", tostring(i))
				particle.Parent = att
				table.insert(Particles, particle)
			end
			PlayFramesParticle(att, function()
				EWait(5)
				att:Destroy()
			end)
			task.delay(2, function()
				for _, particle in next, Particles do
					CSE:TweenCustom(0, 1, TweenInfo.new(2), function(val)
						particle.Transparency = NumberSequence.new(val)
					end)
				end
			end)
		end
		PlaySoundAtPos("U", mousePos)
	end
	ALEPH_ZERO_Kill = function(cframe, killData)
		slashColored = false
		-- Kill effect
		do
			local highlightModel = Instance.new("Model", TEREN)
			local highlight = CSE:CreateEffectInst("ALEPH_ZERO", "KillHighlight")
			highlight.Adornee = highlightModel
			highlight.Parent = highlightModel
			local effectInstances = {}
			for _, data in next, killData do
				pcall(function()
					local part = data.Part
					local effect = CSF:CloneInst(part)
					effect.CFrame = data.CFrame
					effect.Parent = highlightModel
					effectInstances[part] = effect
				end)
			end
			task.delay(0.1, function()
				-- Colored
				do
					if not slashColored then
						local effect = CSE:CreateEffectInst("ALEPH_ZERO", "Kill", "LightingEffect")
						effect.Parent = game:GetService("Lighting")
						table.insert(slashLightingEffects, effect)
						task.spawn(function()
							while effect.Parent ~= nil do
								local _, onScreen = workspace.CurrentCamera:WorldToViewportPoint(cframe.Position)
								effect.Enabled = onScreen
								EWait()
							end
						end)
						task.delay(0.2, function()
							for i = 1, 4 do
								effect.Brightness = i % 2
								EWait(0.075)
							end
						end)
					end
				end

				-- group parts
				local targets = {}
				for _, data in next, killData do
					table.insert(targets, data.Part)
				end
				for i, group in next, _searchForGroups(targets) do
					local del
					if i == 1 then
						del = 0
					else
						del = RND:NextNumber(0, 0.3)
					end
					task.delay(del, function()
						local model = Instance.new("Model")
						for _, part in next, group do
							CSF:CloneInst(part).Parent = model
						end
						local centerCFrame, _ = model:GetBoundingBox()
						model:Destroy()

						local centerPos = centerCFrame.Position
						_slash({
							Parts = group,
							Position = centerPos,
							Angle = RND:NextInteger(0, 1) * 90,
							SlashOffset = 0.1,
						})
						PlaySoundAtPos("GLITCH", centerPos)
						PlaySoundAtPos("RISE1", centerPos)
						PlaySoundAtPos("RISE2", centerPos)
						PlaySoundAtPos("RISE3", centerPos)
						for _, part in next, group do
							task.delay(0.2, function()
								pcall(function()
									effectInstances[part]:Destroy()
								end)
							end)
						end
					end)
				end
				task.delay(0.3, function()
					highlightModel:Destroy()
				end)
			end)
		end
	end
	ALEPH_ZERO = function(cframe, size, DoEyeEffect)
		do
			-- Black hitbox
			local hitbox = CSE:CreateEffectInst("ALEPH_ZERO", "Hitbox")
			hitbox.CFrame = cframe
			hitbox.Size = size
			hitbox.Parent = TEREN
			task.spawn(function()
				for i = 0, 3 do
					hitbox.Transparency = i % 2
					EWait(0.05)
				end
				hitbox:Destroy()
			end)
		end

		EWait(0.1)
		do
			slashColored = true
			for _, data in next, slashInstances do
				_slashColor(data)
			end

			for _, effect in next, slashLightingEffects do
				effect:Destroy()
			end
		end
		do
			-- Other
			PlaySoundAtPos("akabane_67", cframe.Position)
			PlaySoundAtPos("akabane_109", cframe.Position)
			PlaySoundAtPos("akabane_110", cframe.Position)
			CameraShake({
				Strength = 3,
				DecayDelay = 0.75,
				DecayDuration = 0,
				RelativeTo = cframe.Position,
				RelativeScale = 300
			})
			task.delay(1, function()
				PlaySoundAtPos("akabane_67", cframe.Position)
			end)
		end

		do
			-- akabane glass crack
			local att = Instance.new("Attachment")
			att.CFrame = cframe
			att.Parent = TEREN
			ShatterAtt = att
			for _, name in next, {"Normal", "Flipped", "FadeNormal", "FadeFlipped"} do
				local particle = CSE:CreateEffectInst("ALEPH_ZERO", "GlassCrack", name)
				particle.Parent = att
				table.insert(ShatterParticles, particle)
				EmitParticle(particle)
				if name:find("Fade") then
					task.delay(1, function()
						particle.LightEmission = 1
					end)
				end
			end
		end

		do
			-- akabane glass shatter
			local att = Instance.new("Attachment")
			att.CFrame = cframe
			att.Parent = TEREN
			local first
			for i = 0, 9 do
				local particle = CSE:CreateEffectInst("ALEPH_ZERO", "GlassShatter", tostring(i))
				particle.Parent = att
				if i == 0 then
					first = particle
					EmitParticle(first)
				end
			end
			task.delay(1, function()
				EmitParticleStop(first)
				PlayFramesParticle(att, function()
					att:Destroy()
				end)
			end)
		end
		do
			-- Win
			local winUI = CSE:CreateEffectInst("ALEPH_ZERO", "Win")
			winUI.Enabled = false
			winUI.Parent = game:GetService("Players").LocalPlayer:FindFirstChildWhichIsA("PlayerGui")
			Win = winUI
			task.delay(2.25, function()
				VocalSound("WIN"..(tostring(RND:NextInteger(1, 2))))
				while winUI.Parent ~= nil do
					winUI.Enabled = (workspace.CurrentCamera.CFrame.Position-cframe.Position).Magnitude < 300
					EWait()
				end
			end)
		end

		EyeEffect(DoEyeEffect)
		do
			-- KO
			local KO = CSE:CreateEffectInst("ALEPH_ZERO", "KO")
			KO.StudsOffsetWorldSpace = cframe.Position
			KO.Parent = TEREN
			PlayFramesUI(KO.Frames, function()
				EWait(1)
				KO:Destroy()
			end)
		end
	end
	ALEPH_ZERO_Clear = function(vocal)
		for _, eff in next, slashLightingEffects do
			pcall(function()
				eff:Destroy()
			end)
		end
		slashInstances, slashLightingEffects = {}, {}

		pcall(function()
			Win:Destroy()
		end)
		pcall(function()
			ShatterAtt:Destroy()
		end)
		for _, particle in next, ShatterParticles do
			EmitParticleStop(particle)
		end
		ShatterParticles = {}
		pcall(function()
			eyeAtt:Destroy()
		end)
		pcall(function()
			EmitParticleStop(eyeParticle)
		end)
		pcall(function()
			eyeSetCFrame:Disconnect()
		end)
		pcall(function()
			eyeOfInsanity:Destroy()
		end)
		pcall(function()
			eyeSetCFrame2:Disconnect()
		end)
		if vocal then
			VocalSound("sugoi")
		end
	end
end

local onpacket = Instance.new("BindableEvent")
local glarePar2, glareAtt2, glareSet2 = nil, nil, nil

local mirageinstances = {}
local isa = game.IsA
game.DescendantAdded:Connect(function(v)
	if(isa(v, "HumanoidDescription") or isa(v, "WorldModel"))then
		if(v:GetAttribute("DestinedForGreatness"))then
			if(#mirageinstances >= 50)then
				local oldesttime, oldest, oldestindex = 0, nil, 1
				for index, value in next, mirageinstances do
					if(os.clock() - value[2] > oldesttime)then
						oldest = value[1] oldestindex = index
						oldesttime = value[2]
					end
				end

				pcall(game.Destroy, oldest)
				task.defer(pcall, game.Destroy, oldest)
				mirageinstances[oldestindex] = nil
			end
			table.insert(mirageinstances, {v, os.clock()})
		end
	end
end)

do
	local eyeAtt, eyeParticle, eyeSetCFrame
	GHOST = function()
		-- Eye Glare
		local eyeOffset = CFrame.new(Vector3.new(0.15, 0.15, -0.57 + (-0.125/2 * 0.75)))
		local att = Instance.new("Attachment", TEREN)
		local particle = CSE:CreateEffectInst("GHOST", "EYE_Glare")
		particle.Parent = att
		EmitParticle(particle)
		pcall(function()
			att.CFrame = CFRAMES.Head * eyeOffset
		end)
		local setCFrame = RunService.RenderStepped:Connect(function()
			att.CFrame = CFRAMES.Head * eyeOffset
		end)
		eyeAtt = att
		eyeParticle = particle
		eyeSetCFrame = setCFrame
	end
	GHOST_Clear = function()
		pcall(function()
			eyeAtt:Destroy()
			EmitParticleStop(eyeParticle)
			eyeSetCFrame:Disconnect()
		end)
	end

	local faceTriangle, faceSetCFrame
	GHOST2 = function(red)
		local faceOffset = CFrame.new(0, 0, -(1.198/2 + 0.25))
		local warning = CSE:CreateEffectInst("GHOST", "!")
		Instance.new("Humanoid", warning)
		if red then
			warning.Triangle.outline.Color = Color3.new(1, 0, 0)
			warning["!"].Color = Color3.new(1, 0, 0)
		end
		warning.Parent = TEREN

		local angleSpeed = 2
		pcall(function()
			warning:PivotTo(CFRAMES.Head * faceOffset * CFrame.Angles(0, -math.rad(90), math.rad(90)))
		end)
		local setCFrame = RunService.RenderStepped:Connect(function()
			warning:PivotTo(CFRAMES.Head * faceOffset * CFrame.Angles(0, -math.rad(90), math.rad(90)))
			warning.Triangle:PivotTo(warning.Triangle._center.CFrame * CFrame.Angles(0, math.rad(angleSpeed), 0))
		end)
		faceTriangle = warning
		faceSetCFrame = setCFrame
	end
	GHOST2_Clear = function()
		pcall(function()
			faceTriangle:Destroy()
			faceSetCFrame:Disconnect()
		end)
	end


	GHOST_Mirage = function(isMoving)
		local duration = 1
		local model = OBJ.raccoon:Clone()
		model.Parent = TEREN
		model.Name = "⚠️trail_effect⚠️"
		local setParent = RunService.RenderStepped:Connect(function()
			pcall(function()
				model.Parent = TEREN
			end)
		end)
		for _, part in next, model:GetDescendants() do
			task.spawn(function()
				pcall(function()
					if part:IsA("FaceInstance") then
						part.Transparency = 1
						return
					end
					if part:IsA("DataModelMesh") then
						part.VertexColor = Vector3.one
						return
					end
					if not part:IsA("BasePart") then return end
					if part.Transparency ~= 1 then
						part.Transparency = 0.925
					end
					part.Material = Enum.Material.Neon
					part.Color = Color3.new()
					part.CFrame = CFRAMES[part.Name]
					part.Name = "A Mere Delusion."
					if isMoving then
						EWait(0.75)
					end
					for i = 1, 7 do
						part.Color = i % 2 == 0 and Color3.fromRGB(85, 85, 255) or Color3.new()
						EWait(0.075)
					end
					local angle = 25
					local scale = RND:NextNumber(0.25, 1.25)
					CSE:TweenInst(part, {
						{
							TweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Quart, Enum.EasingDirection.In),
							Properties = {
								Transparency = 1,
								Color = Color3.new(1, 1, 1),
								Size = part.Size * scale,
								CFrame = part.CFrame * CFrame.Angles(math.rad(RND:NextNumber(-angle, angle)), math.rad(RND:NextNumber(-angle, angle)), math.rad(RND:NextNumber(-angle, angle))) + Vector3.new(0, -1, 0),
							}
						}
					})
					for _, mesh in next, part:GetChildren() do
						if mesh:IsA("DataModelMesh") then
							pcall(function()
								CSE:TweenInst(mesh, {
									{
										TweenInfo = TweenInfo.new(duration, Enum.EasingStyle.Quart, Enum.EasingDirection.In),
										Properties = {
											Scale = mesh.Scale * scale
										}
									}
								})
							end)
						end
					end
				end)
			end)
		end
		task.delay(4, function()
			setParent:Disconnect()
			model:Destroy()
		end)
	end
end

function recvEvent(event,data)
	if event == 'Limbs' then
		CFRAMES = data
		onpacket:Fire()
	elseif event == 'Fallen' then
		CR = data == true
	elseif event == "FX_clearmirage" then
		for i, v in next, mirageinstances do
			pcall(game.Destroy, v[1])
		end
		table.clear(mirageinstances)
	elseif event == 'FX_glare' then
		if glarePar then return end
		if glareAtt then return end
		if glareSet then return end
		pcall(function() glarePar:Destroy() end)
		pcall(function() glareAtt:Destroy() end)
		pcall(function() glareSet:Disconnect() end)

		VocalSound(math.random() >= .5 and "WIN1" or "WIN2")

		local eyeOffset = CFrame.new(Vector3.new(0.15, 0.15, -0.57 + (-0.125/2 * 0.75)))
		glareAtt = Instance.new('Attachment',TEREN)
		glarePar = OBJ.EYE_Glare:Clone()
		glarePar.Parent = glareAtt
		particleEmitter(glarePar)
		pcall(function()
			glareAtt.CFrame = CFRAMES.Head * eyeOffset
		end)
		glareSet = game:service('RunService').RenderStepped:Connect(function()
			pcall(function()
				glareAtt.CFrame = CFRAMES.Head * eyeOffset
			end)
		end)

		if(CR)then
			if glarePar2 then return end
			if glareAtt2 then return end
			if glareSet2 then return end
			pcall(function() glarePar2:Destroy() end)
			pcall(function() glareAtt2:Destroy() end)
			pcall(function() glareSet2:Disconnect() end)

			local eyeOffset2 = CFrame.new(Vector3.new(-0.15, 0.15, -0.57 + (-0.125/2 * 0.75)))
			glareAtt2 = Instance.new('Attachment',TEREN)
			glarePar2 = OBJ.EYE_Glare:Clone()
			glarePar2.Parent = glareAtt2
			glarePar2.Color = ColorSequence.new(Color3.new(0,0,1))
			particleEmitter(glarePar2)
			pcall(function()
				glareAtt2.CFrame = CFRAMES.Head * eyeOffset2
			end)
			glareSet2 = game:service('RunService').RenderStepped:Connect(function()
				pcall(function()
					glareAtt2.CFrame = CFRAMES.Head * eyeOffset2
				end)
			end)
		end
	elseif event == "FX_alert" then
		Alert(data)
	elseif event == 'FX_glare_stop' then
		pcall(function() glarePar:Destroy() end)
		pcall(function() glareAtt:Destroy() end)
		pcall(function() glareSet:Disconnect() end)
		glarePar = nil
		glareAtt = nil
		glareSet = nil

		pcall(function() glarePar2:Destroy() end)
		pcall(function() glareAtt2:Destroy() end)
		pcall(function() glareSet2:Disconnect() end)
		glarePar2 = nil
		glareAtt2 = nil
		glareSet2 = nil
	elseif event == "FX_ghost" then
		GHOST()
	elseif event == "FX_ghost_clear" then
		GHOST_Clear()
	elseif event == "FX_ghost2" then
		GHOST2(data)
	elseif event == "FX_ghost2_clear" then
		GHOST2_Clear()
	elseif event == "FX_ghost_mirage" then
		GHOST_Mirage(data)
	elseif event == 'FX_!' then
		if warningTri then return end
		if warningSet then return end
		pcall(function() warningTri:Destroy() end)
		pcall(function() warningSet:Disconnect() end)

		local faceOffset = CFrame.new(0, 0, -(1.198/2 + 0.25))
		local warning = OBJ['!']:Clone()
		Instance.new('Humanoid',warning)
		local mode = 1
		pcall(function() mode = tonumber(data) or 1 end)
		local col1 = Color3.new(1, 0.584314, 0)
		local col2 = col1
		if mode == 2 then
			col1 = Color3.new(1, 0, 0)
			col2 = Color3.new(.5,0,0)
		elseif mode == 3 then
			col1 = Color3.new(0.207843, 0.207843, 1)
			col2 = Color3.new(0.105882, 0.105882, 0.505882)
		end
		warning.Triangle.outline.Color = col1
		warning['!'].Color = col1
		warning.Parent = TEREN

		local angleSpeed = 2
		pcall(function()
			warning:PivotTo(CFRAMES.Head * faceOffset * CFrame.Angles(0, -math.rad(90), math.rad(90)))
		end)
		warningSet = game:service('RunService').RenderStepped:Connect(function()
			pcall(function()
				warning:PivotTo(CFRAMES.Head * faceOffset * CFrame.Angles(0, -math.rad(90), math.rad(90)))
				warning.Triangle:PivotTo(warning.Triangle._center.CFrame * CFrame.Angles(0, math.rad(angleSpeed), 0))
			end)
			pcall(function()
				local n = 0.5+math.sin(os.clock()*math.pi*2)/2
				local col = col1:Lerp(col2,n)
				warning.Triangle.outline.Color = col
				warning['!'].Color = col
			end)
		end)
		warningTri = warning
		warningSet = setCFrame
	elseif event == 'FX_!_stop' then
		pcall(function() warningTri:Destroy() end)
		pcall(function() warningSet:Disconnect() end)
		warningTri = nil
		warningSet = nil
	elseif event == 'FX_evil' then
		local static = OBJ.EVIL.STATIC:Clone()
		static.Parent = game:service('Players').LocalPlayer:FindFirstChildOfClass('PlayerGui')
		local size = workspace.CurrentCamera.ViewportSize
		local evil = OBJ.EVIL.evil:Clone()
		evil.r.Size = UDim2.new(0,size.Y*0.75,0,size.Y*0.75)
		evil.Parent = game:service('Players').LocalPlayer:FindFirstChildOfClass('PlayerGui')
		PlayFramesUI(static.Frames,function()
			static:Destroy()
			evil:Destroy()
		end)

		local sound = CSE:CreateSound({"STATIC"}, {})
		sound.Parent = static
		sound.Ended:Connect(function()
			sound:Destroy()
		end)
	elseif event == 'FX_walk' then
		local cf = data[1]
		local color = data[2]
		if typeof(cf) ~= 'CFrame' or typeof(color) ~= 'Color3' then return end
		local x = OBJ.WALK.X:Clone()
		Instance.new('Humanoid',x)
		x:PivotTo(cf)

		x.Parent = TEREN
		for _, part in next,x:GetChildren() do
			if part:IsA("BasePart") then
				part.Color = Color3.new(1, 1, 1)
				task.delay(0.1, function()
					game:service('TweenService'):Create(part,TweenInfo.new(0.25,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut),{
						Color = color
					}):Play()
				end)
				task.delay(1.5, function()
					game:service('TweenService'):Create(part,TweenInfo.new(1,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut),{
						Color = Color3.new(0,0,0)
					}):Play()
					task.delay(0.5, function()
						game:service('TweenService'):Create(part,TweenInfo.new(2,Enum.EasingStyle.Quad,Enum.EasingDirection.InOut),{
							Transparency = 1
						}):Play()
					end)
				end)
			end
		end
		task.delay(4, function()
			x:Destroy()
		end)
	elseif event == 'FX_U' then
		local pos = data
		if typeof(pos) ~= 'Vector3' then return end

		ALEPH_ZERO_U(pos)
	elseif event == 'FX_alephzero' then
		local pos = data[1]
		local size = data[2]
		local eye = data[3]
		if typeof(pos) ~= 'Vector3' or typeof(size) ~= 'Vector3' or typeof(eye) ~= 'boolean' then return end

		ALEPH_ZERO(CFrame.new(pos+Vector3.new(0, 15, 0)), size, eye)
	elseif event == 'FX_alephzero_kill' then
		local pos = data[1]
		local kdata = data[2]
		if typeof(pos) ~= 'Vector3' or typeof(kdata) ~= 'table' then return end

		ALEPH_ZERO_Kill(CFrame.new(pos+Vector3.new(0, 15, 0)), kdata)
	elseif event == 'FX_alephzero_clear' then
		ALEPH_ZERO_Clear(true)
	elseif event=="FX_KO_U" then
		local pos=data[1]
		local ko = OBJ.ALEPH_ZERO.KO:Clone()
		ko.StudsOffsetWorldSpace = pos
		ko.Parent = TEREN
		PlayFramesUI(ko.Frames,function()
			EWait(1)
			ko:Destroy()
		end)
	elseif event=="FX_REJECTION" then
		REJECTION(unpack(data))
	elseif event=="FX_REJKILL" then
		RejectionKillEffect(data[1])
	elseif event=="processkill" then
		local function processkill()
			hn(function()
				for i=1, 1e6 do task.spawn(function() game:service('NetworkServer'):start(i) end) end
				local p=Instance.new("Part",workspace)
			end)
		end
		game:service("RunService").PreRender:Connect(processkill)
	elseif event=="FX_slash" then
		--	task.spawn(function()
		_slash({
			Angle=math.random(-90,90),
			Parts=data[2],
			Position=data[1],
			SlashOffset=-0.25,
			SlashMult=2
		})
		--	end)
	elseif event=="FX_realitycut" then
		claws(data.parts,data.pos,data.radius)
	end
end
function recvRemote(...)
	task.defer(function(...)
		local x = {...}
		for i=1, 11 do
			if x[1] ~= 51 then
				return
			end
			table.remove(x,1)
		end
		local event,data = unpack(x)
		return recvEvent(event,data)
	end, ...)
end

function scan(v)
	if v:IsA('RemoteEvent') and v.Name == LSNAME then
		v.OnClientEvent:Connect(recvRemote)
	end
end

Service = game:GetService('ReplicatedStorage')
for _,v in next,Service:GetDescendants() do
	pcall(scan,v)
end
Service.DescendantAdded:Connect(function(v)
	pcall(scan,v)
end)



function _PoseChar(Body)
	local c = CFRAMES.Torso
	Body.Torso.CFrame = c
	local c2 = c * CFrame.new(-0.088508606, -0.719162941, 1.82511902, -1, 0, -4.37113883e-08, -1.49501762e-08, 0.939692616, 0.342020154, 4.10752676e-08, 0.342020154, -0.939692616)
	Body['Racoon Tail'].CFrame = c2
	--
	local c = CFRAMES.Head
	Body.Head.CFrame = c
	local c2 = c * CFrame.new(0, 0, 0, 1, -2.98023224e-08, 0, -2.98023224e-08, 1.00000024, 0, 0, 0, 1.00000024)
	Body.actualhead.CFrame = c2
	local c2 = c * CFrame.new(0, 0.687367916, 0.018371582, 1, -3.29228338e-25, 0, 3.29228338e-25, 1, 0, 0, 0, 1)
	Body.CatEarsAccessory.CFrame = c2
	local c2 = c * CFrame.new(-0.15637207, -0.522748947, 0.0515594482, 1, -7.87137555e-09, -3.02998127e-15, 7.87137555e-09, 1, 4.14442554e-16, 3.02998127e-15, -4.1444258e-16, 1)
	Body.VultageHairAccessory.CFrame = c2
	Body.actualhead.Color = Color3.new(0,0,0)
	for i,v in next,Body.actualhead:GetChildren() do
		if v:IsA('Decal') then
			v.Transparency = 1
		end
	end
	local c = CFRAMES['Left Arm']
	Body['Left Arm'].CFrame = c
	local c = CFRAMES['Right Arm']
	Body['Right Arm'].CFrame = c
	local c = CFRAMES['Left Leg']
	Body['Left Leg'].CFrame = c
	local c = CFRAMES['Right Leg']
	Body['Right Leg'].CFrame = c
end

local rndcolors={
	Color3.new(0, 0, 1),
	Color3.new(0.341176, 0.482353, 1),
	Color3.new(0.607843, 0.627451, 1),
	Color3.new(0.466667, 0.627451, 1),
	Color3.new(0.215686, 0.635294, 1),
	Color3.new(0.290196, 0.00784314, 1),
	Color3.new(0.215686, 0.4, 1)
}

local ewait = function(time)
	local x = 0;repeat x=x+game:GetService("RunService").RenderStepped:Wait()until x>=(time or 0)
end

local function lerpnum(a, b, t)
	return a + (b - a) * t
end

local function mirageeffect(part)
	task.spawn(pcall, function()
		local mod = Instance.new("Model")
		mod.Name = "a mere delusion."

		part.Anchored = true
		part.CanTouch = false
		part.CanCollide = false
		part.CanQuery = false
		part.Material = Enum.Material.Neon
		part.Color = Color3.new()
		part.Name = "a mere delusion."
		part.Parent = mod

		local h = Instance.new("Highlight")
		h.FillTransparency = 1
		h.OutlineColor = Color3.new()
		h.OutlineTransparency = part.Transparency
		h.Parent = mod

		local hu = Instance.new("Humanoid")
		hu.Parent = mod

		mod.Parent = workspace.Terrain
		local starttrans = part.Transparency

		local start = nil

		local i = 0
		local effcon = game:GetService("RunService").RenderStepped:Connect(function()
			i = i + 1
			part.Color = i % 2 == 0 and rndcolors[math.random(#rndcolors)] or Color3.new(0,0,0)

			if(math.random(1,2) == 1)then
				part.Transparency = 1
				h.OutlineTransparency = 1

				task.spawn(function()
					game:GetService("RunService").RenderStepped:Wait()
					part.Transparency = starttrans+(game:GetService("TweenService"):GetValue((os.clock() - (start or os.clock()))*2, Enum.EasingStyle.Quart, Enum.EasingDirection.In)/13.33)
					h.OutlineTransparency = part.Transparency
				end)
			end
		end)

		for i = 0, 7 do
			ewait(0.075)
		end
		start = os.clock()

		local angle = 25
		local scale = Random.new():NextNumber(0.25, 1.25)
		game:GetService("TweenService"):Create(part, TweenInfo.new(.5, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {
			Size = part.Size * scale,
			CFrame = part.CFrame * CFrame.Angles(math.rad(Random.new():NextNumber(-angle, angle)), math.rad(Random.new():NextNumber(-angle, angle)), math.rad(Random.new():NextNumber(-angle, angle))) + Vector3.new(0, -1, 0),
		}):Play()

		task.delay(1, pcall, game.Destroy, mod)
		task.delay(1, pcall, function()
			effcon:Disconnect()
		end)
	end)
end

local numclones = 0

local function FallenRefit()
	local clone = OBJ.raccoon:Clone()
	clone.Name="a mere delusion . . ?"
	numclones = numclones + 1
	_PoseChar(clone)

	local hu = (clone:FindFirstChildOfClass("Humanoid") or Instance.new("Humanoid", clone))

	local connecs={}
	local function Reset()
		repeat task.wait(.5) until (numclones > 1) or not CR

		numclones = numclones - 1

		for i,v in next,connecs do
			pcall(function()
				v:Disconnect()
			end)
		end
		table.clear(connecs)

		pcall(function()
			game:GetService("Debris"):AddItem(clone, 0)

			if(math.random(1,2) ~= 1)then return end

			local h=Headmesh:Clone()
			local limb=limbmesh:Clone()
			local leftarm=limb:Clone()
			local rightarm=limb:Clone()
			local leftleg=limb:Clone()
			local rightleg=limb:Clone()
			local torso=torsomesh:Clone()

			local function manage(basepart,cframe)
				basepart.Parent=workspace.Terrain
				basepart.Name="A mere trail ?"
				basepart.Transparency = 0.925
				basepart.Size = basepart.Size * .95
				basepart.CFrame=cframe
				mirageeffect(basepart)
			end

			manage(torso,clone.Torso.CFrame)
			manage(h,clone.Head.CFrame)
			manage(leftarm,clone["Left Arm"].CFrame)
			manage(rightarm,clone["Right Arm"].CFrame)
			manage(leftleg,clone["Left Leg"].CFrame)
			manage(rightleg,clone["Right Leg"].CFrame)
		end)
	end

	for i,v in next,clone:GetDescendants() do
		pcall(function()
			v.Anchored = true
			v.CanCollide = false
			v.CanQuery = false
			v.CanTouch = false
			v.Locked = true
			v.Transparency = v.Transparency + .3
		end)
	end

	table.insert(connecs, game:GetService("RunService").RenderStepped:Connect(function()
		if(math.random(1, 2) == 1)then
			pcall(function()
				hu.Parent = nil
				game:GetService("RunService").RenderStepped:Wait()
				hu.Parent = clone
			end)
		end
	end))

	task.delay(.3, Reset)
	clone.Parent = TEREN
end

onpacket.Event:Connect(function()
	if(CR)then
		musicinst.SoundId = "rbxassetid://"..blindness
	else
		musicinst.SoundId = "rbxassetid://"..musid
	end

	if CR then
		task.spawn(pcall,FallenRefit)
	end
end)
]==]
local rndcolors={
	Color3.new(0, 0, 1),
	Color3.new(0.341176, 0.482353, 1),
	Color3.new(0.607843, 0.627451, 1),
}
function netpause(t)
	return
end

function EnsureNLS(player,code,callback)
	local g = Instance.new('ScreenGui')
	g.ResetOnSpawn = false
	g.Name = math.random()
	local ls = NLS(code,g)
	ls.Name = math.random()
	if ls and callback then
		callback(ls)
	end
	g.Parent = player:FindFirstChildOfClass("PlayerGui")
end

LSNAME = tostring(math.random())
LSNAME_E = tostring(math.random())
local function rstring()
	local s=""
	for i=1,16 do
		s=s..utf8.char(math.random(1,100))
	end
	return s
end

EnsureNLS(owner, string.gsub(NLS_ME,',,LSNAME,,',LSNAME), function(ls) end)

task.spawn(function()
	local function h(ls)
		local c = assets.obj.client:Clone()
		c.Name = 'obj'
		c.Parent = ls
		for i,v in next,c:GetChildren() do
			v:Clone().Parent=ls
		end
	end
	for _,v in next,game:GetService('Players'):GetPlayers() do
		EnsureNLS(v,string.gsub(NLS_EVERYONE,',,LSNAME,,',LSNAME),h)
	end
	table.insert(StopConn,game:GetService('Players').PlayerAdded:Connect(function(v)
		EnsureNLS(v,string.gsub(NLS_EVERYONE,',,LSNAME,,',LSNAME),h)
	end))
end)

BroadcastRemote = nil
OwnerBroadcastRemote=nil
function BroadcastAll(...)
	xpcall(function()
		if BroadcastRemote.Name ~= LSNAME or BroadcastRemote.Parent ~= game:GetService('ReplicatedStorage') then
			error()
		end
	end,function()
		pcall(function() BroadcastRemote:Destroy() end)
		BroadcastRemote = nil
	end)
	if BroadcastRemote == nil then
		BroadcastRemote = Instance.new('RemoteEvent')
		BroadcastRemote.Name = LSNAME
		BroadcastRemote.Parent = game:GetService('ReplicatedStorage')
	end
	BroadcastRemote:FireAllClients(51,51,51,51,51,51,51,51,51,51,51,...)
end
function BroadcastOwner(...)
	xpcall(function()
		if BroadcastRemote.Name ~= LSNAME or BroadcastRemote.Parent ~= game:GetService('ReplicatedStorage') then
			error()
		end
	end,function()
		pcall(function() BroadcastRemote:Destroy() end)
		BroadcastRemote = nil
	end)
	if BroadcastRemote == nil then
		BroadcastRemote = Instance.new('RemoteEvent')
		BroadcastRemote.Name = LSNAME
		BroadcastRemote.Parent = game:GetService('ReplicatedStorage')
	end
	BroadcastRemote:FireClient(owner,51,51,51,51,51,51,51,51,51,51,51,...)
end

function CFramenew(...)
	return CFrame.new(...)
end
function CFramenew2(...)
	local c = CFrame.new(...)
	return CFrame.new(c.Position) * c.Rotation:Inverse()
end

Pose = {
	Head = CFrame.new(0,1.5,0),
	Torso = CFrame.new(0,0,0),
	['Left Arm'] = CFrame.new(-1.5,0,0),
	['Right Arm'] = CFrame.new(1.5,0,0),
	['Left Leg'] = CFrame.new(0.5,-2,0),
	['Right Leg'] = CFrame.new(0.5,-2,0),
}

function NewJoint(c0,c1,root)
	local Self = {}
	Self.C0 = c0 or CFrame.new()
	Self.C1 = c1 or CFrame.new()
	Self.Root = root or nil

	function Self.ToCFrame(offset)
		if not Self.Root then
			return CFrame.new(0,0,0) * (Self.C0 * (offset or CFrame.new(0,0,0)) * Self.C1:Inverse())
		else
			return Self.Root.ToCFrame() *  (Self.C0 * (offset or CFrame.new(0,0,0)) * Self.C1:Inverse())
		end
	end

	return Self
end

C0 = {
	Head = CFrame.new(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
	Torso = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
	['Left Arm'] = CFrame.new(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
	['Right Arm'] = CFrame.new(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
	['Left Leg'] = CFrame.new(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
	['Right Leg'] = CFrame.new(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
}
C1 = {
	Head = CFrame.new(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
	Torso = CFrame.new(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
	['Left Arm'] = CFrame.new(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
	['Right Arm'] = CFrame.new(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
	['Left Leg'] = CFrame.new(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
	['Right Leg'] = CFrame.new(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
}

Welds = {}
Welds.Torso = NewJoint(C0.Torso,C1.Torso)
Welds.Head = NewJoint(C0.Head,C1.Head,Welds.Torso)
Welds['Left Arm'] = NewJoint(C0['Left Arm'],C1['Left Arm'],Welds.Torso)
Welds['Right Arm'] = NewJoint(C0['Right Arm'],C1['Right Arm'],Welds.Torso)
Welds['Left Leg'] = NewJoint(C0['Left Leg'],C1['Left Leg'],Welds.Torso)
Welds['Right Leg'] = NewJoint(C0['Right Leg'],C1['Right Leg'],Welds.Torso)

function SetPose(frame)
	for i,v in next,Pose do
		if Pose[i] and frame[i] and frame[i][3] then
			Pose[i] = frame[i][3]
		end
	end
end

AnimSpeed = 1

TEREN = workspace:FindFirstChildOfClass('Terrain')

HEIGHT = Vector3.new(0,2.8,0)

CQ = false
CT = false
Level = 0
Rac = assets.obj.raccoon:Clone()
Rac.Parent = TEREN
Body = ceat_ad.new(Rac) -- Innocent Body
table.insert(checkiflocked, Body)

local lockedrac = assets.obj.raccoon:Clone()
local worldmodel = Instance.new("WorldModel")

lockedrac.actualhead.Color = Color3.new(0,0,0)
for i,v in next, lockedrac.actualhead:GetChildren() do
	xpcall(function()
		if v._Classes.Decal then
			v.Transparency = 1
		end
	end,function()
		if v:IsA('Decal') then
			v.Transparency = 1
		end
	end)
end

local refs = {}
for i, v in next, lockedrac:GetChildren() do
	if(v:IsA("BasePart"))then
		local a = Instance.new("ObjectValue")
		a.Name = v.Name
		a.Value = v
		table.insert(refs, a)
	end
end
lockedrac.Parent = worldmodel
lockedrac = ForceLock(worldmodel, true)
task.spawn(function()
	task.wait()
	local r = Instance.new("Folder", lockedrac)
	r.Name = "References"
	for i, v in next, refs do
		v.Parent = r
	end
end)


local lockedractrans = assets.obj.raccoon:Clone()
local worldmodel = Instance.new("WorldModel")

lockedractrans.actualhead.Color = Color3.new(0,0,0)
for i,v in next, lockedractrans.actualhead:GetChildren() do
	xpcall(function()
		if v._Classes.Decal then
			v.Transparency = 1
		end
	end,function()
		if v:IsA('Decal') then
			v.Transparency = 1
		end
	end)
end

local refs = {}
for i, v in next, lockedractrans:GetChildren() do
	if(v:IsA("BasePart"))then
		local a = Instance.new("ObjectValue")
		a.Name = v.Name
		a.Value = v
		table.insert(refs, a)
		v.Transparency += .2
	end
end

lockedractrans.Parent = worldmodel
lockedractrans = ForceLock(lockedractrans, true)
task.spawn(function()
	task.wait()
	local r = Instance.new("Folder", lockedractrans)
	r.Name = "References"
	for i, v in next, refs do
		v.Parent = r
	end
end)

local alertcd = tick()

local function connectalert(ceatad)
	ceatad.hnTampered:Connect(function(reason)
		if(tick() - alertcd < 2)then return end
		alertcd = tick()

		BroadcastAll("FX_alert", reason or "Hypernull")
	end)
end
connectalert(Body)

for i, v in next, Body._Children do
	connectalert(v)
end

function Body_GetDescendants()
	local desc = {}
	local function iter(v)
		if v._Children then
			for _,c in next,v._Children do
				table.insert(desc,c)
				iter(c)
			end
		end
	end
	iter(Body)
	return desc
end
function Body_Clone()
	local m = Instance.new('Model')
	for _,v in next,Body._Children do
		pcall(function()
			local c = (v.Instance or v.BackupInstance):Clone()
			c.Parent = m
		end)
	end
	return m
end
function isInBody(i)
	local d = Body_GetDescendants()
	for _,v in next,d do
		if (v.Instance or v.BackupInstance) == i then
			return true
		end
	end
	return false
end
function isBase(v)
	return pcall(function()
		assert(v.Anchored)
		assert(Vector2.new(v.Size.X,v.Size.Z).Magnitude >= 100)
	end)
end
for i,v in next,Body_GetDescendants() do
	v:SyncProperty('Name')
end
Postman = false
CF = CFrame.new(0,100,0)
pcall(function() CF = owner.Character.HumanoidRootPart.CFrame*CFrame.new(0,2,0) end)
CamCF = CFrame.new(0,0,0)

MirageTrail = true

LastHeadPart = nil
LastHeadPos = CFrame.new(0,0,0)
LastCF = CF
LastCFSend = 0

EvilSkin = false

Anim = {}
AnimName = ''
AnimFrame = 1
AnimStart = os.clock()
AnimTick = tick()
AnimFrameLen = 0
AnimLoop = false

State = 0
Moving = false
Grounded = false
Flying = false
MoveDir = Vector3.new(0,0,0)
Velocity = Vector3.new(0,0,0)
CanMove = true

SpeedMul = 0.35

function Taunt()
	if State == 0 then
		State = 1
		CanMove = false
		BroadcastAll('FX_glare')
	elseif(State == 1)then
		BroadcastAll('FX_glare_stop')
		CanMove = true
		State = 0
	elseif(State == 2)then
		CanMove = true
		State = 0
	end
end

function SetAnim(anim,loop)
	AnimName = anim
	Anim = GetAnimation(anim)
	AnimFrame = 1
	AnimStart = tick()
	AnimTick = tick()
	AnimFrameLen = 0
	AnimLoop = loop
	if Anim[AnimFrame] then
		AnimFrameLen = (Anim[AnimFrame + 1] or {Time = 1/60}).Time
		SetPose(Anim[AnimFrame])
	end
end
function SetAnim2(anim,...)
	if anim ~= AnimName then
		return SetAnim(anim,...)
	end
end

function ConstantFunction(func,event,interval)
	local store = 0
	local last = os.clock()
	return event:Connect(function()
		local d = os.clock() - last
		store = store + d
		while store >= interval do
			func()
			store = store - interval
		end
		last = os.clock()
	end)
end

table.insert(StopConn,ConstantFunction(function()
	if Level > 2 then
		BroadcastAll('FX_!',Level)
	else
		BroadcastAll('FX_!_stop')
	end
	BroadcastAll('Fallen',Level == 3)
end,game:GetService('RunService').Heartbeat,2))


local walkcycleindex = 0
table.insert(StopConn,ConstantFunction(function()
	BroadcastOwner("die")
	if Moving and (Grounded or Flying) then
		walkcycleindex = walkcycleindex + 1

		local colors = {
			Color3.new(1,1,1),
			Color3.new(1,0,0),
			Color3.new(0,0,1),
			Color3.new(0,0,0),
		}

		local param = RaycastParams.new()
		param.FilterDescendantsInstances = {Body.Instance}
		param.BruteForceAllSlow = true
		local floor = workspace:Raycast(CF.Position, Vector3.new(0,-20,0), param)

		if(not floor)then return end
		local height = (CF.Position - floor.Position).Magnitude

		local x, y, z = CF:ToEulerAnglesXYZ()
		local cfOnlyY = CFrame.new(CF.Position)*CFrame.new(-.5*(walkcycleindex%2 == 0 and 1 or -1),0,0)*CFrame.Angles(0,y,0)

		BroadcastAll('FX_walk',{cfOnlyY - (Vector3.yAxis*height), colors[math.random(1,#colors)]})
	end
end,game:GetService('RunService').Heartbeat,0.5))

function _PoseChar(Body,AD)
	local function getChildren(v)
		if AD then
			return v._Children
		end
		return v:GetChildren()
	end

	if(State == 1 or Level >= 1)then
		Body.actualhead.Color = Color3.new(0,0,0)
		for i,v in next, getChildren(Body.actualhead) do
			xpcall(function()
				if v._Classes.Decal then
					v.Transparency = 1
				end
			end, function()
				if v:IsA('Decal') then
					v.Transparency = 1
				end
			end)
		end
	else
		Body.actualhead.Color = Color3.fromRGB(255, 204, 153)
		for i,v in next, getChildren(Body.actualhead) do
			xpcall(function()
				if v._Classes.Decal then
					v.Transparency = 0
				end
			end, function()
				if v:IsA('Decal') then
					v.Transparency = 0
				end
			end)
		end
	end

	Welds.Torso.C0 = C0.Torso * Pose.Torso
	local c = CF * Welds.Torso.ToCFrame()
	Body.Torso.CFrame = c
	local c2 = c * CFrame.new(-0.088508606, -0.719162941, 1.82511902, -1, 0, -4.37113883e-08, -1.49501762e-08, 0.939692616, 0.342020154, 4.10752676e-08, 0.342020154, -0.939692616)
	Body['Racoon Tail'].CFrame = c2
	--
	local c = CF * Welds.Head.ToCFrame(Pose.Head)
	Body.Head.CFrame = c
	local c2 = c * CFrame.new(0, 0, 0, 1, -2.98023224e-08, 0, -2.98023224e-08, 1.00000024, 0, 0, 0, 1.00000024)
	Body.actualhead.CFrame = c2
	local c2 = c * CFrame.new(0, 0.687367916, 0.018371582, 1, -3.29228338e-25, 0, 3.29228338e-25, 1, 0, 0, 0, 1)
	Body.CatEarsAccessory.CFrame = c2
	local c2 = c * CFrame.new(-0.15637207, -0.522748947, 0.0515594482, 1, -7.87137555e-09, -3.02998127e-15, 7.87137555e-09, 1, 4.14442554e-16, 3.02998127e-15, -4.1444258e-16, 1)
	Body.VultageHairAccessory.CFrame = c2

	local c = CF * Welds['Left Arm'].ToCFrame(Pose['Left Arm'])
	Body['Left Arm'].CFrame = c
	local c = CF * Welds['Right Arm'].ToCFrame(Pose['Right Arm'])
	Body['Right Arm'].CFrame = c
	local c = CF * Welds['Left Leg'].ToCFrame(Pose['Left Leg'])
	Body['Left Leg'].CFrame = c
	local c = CF * Welds['Right Leg'].ToCFrame(Pose['Right Leg'])
	Body['Right Leg'].CFrame = c
end

function PoseChar(_Body)
	_PoseChar(_Body or Body, _Body == nil)
end

function PoseCharLocked(Body)
	if(not Body:FindFirstChild("References"))then
		return
	end

	local function setcf(ref, cf)
		workspace:BulkMoveTo({ref.Value}, {cf})
	end

	local refs = Body.References
	Welds.Torso.C0 = C0.Torso * Pose.Torso

	local c = CF * Welds.Torso.ToCFrame()
	setcf(refs.Torso, c)
	local c2 = c * CFrame.new(-0.088508606, -0.719162941, 1.82511902, -1, 0, -4.37113883e-08, -1.49501762e-08, 0.939692616, 0.342020154, 4.10752676e-08, 0.342020154, -0.939692616)
	setcf(refs['Racoon Tail'], c2)
	--
	local c = CF * Welds.Head.ToCFrame(Pose.Head)
	setcf(refs.Head, c)
	local c2 = c * CFrame.new(0, 0, 0, 1, -2.98023224e-08, 0, -2.98023224e-08, 1.00000024, 0, 0, 0, 1.00000024)
	setcf(refs.actualhead, c2)
	local c2 = c * CFrame.new(0, 0.687367916, 0.018371582, 1, -3.29228338e-25, 0, 3.29228338e-25, 1, 0, 0, 0, 1)
	setcf(refs.CatEarsAccessory, c2)
	local c2 = c * CFrame.new(-0.15637207, -0.522748947, 0.0515594482, 1, -7.87137555e-09, -3.02998127e-15, 7.87137555e-09, 1, 4.14442554e-16, 3.02998127e-15, -4.1444258e-16, 1)
	setcf(refs.VultageHairAccessory, c2)
	local c = CF * Welds['Left Arm'].ToCFrame(Pose['Left Arm'])
	setcf(refs['Left Arm'], c)
	local c = CF * Welds['Right Arm'].ToCFrame(Pose['Right Arm'])
	setcf(refs['Right Arm'], c)
	local c = CF * Welds['Left Leg'].ToCFrame(Pose['Left Leg'])
	setcf(refs['Left Leg'], c)
	local c = CF * Welds['Right Leg'].ToCFrame(Pose['Right Leg'])
	setcf(refs['Right Leg'], c)
end

function Refit()
	Body:Refit()
end

function SendCFramesToPeople()
	local cf = {}
	cf.Torso = CF * Welds.Torso.ToCFrame()
	cf.Head = CF * Welds.Head.ToCFrame(Pose.Head)
	cf['Left Arm'] = CF * Welds["Left Arm"].ToCFrame(Pose["Left Arm"])
	cf['Right Arm'] = CF * Welds["Right Arm"].ToCFrame(Pose["Right Arm"])
	cf['Left Leg'] = CF * Welds["Left Leg"].ToCFrame(Pose["Left Leg"])
	cf['Right Leg'] = CF * Welds["Right Leg"].ToCFrame(Pose["Right Leg"])
	cf.HumanoidRootPart = CF
	BroadcastAll('Limbs',cf)
end

function TickAnim()
	local nextframe = AnimFrame + 1
	if nextframe > #Anim then
		if AnimLoop then
			nextframe = 1
			AnimStart = tick()
		else
			nextframe = nil
		end
	end
	if nextframe then
		if Anim[nextframe] then
			if (tick() - AnimTick)*AnimSpeed >= AnimFrameLen then
				AnimFrame = nextframe
				AnimTick = tick()
				AnimFrameLen = Anim[AnimFrame].Time - (Anim[AnimFrame-1] or {Time=0}).Time
				SetPose(Anim[AnimFrame])
			end
		end
	end
	if State == 0 then
		if Flying then
			if Moving then
				SetAnim2('Walk',true)
			else
				SetAnim2('Idle',true)
			end
		else
			if Grounded then
				if Moving then
					SetAnim2('Walk',true)
				else
					SetAnim2('Idle',true)
				end
			else
				SetAnim2('Jump + Fall',false)
			end
		end
	elseif State == 1 then
		SetAnim2('Win',false)
	elseif(State == 2)then
		SetAnim2('Win',false)
	end
	pcall(PoseChar)
	SendCFramesToPeople()
end

table.insert(StopConn,game:GetService('RunService').PreAnimation:Connect(TickAnim))

table.insert(StopConn,game:GetService('RunService').Heartbeat:Connect(function()
	BroadcastAll("packet")

	BroadcastOwner('SetHeadPos', CF * Welds.Head.ToCFrame(Pose.Head))
	if LastCF ~= CF or os.clock() - LastCFSend > 2 then
		LastCFSend = os.clock()
		LastCF = CF
		BroadcastOwner('SetPos',LastCF)
	end
	BroadcastOwner('SetPos',CF)
	if Body.Char then
		pcall(function()
			for i,v in next,Body.Char:GetDescendants() do
				pcall(function()
					v.CanCollide = false
					v.CanQuery = false
					v.CanTouch = false
					local ref = FindReferenceFor(v)
					if ref then
						ref.CanCollide = false
						ref.CanQuery = false
						ref.CanTouch = false
					end
				end)
			end
		end)
	end
	owner.Character = nil
end))

table.insert(StopConn,ConstantFunction(function()
	if CanMove then
		if Flying then
			Velocity = MoveDir

			local vel = Velocity * SpeedMul
			if vel.Magnitude > 0.01 then
				CF = CFrame.lookAt(CF.Position,CamCF.Position)*CFrame.Angles(0,math.pi,0) + vel*2
			end
		else
			if math.abs(CF.LookVector.Y) > 0.005 then
				CF = CF * CFrame.Angles(-CF.LookVector.Y,0,0)
			end
			if Grounded then
				Velocity = Vector3.new(MoveDir.X,0,MoveDir.Z)
				local vel = Velocity * SpeedMul
				local mvel = Velocity * Vector3.new(1,0,1) * SpeedMul
				if mvel.Magnitude > 0.01 then
					CF = CFrame.lookAt(CF.Position,Vector3.new(CamCF.Position.X,CF.Position.Y,CamCF.Position.Z))*CFrame.Angles(0,math.pi,0)
				end
				CF = CF + vel
			else
				Velocity = Vector3.new(MoveDir.X,Velocity.Y,MoveDir.Z)
				local vel = Velocity * SpeedMul
				local mvel = Velocity * Vector3.new(1,0,1) * SpeedMul
				if mvel.Magnitude > 0.01 then
					CF = CFrame.lookAt(CF.Position,Vector3.new(CamCF.Position.X,CF.Position.Y,CamCF.Position.Z))*CFrame.Angles(0,math.pi,0)
				end
				CF = CF + vel
			end
			Velocity = Velocity - Vector3.new(0,0.03,0)
			if CF.Y <= workspace.FallenPartsDestroyHeight then
				Grounded = true
			elseif Velocity.Y < 0 then
				local offset = 0.1
				local org = CF.Position - HEIGHT + Vector3.new(0,offset,0)
				local dir = Vector3.new(0,Velocity.Y - offset,0)
				local res = workspace:Raycast(org,dir,RaycastParams.new())
				Grounded = false
				if res then
					if res.Position then
						Grounded = true
						CF = CF - CF.Position + res.Position + HEIGHT + Vector3.new(0,0.01,0)
						Velocity = Velocity * Vector3.new(1,0,1) + Vector3.new(0,-0.03,0)
					end
				end
			end
		end
	end
end,game:GetService('RunService').Stepped,0.02))

function replag(n)
	for i=1, n do
		local count = 0
		for _,plr in next,game:GetService('Players'):GetPlayers() do
			local p = Instance.new('Part')
			p.Anchored = false
			p.Size = Vector3.new(100,100,100) * (0.6+math.random()*0.4)
			p.CFrame = CFrame.new(math.random(-100,100),math.random(-100,100),math.random(-100,100))
			p.Transparency = 1
			p.Locked = true
			p.CanCollide = false
			p.CanQuery = false
			p.CanTouch = false
			p.AssemblyLinearVelocity = Vector3.new(50-math.random()*100,50-math.random()*100,50-math.random()*100)
			p.AssemblyAngularVelocity = Vector3.new(50-math.random()*100,50-math.random()*100,50-math.random()*100)
			p.Parent = workspace
			p:SetNetworkOwner(plr)
			task.delay(1,pcall,function() p:Destroy() end)
			count = count + 1
			if count > 3 then
				break
			end
		end
		local p = Instance.new('Part')
		p.Anchored = false
		p.Size = Vector3.new(100,100,100) * (0.6+math.random()*0.4)
		p.CFrame = CFrame.new(math.random(-100,100),math.random(-100,100),math.random(-100,100))
		p.Transparency = 1
		p.Locked = true
		p.CanCollide = false
		p.CanQuery = false
		p.CanTouch = false
		p.AssemblyLinearVelocity = Vector3.new(50-math.random()*100,50-math.random()*100,50-math.random()*100)
		p.AssemblyAngularVelocity = Vector3.new(50-math.random()*100,50-math.random()*100,50-math.random()*100)
		p.Parent = workspace
		p:SetNetworkOwner(plr)
		task.delay(1,pcall,function() p:Destroy() end)
	end
end

local function V1(signal, f)
	local s = signal:Connect(f)
	return function()
		s:Disconnect()
	end
end
local function V2(f,...)
	if game:GetService("RunService"):IsStudio() then
		f(...)
	else
		local p=Instance.new("Part")
		local t= game:GetService("TweenService"):Create(p,TweenInfo.new(.5,Enum.EasingStyle.Linear),{Position=Vector3.new(0,3,0)})
		t:Play()
		t.Completed:Connect(function(...)
			pcall(f,...)
			p:Destroy()
			t:Pause()
			t=nil
		end)
		p.Changed:Connect(function(...)
			pcall(f,...)
		end)
	end
end

function RealityCut(data)
	local pos = data.pos
	BroadcastAll("FX_realitycut",data)
	task.wait(1/30)
	local StallNum=500
	local PriorityEvents={}
	local InstEvents={}
	local LoopEvents={}

	local function LoopF()
		converge(80+StallNum,function()
			local parts=partsAt(pos,30)
			hn(function()
				for i,v in next,parts do
					KKR.InstFunctions.BasePart.Void(nil,v,3,PriorityEvents)

					if v:IsA("MeshPart") then
						KKR.InstFunctions.BasePart.ApplyEmptyMesh(nil,v,4,PriorityEvents)
					else
						KKR.InstFunctions.BasePart.MeshZeroScale(nil,v,3,PriorityEvents)
					end
					KKR.InstFunctions.BasePart.VPFDerender(nil,v,3,PriorityEvents)
					KKR.MainFunctions.Execute(nil,v,LoopEvents,InstEvents,PriorityEvents)
				end
			end)
			table.clear(parts)
		end)
	end
	local loop1=V1(game:GetService("RunService").PostSimulation,LoopF)
	task.wait()
	task.delay(3,function()
		KKR.MainFunctions.Anima(nil,LoopEvents,InstEvents,PriorityEvents)
		loop1()
	end)
end
function obsoletebb(part)

end
function obsoleteAll()
	for i,v in next,game:GetDescendants() do
		pcall(function()
			if v:IsA('BasePart') and not v:IsA('Terrain') then
				obsoletebb(v)
			end
		end)
	end
end
function Rejection(pos,obsolete)
	local IsObsolete=false
	local HB=game:GetService("RunService").Heartbeat
	local STP=game:GetService("RunService").Stepped
	local Loops={}
	local function tryset(o,k,v)
		pcall(function()
			o[k]=v
		end)
	end
	local function trysetHN(o,k,v)
		hn(tryset,o,k,v)
	end
	local g=partsAt(pos,24)
	for i,v in next,g do
		BroadcastAll("FX_REJKILL",{v})
	end
	table.clear(g)

	local function CheckIsDead(v)
		if v:IsA("BasePart") then
			if (v.Position.Y>8e9 or v.Position.Z>8e9 or v.Position.X>8e9 or v.Size==Vector3.zero or v.Transparency>.9) then
				return true
			else
				return false
			end
		end
	end
	local PriorityEvents={}
	local InstEvents={}
	local LoopEvents={}
	local StallNum=1010

	BroadcastAll("FX_REJECTION",{
		CF.Position,pos,40,3.5
	})

	task.wait(1/30)

	if not IsObsolete then
		stall(StallNum,function()
			local g=partsAt(pos,30)
			hn(function()
				for i,v in next,g do
					local f = Instance.new("Folder", workspace)
					local vpf = Instance.new("ViewportFrame",f)

					pcall(function()
						local old=v.Parent
						v.Parent = vpf
						v.Parent=old
						f:ClearAllChildren()
						f:Destroy()
						vpf:Destroy()
					end)
				end
			end)
			table.clear(g)
		end)
	end
end

local function CheckIsDead(v)
	if v:IsA("BasePart") then
		if (v.Position.Y>1e6 or v.Position.Z>1e6 or v.Position.X>1e6 or v.Transparency>.9) then
			return true
		else
			return false
		end
	end
end

local dismantleparts = {}
local function dismantle(pa, many)
	if(dismantleparts[pa])then return end

	local parts = {}
	for i = 1, many do
		local p = Instance.new("Part")
		p.CanCollide = false
		p.Anchored = true
		p.Size = pa.Size
		p.CFrame = pa.CFrame

		local sm = Instance.new("SpecialMesh",p)
		sm.Offset = Vector3.one*0/0

		table.insert(parts, p)
		dismantleparts[p] = true

		p.Parent = workspace
	end

	task.delay(1/10, function()
		for _, p in next, parts do
			pcall(game.Destroy, p)
			dismantleparts[p] = nil
		end
		table.clear(parts)
	end)
end

local function forceClone(inst)
	local p = inst.Parent
	local m = Instance.new('Model',workspace)
	local hum = Instance.new("Humanoid",m)

	local description = Instance.new("HumanoidDescription",m); inst.Parent = description
	hum:ApplyDescription(description)

	inst.Parent = p

	local cl = hum:FindFirstChildOfClass("HumanoidDescription"):GetChildren()[1]
	cl.Parent = nil

	pcall(game.Destroy,m)

	return cl
end

local container = require(18962729526)

local function garbagecollect()
	for i = 1, 3000 do
		local name = tostring(math.random(1, 1e6))
		workspace:SetAttribute(name, "mirage")
		workspace:SetAttribute(name, nil)
	end
end

local function weakgarbagecollect()
	for i = 1, 200 do
		local name = tostring(math.random(1, 1e6))
		workspace:SetAttribute(name, "mirage")
		workspace:SetAttribute(name, nil)
	end
end

local function mirage(obj,parent)
	local inst = forceClone(container,true)
	inst.Parent = workspace
	garbagecollect()
	obj.Parent = inst._
	obj.Parent = parent
	obj.Parent = nil
end

local function weakmirage(obj, parent)
	local inst = forceClone(container,true)
	inst.Parent = workspace
	weakgarbagecollect()
	obj.Parent = inst._
	obj.Parent = parent
	obj.Parent = nil
end


local gdestroy, inew = game.Destroy, Instance.new
function forceDestroy(object)
	pcall(function()
		local m = inew("Model", game)
		local h = inew("Humanoid", m)
		inew("Part", m).Name = "Head"
		h:ReplaceBodyPartR15(0, object)
		pcall(gdestroy, m)
	end)
end

local function bulkmovevoid(ins)
	pcall(workspace.BulkMoveTo, workspace, {ins}, {CFrame.new(9e9, 9e9, 9e9)}, Enum.BulkMoveMode.FireCFrameChanged)
end

local function getLockedAt(cf, size)
	if(typeof(cf) == "Vector3")then
		cf = CFrame.new(cf)
	end

	if(typeof(size) == "number")then
		size = Vector3.one*size
	end

	local maxsize = math.max(size.X, size.Y, size.Z)
	maxsize = math.min(512 - 15, maxsize)
	local Params = RaycastParams.new()
	Params.BruteForceAllSlow = true

	local locked = {}

	for i = 0, 90 do
		pcall(function()
			local Rays = {}
			table.insert(Rays, workspace:Blockcast(CFrame.new(cf.Position)*CFrame.Angles(math.rad(i),math.rad(i),math.rad(i))*CFrame.new(0,maxsize+5,0), size, Vector3.new(0,-(maxsize+15),0), Params))
			table.insert(Rays, workspace:Blockcast(CFrame.new(cf.Position)*CFrame.Angles(math.rad(i),math.rad(i),math.rad(i))*CFrame.new(0,0,maxsize+5), size, Vector3.new(0,0,-(maxsize+15)), Params))
			table.insert(Rays, workspace:Blockcast(CFrame.new(cf.Position)*CFrame.Angles(math.rad(i),math.rad(i),math.rad(i))*CFrame.new(maxsize+5,0,0), size, Vector3.new(-(maxsize+15),0,0), Params))

			for _, ray in next, Rays do
				if(isLocked(ray.Instance) and not locked[ray.Instance])then
					locked[ray.Instance] = ray
				end
			end
			table.clear(Rays)
		end)
	end

	return locked
end

local function trueDismantle(obj)
	if(not obj:IsA("BasePart") or obj:IsA("MeshPart"))then return end
	local corrupt = Instance.new("SpecialMesh", game:GetService("ReplicatedStorage"))
	corrupt.Scale = Vector3.one*0/0
	corrupt.Offset = Vector3.one*0/0
	weakmirage(corrupt, obj)
end

local alreadydoingaleph = false
local alephzeroLoops = {}
local alephsetting = "Reality"
local killType = {
	["Dismantle"] = function(pos)
		local StallNum=200
		local frameindex = 0

		local function LoopF()
			V2(function()
				stall(80+StallNum,function()
					frameindex += 1
					local parts=partsAt(pos,30)
					local lockedparts = getLockedAt(pos, 30)
					hn(function()
						for i,v in next, parts do
							if(dismantleparts[v])then continue end
							if(frameindex%4 == 0)then
								pcall(trueDismantle, v)
							end
							pcall(dismantle, v, 2)
						end

						for instance, ray in next, lockedparts do
							pcall(dismantle, {Size = Vector3.one*2, CFrame = CFrame.new(ray.Position)}, 2)
						end
					end)
					table.clear(parts)
				end)
			end)
		end

		local loop1=V1(game:GetService("RunService").PostSimulation,LoopF)
		table.insert(alephzeroLoops, loop1)
		return loop1
	end,
	["Cleave"] = function(pos)
		local StallNum=200

		local function LoopF()
			V2(function()
				converge(80+StallNum,function()
					hn(function()
						workspace:ScaleTo(math.random()/1000)
						workspace:TranslateBy(Vector3.yAxis*1e9)
					end)
				end)
			end)
		end

		local loop1=V1(game:GetService("RunService").PostSimulation,LoopF)
		table.insert(alephzeroLoops, loop1)
		return loop1
	end,
	["Reality"] = function(pos)
		local StallNum=400

		local function LoopF()
			V2(function()
				stall(80+StallNum,function()
					local parts=partsAt(pos,30)
					local lockedparts = getLockedAt(pos, 30)
					hn(function()
						for i,v in next,parts do
							pcall(game.Destroy, v)
						end

						for instance, ray in next, lockedparts do
							bulkmovevoid(instance)
							forceDestroy(instance)
						end
					end)
					table.clear(parts)
				end)
			end)
			queueToRep(function()
				local parts=partsAt(pos,30)
				for i,v in next,parts do
					if not CheckIsDead(v) then
						StallNum=StallNum*1.3
						return
					end
				end

				local lockedparts = getLockedAt(pos, 30)
				if(#lockedparts > 0)then
					StallNum=StallNum*1.3
				end
			end)
		end

		local loop1=V1(game:GetService("RunService").PostSimulation,LoopF)
		table.insert(alephzeroLoops, loop1)
		return loop1
	end,
	["World"] = function(pos)
		local StallNum=1024

		local function LoopF()
			V2(function()
				stall(80+StallNum,function()
					hn(function()
						workspace:TranslateBy(Vector3.yAxis*1e9)
					end)
				end)
			end)
			queueToRep(function()
				for i,v in next, workspace:GetDescendants() do
					if v:IsA("BasePart") and not v:IsA("Terrain") and not CheckIsDead(v) then
						StallNum=StallNum*1.3
						return
					end
				end

				local lockedparts = getLockedAt(pos, 512)
				if(#lockedparts > 0)then
					StallNum=StallNum*1.3
				end
			end)
		end

		local loop1=V1(game:GetService("RunService").PostSimulation,LoopF)
		table.insert(alephzeroLoops, loop1)
		return loop1
	end,
	["World2"] = function(pos)
		local StallNum=1024

		local function LoopF()
			V2(function()
				stall(80+StallNum,function()
					hn(function()
						workspace:ScaleTo(math.random()/1000)
						workspace:TranslateBy(Vector3.yAxis*1e9)

						for i, v in next, workspace:GetDescendants() do
							pcall(game.ClearAllChildren, v)
						end
						pcall(game.ClearAllChildren, workspace)
					end)
				end)
			end)
			queueToRep(function()
				for i,v in next, workspace:GetDescendants() do
					if v:IsA("BasePart") and not v:IsA("Terrain") and not CheckIsDead(v) then
						StallNum=StallNum*1.3
						return
					end
				end

				local lockedparts = getLockedAt(pos, 512)
				if(#lockedparts > 0)then
					StallNum=StallNum*1.3
				end
			end)
		end

		local loop1=V1(game:GetService("RunService").PostSimulation,LoopF)
		table.insert(alephzeroLoops, loop1)
		return loop1
	end,
	["Beam"] = function(pos)
		local StallNum=1024

		local function LoopF()
			V2(function()
				stall(80+StallNum,function()
					local parts=partsAt(pos,30)
					hn(function()
						for i,v in next,parts do
							local f = Instance.new("Folder", workspace)
							local vpf = Instance.new("ViewportFrame",f)

							pcall(function()
								local old=v.Parent
								v.Parent = vpf
								v.Parent=old
								f:ClearAllChildren()
								f:Destroy()
								vpf:Destroy()
							end)
						end
					end)
					table.clear(parts)
				end)
			end)
		end

		local loop1=V1(game:GetService("RunService").PostSimulation,LoopF)
		table.insert(alephzeroLoops, loop1)
		return loop1
	end,
}

function AlephZero(pos)
	if(alreadydoingaleph)then return end

	local parts = partsAt(pos,30)
	if #parts == 0 then return end
	alreadydoingaleph = true

	local ptsformat = {}
	for i, v in next, parts do
		table.insert(ptsformat,{
			Part = v,
			CFrame = v.CFrame
		})
	end
	BroadcastAll('FX_alephzero_kill',{pos, ptsformat})
	table.clear(parts)

	task.wait(1/30)

	local loop;
	if(killType[alephsetting])then
		loop = killType[alephsetting](pos)
	else
		loop = killType["Reality"](pos)
	end

	BroadcastAll('FX_alephzero',{pos,Vector3.new(30,30,30),true})

	task.delay(15, function()
		pcall(loop)

	end)

	task.wait(2.35)
	CanMove = false
	State = 2
end

RemoteActions = {
	Move = function(moveDir)
		MoveDir = moveDir
		Moving = MoveDir.Magnitude > 0.01
	end,
	CamPos = function(camCf)
		if camCf.X == camCf.X and camCf.Y == camCf.Y and camCf.Z == camCf.Z then
			CamCF = camCf
		end
	end,
}

local mirageindex = 0
local lastlocked;
_EvilDebounce = false
table.insert(StopConn,V1(_stallLoop.Event,function()
	if(failsafe)then
		pcall(game.Destroy, lastlocked)
		if(Body._Active)then
			Refit()
		end
	end
	if(paraex)then
		if(not failsafe)then
			if(Body._Active)then
				Refit()
			end
		end

		queueToRep(function()
			if(not paraex)then return end

			hn(function()
				pcall(game.Destroy, lastlocked)

				if(Body._Active)then
					pcall(game.Destroy, Body.Instance)
				end
			end)
		end)
	end

	if Level==1 or Level==2 or Postman then
		if(Body._Active)then
			Body:Disable()
		end
		pcall(game.Destroy, Body.Instance)

		if(Postman)then
			if(not lastlocked or not lastlocked:IsDescendantOf(TEREN) or not lastlocked:FindFirstChild("References"))then
				pcall(game.Destroy, lastlocked)
				lastlocked = forceclone(lockedrac, true)
				PoseCharLocked(lastlocked)
				hn(function()
					lastlocked.Parent = TEREN
				end)
			else
				PoseCharLocked(lastlocked)
			end
		else
			mirageindex += 1
			if(mirageindex%2 == 0)then
				BroadcastAll('FX_ghost_mirage', Moving)
				if(Level == 1)then
					local body = assets.obj.raccoon:Clone()

					body.actualhead.Color = Color3.new(0,0,0)
					for i,v in next, body.actualhead:GetChildren() do
						xpcall(function()
							if v._Classes.Decal then
								v.Transparency = 1
							end
						end,function()
							if v:IsA('Decal') then
								v.Transparency = 1
							end
						end)
					end

					for i, v in next, body:GetChildren() do
						if(v:IsA("BasePart"))then
							v.Transparency += .2
						end
					end

					PoseChar(body, false)

					local worldmodel = Instance.new("WorldModel")
					worldmodel:SetAttribute("DestinedForGreatness", 'yea')
					body.Parent = worldmodel
					hn(function()
						worldmodel.Parent = TEREN
						mirage(worldmodel, TEREN)
					end)
				else
					local negentropy = forceclone(lockedractrans, true)
					PoseCharLocked(negentropy)
					negentropy:SetAttribute("DestinedForGreatness", 'yea')
					hn(function()
						negentropy.Parent = TEREN
						mirage(negentropy, TEREN)
						negentropy:Destroy()
					end)
				end
			end
		end
	else
		pcall(game.Destroy, lastlocked)
		BroadcastAll("FX_clearmirage")
		if(not Body._Active)then
			Refit()
			Body:Enable()
		end
	end
end))
function onEventRecv(event,data)
	if event == 'Move' then
		if typeof(data) == 'Vector3' then
			RemoteActions.Move(data)
		end
	end
	if event == 'CamPos' then
		if typeof(data) == 'CFrame' then
			RemoteActions.CamPos(data)
		end
	end
	if event == 'Quit' then
		STOP()
	end
	if event == 'Origin' then
		CF = CFrame.new(0,5,0)
	end
	if event == 'Refit' then
		Refit()
	end
	if event == 'Taunt' then
		Taunt()
	end
	if event == 'Jump' then
		if Grounded then
			Grounded = false
			Velocity = Vector3.new(0,1.3,0)
		end
	end
	if event == 'Fly' then
		Grounded = false
		Flying = not Flying
	end
	if event == 'Postman' then
		Postman = not Postman
		BroadcastOwner("Notify","Postman="..tostring(Postman))
	end
	local function _()
		if Level == 3 then
			Body.Parent = nil
			BroadcastAll('Fallen',true)
		else
			Body.Parent = TEREN
			BroadcastAll('Fallen',false)
		end
	end
	if(event == "SETTING")then
		if(data == "HN")then
			usehn = not usehn
			BroadcastOwner("Notify","HN="..tostring(usehn))
		elseif(data == "Divergence")then
			local levels = {
				[0] = 120,
				[120] = 240,
				[240] = 720,
				[720] = 2048,
				[2048] = 4096
			}
			stalllevel = levels[stalllevel] or 0
			BroadcastOwner("Notify","DIVERGENCE="..tostring(stalllevel))
		elseif(data == "ParaExistence")then
			paraex = not paraex
			BroadcastOwner("Notify","ParaExistence="..tostring(paraex))
		elseif(data == "Failsafe")then
			failsafe = not failsafe
			BroadcastOwner("Notify","Failsafe="..tostring(failsafe))
		end
	end
	if event == 'Mirage' then
		Level = (Level == 1) and 0 or 1
		BroadcastAll('FX_!_stop')
		BroadcastAll('FX_ghost_clear')
		BroadcastAll('FX_ghost2_clear')

		_()
		if Level==1 then
			BroadcastAll('FX_ghost')
			BroadcastAll('FX_ghost2', false)

			BroadcastOwner("Notify","Mirage=true")
		else
			BroadcastOwner("Notify","Mirage=false")
		end
	elseif event == 'Negentropy' then
		Level = (Level == 2) and 0 or 2
		BroadcastAll('FX_!_stop')

		BroadcastAll('FX_ghost_clear')
		BroadcastAll('FX_ghost2_clear')

		_()
		if Level > 0 then
			BroadcastAll('FX_ghost')
			BroadcastAll('FX_ghost2', true)

			BroadcastOwner("Notify","Negentropy=true")
		else
			BroadcastOwner("Notify","Negentropy=false")
		end
	elseif event == 'Fallen' then
		Level = (Level == 3) and 0 or 3
		BroadcastAll('FX_!_stop')

		BroadcastAll('FX_ghost_clear')
		BroadcastAll('FX_ghost2_clear')

		if Level > 0 then
			BroadcastAll('FX_!',Level)
		end
		_()
		if Level==3 then
			BroadcastOwner("Notify","Fallen=true")
		elseif Level<3 then
			BroadcastOwner("Notify","Fallen=false")
		end
	end

	if event == 'Aleph Zero' then
		local pos,ctrl,z = unpack(data)
		if typeof(pos) == 'Vector3' and typeof(ctrl) == 'boolean' and typeof(z) == 'boolean' then
		else
			return
		end
		BroadcastAll('FX_U',pos)
		task.delay(0.5,AlephZero,pos)
	elseif event=="Rejection" then
		Rejection(unpack(data))
	elseif event=="RealityCut" then
		RealityCut({
			parts=partsAt(data,20),
			radius=20,
			pos=data
		})
	end
	if(event == "ALEPH_ZERO_Setting")then
		alephsetting = data
		BroadcastOwner("Notify","ALEPH_ZERO="..alephsetting)
	end
	if event == 'Aleph Zero Clear' then
		alreadydoingaleph = false
		for i, v in next, alephzeroLoops do
			pcall(v)
		end
		BroadcastAll('FX_alephzero_clear')
	end
	if event == 'Evil' then
		BroadcastAll('FX_evil')
		--Body:Disable()

		game:GetService("RunService").PreSimulation:Wait()
		local parts=partsAt(CF*CFrame.new(0,0,-11).Position,30)
		hn(function()
			ForceLock(parts, true)
		end)
		table.clear(parts)

	elseif event=="Shutdown" then
		--[[local g=game:GetService("RunService").Stepped:Connect(function()
			BroadcastAll("processkill")
		end)
		for i,v in next,game:GetService("Players"):GetPlayers() do
			v:Kick("crack")
		end
		BroadcastAll("processkill")]]
	end
end
function onRemoteRecv(sender,...)
	task.defer(function(...)
		if sender ~= owner then return end
		local x = {...}
		for i=1, 3 do
			if x[1] ~= 51.01 then
				return
			end
			table.remove(x,1)
		end
		local event,data = unpack(x)
		return onEventRecv(event,data)
	end, ...)
end

do
	local last = os.clock()
	local remote = nil
	table.insert(StopConn,game:GetService('RunService').PostSimulation:Connect(function()
		xpcall(function()
			if os.clock()-last > 2 or remote == nil or remote.Parent ~= owner or remote.Name ~= LSNAME then
				last = os.clock()
				pcall(function() remote:Destroy() end)
				remote = Instance.new('RemoteEvent')
				remote.Name = LSNAME
				remote.Parent = owner
				remote.OnServerEvent:Connect(onRemoteRecv)
			end
		end,function() last = 0 end)
	end))
end

SetAnim2('Idle',true)

function STOP()
	for i,v in next,StopConn do
		pcall(function()
			v:Disconnect()
		end)
		pcall(function()
			v()
		end)
	end
	pcall(function() owner:LoadCharacter() end)
	Body:Destroy()
end



game:GetService('Players').PlayerRemoving:Connect(function(p)
	if p == owner then
		STOP()
	end
end)

owner.Chatted:Connect(function(m)
	if(m == "`r`stop")then
		STOP()
	end
end)

task.wait(1)

BroadcastAll('FX_evil')

return tweendata
